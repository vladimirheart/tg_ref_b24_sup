<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>–ë–∞–∑–∞ –∑–Ω–∞–Ω–∏–π ‚Äî –ü–∞–Ω–µ–ª—å –ø–æ–¥–¥–µ—Ä–∂–∫–∏</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" />
  <link href="{{ url_for('static', filename='style.css') }}" rel="stylesheet" />
  <link href="{{ url_for('static', filename='sidebar.css') }}" rel="stylesheet" />
  <style>
    .knowledge-base-page {
      padding-bottom: 3rem;
    }

    .knowledge-filters .form-label {
      font-size: 0.85rem;
      font-weight: 600;
      color: #495057;
    }

    .knowledge-table-wrapper {
      max-height: 70vh;
      overflow: auto;
      border: 1px solid rgba(0, 0, 0, 0.08);
      border-radius: 0.75rem;
      background: #fff;
      box-shadow: 0 0.75rem 1.5rem rgba(18, 38, 63, 0.03);
    }

    .knowledge-table {
      margin-bottom: 0;
      min-width: 960px;
    }

    .knowledge-table thead th {
      position: sticky;
      top: 0;
      z-index: 2;
      background: #f8f9fb;
      border-bottom: 1px solid rgba(0, 0, 0, 0.08);
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }

    .knowledge-table tbody tr.article-row td:first-child {
      font-weight: 600;
    }

    .knowledge-table tbody tr.article-row td {
      vertical-align: middle;
      white-space: nowrap;
    }

    .knowledge-table tbody tr.article-row td:nth-child(1) {
      white-space: normal;
    }

    .knowledge-table tbody tr.article-row td:nth-child(1) .article-title {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
    }

    .knowledge-table tbody tr.article-row td span.badge-status {
      font-size: 0.75rem;
      font-weight: 600;
      letter-spacing: 0.02em;
    }

    .knowledge-table tbody tr.direction-group-row td,
    .knowledge-table tbody tr.subdirection-row td {
      background: linear-gradient(90deg, rgba(118, 93, 255, 0.08), rgba(118, 93, 255, 0));
      font-weight: 600;
      font-size: 0.95rem;
    }

    .knowledge-table tbody tr.subdirection-row td {
      background: linear-gradient(90deg, rgba(48, 164, 255, 0.12), rgba(48, 164, 255, 0));
      font-weight: 500;
      font-size: 0.9rem;
    }

    .knowledge-table tbody tr.group-empty td {
      text-align: center;
      padding: 2.5rem 1rem;
      color: #6c757d;
      font-size: 0.95rem;
    }

    .group-cell {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.85rem 1rem;
    }

    .group-label {
      flex: 1;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
    }

    .group-toggle-btn {
      border: none;
      background: transparent;
      color: #3b5bdb;
      padding: 0.25rem 0.35rem;
      border-radius: 0.35rem;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 0.95rem;
      transition: background-color 0.2s ease;
    }

    .group-toggle-btn:hover,
    .group-toggle-btn:focus {
      background: rgba(59, 91, 219, 0.12);
      outline: none;
    }

    .group-toggle-btn[data-state="collapsed"]::before {
      content: "‚ñ∂";
    }

    .group-toggle-btn[data-state="expanded"]::before {
      content: "‚ñº";
    }

    .group-toggle-btn span {
      margin-left: 0.4rem;
    }

    .knowledge-summary {
      border: 1px solid rgba(0, 0, 0, 0.05);
      border-radius: 0.75rem;
      padding: 1rem 1.25rem;
      background: #fff;
    }

    @media (max-width: 992px) {
      .knowledge-table {
        min-width: 720px;
      }
    }

    @media (max-width: 768px) {
      .knowledge-table-wrapper {
        border-radius: 0.5rem;
      }

      .group-cell {
        flex-direction: column;
        align-items: flex-start;
        gap: 0.5rem;
      }

      .knowledge-table tbody tr.article-row td {
        white-space: normal;
      }
    }
  </style>
</head>
<body class="with-sidebar sidebar-pinned">
  {% include "_sidebar.html" %}
  <main class="main-content container-fluid">
    <div class="container-fluid mt-4 knowledge-base-page">
      <div class="d-flex flex-column flex-lg-row justify-content-between gap-3 mb-4">
        <div>
          <h2 class="mb-1">üìö –ë–∞–∑–∞ –∑–Ω–∞–Ω–∏–π</h2>
          <p class="text-muted mb-0">–°—Ç–∞—Ç—å–∏ —Å–≥—Ä—É–ø–ø–∏—Ä–æ–≤–∞–Ω—ã –ø–æ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—é –∏ –ø–æ–¥—Ç–∏–ø—É. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ñ–∏–ª—å—Ç—Ä—ã –∏ –ø–æ–∏—Å–∫, —á—Ç–æ–±—ã –±—ã—Å—Ç—Ä–µ–µ –Ω–∞—Ö–æ–¥–∏—Ç—å –Ω—É–∂–Ω—ã–µ –º–∞—Ç–µ—Ä–∏–∞–ª—ã.</p>
        </div>
        <div class="knowledge-summary text-muted small">
          <div>–í—Å–µ–≥–æ —Å—Ç–∞—Ç–µ–π: <span class="fw-semibold" id="knowledgeTotalCount">{{ articles|length }}</span></div>
          <div>–û—Ç–æ–±—Ä–∞–∂–∞–µ—Ç—Å—è: <span class="fw-semibold" id="knowledgeResultsCount">{{ articles|length }}</span></div>
        </div>
      </div>

      <div class="row g-3 knowledge-filters">
        <div class="col-12 col-xl-4">
          <label for="knowledgeSearch" class="form-label">–ü–æ–∏—Å–∫ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é –∏ –∞—Ç—Ä–∏–±—É—Ç–∞–º</label>
          <input type="search" id="knowledgeSearch" class="form-control" placeholder="–ù–∞–ø—Ä–∏–º–µ—Ä: CRM, –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è, –¥–µ–ø–∞—Ä—Ç–∞–º–µ–Ω—Ç..." />
        </div>
        <div class="col-12 col-sm-6 col-lg-3 col-xl-2">
          <label for="filterDirection" class="form-label">–ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</label>
          <select id="filterDirection" class="form-select form-select-sm"></select>
        </div>
        <div class="col-12 col-sm-6 col-lg-3 col-xl-2">
          <label for="filterSubDirection" class="form-label">–ü–æ–¥—Ç–∏–ø –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è</label>
          <select id="filterSubDirection" class="form-select form-select-sm"></select>
        </div>
        <div class="col-12 col-sm-6 col-lg-3 col-xl-2">
          <label for="filterDepartment" class="form-label">–û—Ç–¥–µ–ª</label>
          <select id="filterDepartment" class="form-select form-select-sm"></select>
        </div>
        <div class="col-12 col-sm-6 col-lg-3 col-xl-2">
          <label for="filterType" class="form-label">–¢–∏–ø</label>
          <select id="filterType" class="form-select form-select-sm"></select>
        </div>
        <div class="col-12 col-sm-6 col-lg-3 col-xl-2">
          <label for="filterStatus" class="form-label">–°—Ç–∞—Ç—É—Å</label>
          <select id="filterStatus" class="form-select form-select-sm"></select>
        </div>
        <div class="col-12 col-sm-6 col-lg-3 col-xl-2">
          <label for="filterAuthor" class="form-label">–ê–≤—Ç–æ—Ä</label>
          <select id="filterAuthor" class="form-select form-select-sm"></select>
        </div>
        <div class="col-12 d-flex flex-wrap align-items-center gap-2 justify-content-between">
          <div class="text-muted small">–ù–∞—Å—Ç—Ä–æ–π—Ç–µ —Ñ–∏–ª—å—Ç—Ä—ã –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ø–æ–∏—Å–∫. –î–æ—Å—Ç—É–ø–Ω–∞ –∏–µ—Ä–∞—Ä—Ö–∏—è –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–π —Å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å—é —Å–≤–µ—Ä–Ω—É—Ç—å —Ä–∞–∑–¥–µ–ª—ã.</div>
          <button id="knowledgeResetFilters" type="button" class="btn btn-outline-secondary btn-sm">–°–±—Ä–æ—Å–∏—Ç—å —Ñ–∏–ª—å—Ç—Ä—ã</button>
        </div>
      </div>

      <div class="knowledge-table-wrapper mt-4">
        <table class="table table-hover align-middle knowledge-table" id="knowledgeTable">
          <thead>
            <tr>
              <th scope="col">–ù–∞–∑–≤–∞–Ω–∏–µ</th>
              <th scope="col">–û—Ç–¥–µ–ª</th>
              <th scope="col">–¢–∏–ø</th>
              <th scope="col">–°—Ç–∞—Ç—É—Å</th>
              <th scope="col">–ê–≤—Ç–æ—Ä</th>
              <th scope="col">–ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</th>
              <th scope="col">–ü–æ–¥—Ç–∏–ø –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è</th>
            </tr>
          </thead>
          <tbody id="knowledgeTableBody">
          </tbody>
        </table>
      </div>
    </div>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  <script src="{{ url_for('static', filename='sidebar.js') }}"></script>
  <script src="{{ url_for('static', filename='modal-transitions.js') }}"></script>
  <script>
    (function () {
      const articles = ({{ articles | tojson | safe }} || []).map((item) => ({
        id: item.id,
        title: (item.title || '').trim(),
        department: (item.department || '').trim(),
        article_type: (item.article_type || '').trim(),
        status: (item.status || '').trim(),
        author: (item.author || '').trim(),
        direction: (item.direction || '').trim(),
        direction_subtype: (item.direction_subtype || '').trim(),
      }));

      const EMPTY_TOKEN = '__EMPTY__';
      const localeOptions = { sensitivity: 'base', numeric: true };
      const tableBody = document.getElementById('knowledgeTableBody');
      const searchInput = document.getElementById('knowledgeSearch');
      const directionSelect = document.getElementById('filterDirection');
      const subDirectionSelect = document.getElementById('filterSubDirection');
      const departmentSelect = document.getElementById('filterDepartment');
      const typeSelect = document.getElementById('filterType');
      const statusSelect = document.getElementById('filterStatus');
      const authorSelect = document.getElementById('filterAuthor');
      const resultsCountEl = document.getElementById('knowledgeResultsCount');
      const totalCountEl = document.getElementById('knowledgeTotalCount');
      const resetButton = document.getElementById('knowledgeResetFilters');
      const COLUMN_COUNT = 7;

      if (totalCountEl) {
        totalCountEl.textContent = String(articles.length);
      }

      const collapsedDirections = new Set();
      const collapsedSubDirections = new Set();

      function normalize(value) {
        return (value || '').trim();
      }

      function displayValue(value, fallback) {
        const normalized = normalize(value);
        return normalized ? normalized : fallback;
      }

      function matchesSingle(articleValue, filterValue) {
        if (!filterValue || filterValue === 'all') {
          return true;
        }
        const normalized = normalize(articleValue);
        if (filterValue === EMPTY_TOKEN) {
          return !normalized;
        }
        return normalized.toLowerCase() === filterValue.toLowerCase();
      }

      function buildValueOptions(field, emptyLabel) {
        const values = new Map();
        articles.forEach((article) => {
          const raw = normalize(article[field]);
          if (!raw) {
            if (!values.has(EMPTY_TOKEN)) {
              values.set(EMPTY_TOKEN, { value: EMPTY_TOKEN, label: emptyLabel });
            }
            return;
          }
          const key = raw.toLowerCase();
          if (!values.has(key)) {
            values.set(key, { value: article[field], label: article[field] });
          }
        });
        const sorted = Array.from(values.entries())
          .filter(([key]) => key !== EMPTY_TOKEN)
          .sort((a, b) => a[1].label.localeCompare(b[1].label, 'ru', localeOptions))
          .map(([, value]) => value);
        if (values.has(EMPTY_TOKEN)) {
          sorted.push(values.get(EMPTY_TOKEN));
        }
        return sorted;
      }

      function populateSelect(select, options, placeholder) {
        const previous = select.value;
        select.innerHTML = '';
        const allOption = document.createElement('option');
        allOption.value = 'all';
        allOption.textContent = placeholder;
        select.appendChild(allOption);
        options.forEach((option) => {
          const opt = document.createElement('option');
          opt.value = option.value;
          opt.textContent = option.label;
          select.appendChild(opt);
        });
        const hasPrevious = Array.from(select.options).some((opt) => opt.value === previous);
        select.value = hasPrevious ? previous : 'all';
      }

      function updateSubDirectionOptions() {
        const directionValue = directionSelect.value;
        const source = directionValue === 'all'
          ? articles
          : articles.filter((article) => matchesSingle(article.direction, directionValue));
        const values = new Map();
        source.forEach((article) => {
          const raw = normalize(article.direction_subtype);
          if (!raw) {
            if (!values.has(EMPTY_TOKEN)) {
              values.set(EMPTY_TOKEN, { value: EMPTY_TOKEN, label: '–ë–µ–∑ –ø–æ–¥—Ç–∏–ø–∞ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è' });
            }
            return;
          }
          const key = raw.toLowerCase();
          if (!values.has(key)) {
            values.set(key, { value: article.direction_subtype, label: article.direction_subtype });
          }
        });
        const sorted = Array.from(values.entries())
          .filter(([key]) => key !== EMPTY_TOKEN)
          .sort((a, b) => a[1].label.localeCompare(b[1].label, 'ru', localeOptions))
          .map(([, value]) => value);
        if (values.has(EMPTY_TOKEN)) {
          sorted.push(values.get(EMPTY_TOKEN));
        }
        populateSelect(subDirectionSelect, sorted, '–í—Å–µ –ø–æ–¥—Ç–∏–ø—ã');
      }

      function getFilteredArticles() {
        const searchValue = searchInput.value.trim().toLowerCase();
        const directionValue = directionSelect.value;
        const subDirectionValue = subDirectionSelect.value;
        const departmentValue = departmentSelect.value;
        const typeValue = typeSelect.value;
        const statusValue = statusSelect.value;
        const authorValue = authorSelect.value;

        return articles.filter((article) => {
          if (!matchesSingle(article.direction, directionValue)) {
            return false;
          }
          if (!matchesSingle(article.direction_subtype, subDirectionValue)) {
            return false;
          }
          if (!matchesSingle(article.department, departmentValue)) {
            return false;
          }
          if (!matchesSingle(article.article_type, typeValue)) {
            return false;
          }
          if (!matchesSingle(article.status, statusValue)) {
            return false;
          }
          if (!matchesSingle(article.author, authorValue)) {
            return false;
          }
          if (searchValue) {
            const haystack = [
              article.title,
              article.department,
              article.article_type,
              article.status,
              article.author,
              article.direction,
              article.direction_subtype,
            ]
              .join(' ')
              .toLowerCase();
            if (!haystack.includes(searchValue)) {
              return false;
            }
          }
          return true;
        });
      }

      function groupArticles(data) {
        const grouped = new Map();
        data.forEach((article) => {
          const directionKey = normalize(article.direction) || EMPTY_TOKEN;
          const directionLabel = displayValue(article.direction, '–ë–µ–∑ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è');
          if (!grouped.has(directionKey)) {
            grouped.set(directionKey, {
              label: directionLabel,
              subgroups: new Map(),
            });
          }
          const entry = grouped.get(directionKey);
          const subKey = normalize(article.direction_subtype) || EMPTY_TOKEN;
          const subLabel = displayValue(article.direction_subtype, '–ë–µ–∑ –ø–æ–¥—Ç–∏–ø–∞ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è');
          if (!entry.subgroups.has(subKey)) {
            entry.subgroups.set(subKey, { label: subLabel, items: [] });
          }
          entry.subgroups.get(subKey).items.push(article);
        });
        return Array.from(grouped.entries()).sort((a, b) =>
          a[1].label.localeCompare(b[1].label, 'ru', localeOptions)
        );
      }

      function renderTable() {
        const filtered = getFilteredArticles();
        const grouped = groupArticles(filtered);
        tableBody.innerHTML = '';

        if (resultsCountEl) {
          resultsCountEl.textContent = String(filtered.length);
        }

        if (!filtered.length) {
          const emptyRow = document.createElement('tr');
          emptyRow.className = 'group-empty';
          const cell = document.createElement('td');
          cell.colSpan = COLUMN_COUNT;
          cell.textContent = '–ù–µ—Ç —Å—Ç–∞—Ç–µ–π, —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏—Ö –≤—ã–±—Ä–∞–Ω–Ω—ã–º —É—Å–ª–æ–≤–∏—è–º.';
          emptyRow.appendChild(cell);
          tableBody.appendChild(emptyRow);
          return;
        }

        grouped.forEach(([directionKey, directionEntry]) => {
          const directionRow = document.createElement('tr');
          directionRow.className = 'direction-group-row';
          const dirCell = document.createElement('td');
          dirCell.colSpan = COLUMN_COUNT;
          dirCell.classList.add('group-cell', 'direction-cell');
          const dirToggle = document.createElement('button');
          dirToggle.type = 'button';
          dirToggle.className = 'group-toggle-btn';
          dirToggle.dataset.state = collapsedDirections.has(directionKey) ? 'collapsed' : 'expanded';
          dirToggle.setAttribute('aria-label', collapsedDirections.has(directionKey) ? '–†–∞–∑–≤–µ—Ä–Ω—É—Ç—å –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ' : '–°–≤–µ—Ä–Ω—É—Ç—å –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ');
          dirToggle.addEventListener('click', () => {
            if (collapsedDirections.has(directionKey)) {
              collapsedDirections.delete(directionKey);
            } else {
              collapsedDirections.add(directionKey);
            }
            renderTable();
          });
          dirCell.appendChild(dirToggle);

          const dirLabel = document.createElement('span');
          dirLabel.className = 'group-label';
          dirLabel.textContent = directionEntry.label;
          dirCell.appendChild(dirLabel);

          const dirCount = Array.from(directionEntry.subgroups.values()).reduce(
            (acc, subgroup) => acc + subgroup.items.length,
            0
          );
          const dirBadge = document.createElement('span');
          dirBadge.className = 'badge text-bg-secondary';
          dirBadge.textContent = dirCount;
          dirCell.appendChild(dirBadge);

          directionRow.appendChild(dirCell);
          tableBody.appendChild(directionRow);

          if (collapsedDirections.has(directionKey)) {
            return;
          }

          const subgroups = Array.from(directionEntry.subgroups.entries()).sort((a, b) =>
            a[1].label.localeCompare(b[1].label, 'ru', localeOptions)
          );

          subgroups.forEach(([subKey, subEntry]) => {
            const combinedKey = `${directionKey}__${subKey}`;
            const subRow = document.createElement('tr');
            subRow.className = 'subdirection-row';
            const subCell = document.createElement('td');
            subCell.colSpan = COLUMN_COUNT;
            subCell.classList.add('group-cell', 'subdirection-cell');

            const subToggle = document.createElement('button');
            subToggle.type = 'button';
            subToggle.className = 'group-toggle-btn';
            subToggle.dataset.state = collapsedSubDirections.has(combinedKey) ? 'collapsed' : 'expanded';
            subToggle.setAttribute('aria-label', collapsedSubDirections.has(combinedKey) ? '–†–∞–∑–≤–µ—Ä–Ω—É—Ç—å –ø–æ–¥—Ç–∏–ø' : '–°–≤–µ—Ä–Ω—É—Ç—å –ø–æ–¥—Ç–∏–ø');
            subToggle.addEventListener('click', () => {
              if (collapsedSubDirections.has(combinedKey)) {
                collapsedSubDirections.delete(combinedKey);
              } else {
                collapsedSubDirections.add(combinedKey);
              }
              renderTable();
            });
            subCell.appendChild(subToggle);

            const subLabel = document.createElement('span');
            subLabel.className = 'group-label';
            subLabel.textContent = subEntry.label;
            subCell.appendChild(subLabel);

            const subBadge = document.createElement('span');
            subBadge.className = 'badge text-bg-light border';
            subBadge.textContent = subEntry.items.length;
            subCell.appendChild(subBadge);

            subRow.appendChild(subCell);
            tableBody.appendChild(subRow);

            if (collapsedSubDirections.has(combinedKey)) {
              return;
            }

            const sortedItems = subEntry.items.slice().sort((a, b) =>
              a.title.localeCompare(b.title, 'ru', localeOptions)
            );

            sortedItems.forEach((article) => {
              const row = document.createElement('tr');
              row.className = 'article-row';

              const cells = [
                displayValue(article.title, '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è'),
                displayValue(article.department, '‚Äî'),
                displayValue(article.article_type, '‚Äî'),
                displayValue(article.status, '‚Äî'),
                displayValue(article.author, '‚Äî'),
                displayValue(article.direction, '–ë–µ–∑ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è'),
                displayValue(article.direction_subtype, '–ë–µ–∑ –ø–æ–¥—Ç–∏–ø–∞ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è'),
              ];

              cells.forEach((text, index) => {
                const td = document.createElement('td');
                td.textContent = text;
                if (index === 0) {
                  td.classList.add('text-break');
                }
                row.appendChild(td);
              });

              tableBody.appendChild(row);
            });
          });
        });
      }

      function resetFilters() {
        searchInput.value = '';
        directionSelect.value = 'all';
        updateSubDirectionOptions();
        subDirectionSelect.value = 'all';
        departmentSelect.value = 'all';
        typeSelect.value = 'all';
        statusSelect.value = 'all';
        authorSelect.value = 'all';
        collapsedDirections.clear();
        collapsedSubDirections.clear();
        renderTable();
      }

      function initFilters() {
        populateSelect(directionSelect, buildValueOptions('direction', '–ë–µ–∑ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è'), '–í—Å–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è');
        populateSelect(departmentSelect, buildValueOptions('department', '–ë–µ–∑ –æ—Ç–¥–µ–ª–∞'), '–í—Å–µ –æ—Ç–¥–µ–ª—ã');
        populateSelect(typeSelect, buildValueOptions('article_type', '–ë–µ–∑ —Ç–∏–ø–∞'), '–í—Å–µ —Ç–∏–ø—ã');
        populateSelect(statusSelect, buildValueOptions('status', '–ë–µ–∑ —Å—Ç–∞—Ç—É—Å–∞'), '–í—Å–µ —Å—Ç–∞—Ç—É—Å—ã');
        populateSelect(authorSelect, buildValueOptions('author', '–ë–µ–∑ –∞–≤—Ç–æ—Ä–∞'), '–í—Å–µ –∞–≤—Ç–æ—Ä—ã');
        updateSubDirectionOptions();
        subDirectionSelect.value = 'all';
      }

      directionSelect.addEventListener('change', () => {
        const prevSubValue = subDirectionSelect.value;
        updateSubDirectionOptions();
        if (!Array.from(subDirectionSelect.options).some((opt) => opt.value === prevSubValue)) {
          subDirectionSelect.value = 'all';
        } else {
          subDirectionSelect.value = prevSubValue;
        }
        collapsedDirections.clear();
        collapsedSubDirections.clear();
        renderTable();
      });

      [subDirectionSelect, departmentSelect, typeSelect, statusSelect, authorSelect].forEach((select) => {
        select.addEventListener('change', () => {
          collapsedDirections.clear();
          collapsedSubDirections.clear();
          renderTable();
        });
      });

      searchInput.addEventListener('input', () => {
        collapsedDirections.clear();
        collapsedSubDirections.clear();
        renderTable();
      });

      resetButton.addEventListener('click', resetFilters);

      initFilters();
      renderTable();
    })();
  </script>
</body>
</html>
