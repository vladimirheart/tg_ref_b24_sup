<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bender — Панель поддержки</title>
  <link rel="icon" type="image/svg+xml" href="{{ url_for('static', filename='bender-icon.svg') }}" />
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" />
  <link href="https://cdn.jsdelivr.net/npm/bootstrap-table@1.22.1/dist/bootstrap-table.min.css" rel="stylesheet">
  <link href="{{ url_for('static', filename='style.css') }}" rel="stylesheet" />
  <link href="{{ url_for('static', filename='sidebar.css') }}" rel="stylesheet" />
  <style>
  /* Предотвращаем первый «прыжок» при ресайзе столбцов */
#ticketsTable {
  table-layout: fixed;   /* фиксированная раскладка предотвращает перерасчёт ширин */
  width: 100%;
}
#ticketsTable th, 
#ticketsTable td {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
/* Фикс рывка в момент старта ресайза */
#ticketsTable th, #ticketsTable td { box-sizing: border-box; }
#ticketsTable th { will-change: width; }

/* отключим нежелательные переходы на ширину */
#ticketsTable th, #ticketsTable td { transition: none !important; }

/* Фикс для контейнера, чтобы не тянул всю ширину экрана во время перетаскивания */
.table-responsive {
  overflow: auto;
  contain: content;      /* изоляция контента от внешних перерисовок */
}

  /* Адаптивные стили для всех страниц */
  @media (max-width: 1024px) {
    .container {
      padding-left: 10px;
      padding-right: 10px;
    }

    .navbar-nav {
      flex-direction: row;
      flex-wrap: wrap;
      justify-content: center;
    }

    .navbar-nav .nav-link {
      padding: 0.5rem;
      font-size: 0.9rem;
    }

    .table-responsive {
      font-size: 0.85rem;
    }

    .chat-bubble {
      max-width: 90%;
    }

    .input-group-send {
      flex-direction: column;
    }

    .input-group-send textarea {
      min-height: 80px;
    }
	/* Маркёр активного пункта в меню настроек отправки */
	.dropdown-menu .dropdown-item .check {
	  display: inline-block;
	  width: 1.2em;
	}
	.dropdown-menu .dropdown-item.active .check::before {
	  content: "✔";
	}

    .modal-dialog {
      margin: 10px;
    }

    .btn-sm {
      font-size: 0.75rem;
      padding: 0.25rem 0.5rem;
    }
  }

  @media (max-width: 576px) {
    h2 {
      font-size: 1.5rem;
    }

    .badge {
      font-size: 0.7rem;
      margin-bottom: 5px;
    }

    .form-select, .form-control {
      font-size: 0.9rem;
    }

    .pagination {
      flex-wrap: wrap;
    }

    .page-link { padding: 0.3rem 0.6rem; font-size: 0.85rem; }
  }

  .category-selector {
    background-color: #f8f9fa;
    border-left: 4px solid #6f42c1;
    padding: 10px;
    margin-bottom: 15px;
    border-radius: 4px;
  }

  .chat-bubble {
    padding: 8px 12px;
    border-radius: 8px;
    margin-bottom: 6px;
    max-width: 80%;
    word-wrap: break-word;
    transition: opacity 0.3s ease;
  }
  /* Имя отправителя - делаем немного крупнее */
  .chat-bubble strong {
    font-size: 1.1em;      /* размер для имени */
    font-weight: 600;
  }

  /* Сообщение - стандартный размер */
  .chat-bubble p {
    font-size: 1em;        /* размер для текста сообщения */
    margin-bottom: 4px;
    line-height: 1.4;
  }

  /* Время - делаем мельче */
  .chat-bubble small {
    font-size: 0.85em;     /* размер для времени */
    color: #666 !important;
    opacity: 0.8;
  }
  /* ↑ Увеличение текста и эмодзи в сообщениях истории ~в 1.5 раза */
  .chat-bubble {
	  font-size: 1.5em;      /* было 1em → стало ~1.5x */
	  line-height: 1.35;
	}
	.chat-bubble img.emoji {
	  height: 1em;
	  width: 1em;
	  vertical-align: -0.1em;
	}
  @media (max-width: 768px) {
    .chat-bubble strong {
        font-size: 1.1em;
    }
    
    .chat-bubble p {
        font-size: 0.95em;
    }
    
    .chat-bubble small {
        font-size: 0.75em;
    }
  }
  .from-user {
    background: #e3f2fd;
    align-self: flex-start;
	margin-right: auto;
  }

  .from-support {
    background: #d1f7d1;
    align-self: flex-end;
	margin-left: auto;
  }

  .chat-container {
  flex: 1;
  min-height: 0;
  overflow-y: auto;
}

#historyModal .input-group-send {
  flex: 0 0 auto;
  margin-top: 0;
  border-top: 1px solid #dee2e6;
}

/* фиксируем ширину полосы — контент больше не «сжимается» при ховере контейнера */
#historyContent::-webkit-scrollbar {
  width: 12px;
}
#historyContent { scrollbar-width: thin; scrollbar-color: rgba(0,0,0,.55) transparent; }

/* желоб (трек) */
#historyContent::-webkit-scrollbar-track {
  background: transparent;
}
#historyContent::-webkit-scrollbar-track:hover {
  background: rgba(0,0,0,.04); /* опционально */
}

/* ползунок */
#historyContent::-webkit-scrollbar-thumb {
  background-color: rgba(0,0,0,.40);
  border-radius: 8px;
  border: 2px solid transparent;     /* визуально тоньше */
  background-clip: content-box;
  transition: background-color .15s ease;
}
#historyContent::-webkit-scrollbar-thumb:hover {
  background-color: rgba(0,0,0,.85);  /* меняем «прозрачность» только на самом ползунке */
}

/* оставляем, чтобы ширина под полосу была стабильной и не дёргалась верстка */
#historyContent { scrollbar-gutter: stable both-edges; }

#historyContent {
  scrollbar-gutter: stable both-edges;
}

/* Firefox: цвет и толщина (тонкий по умолчанию, «авто» при ховере) */
#historyContent { scrollbar-width: thin; scrollbar-color: rgba(0,0,0,.4) transparent; }
#historyContent.hovering { scrollbar-width: auto; scrollbar-color: rgba(0,0,0,.95) transparent; }
  
.history-viewport { position: relative; }
  
.history-scroll-btn {
  position: absolute;
  right: 6px;                /* рядом со скролл-баром */
  width: 34px;
  height: 34px;
  border-radius: 50%;
  border: 1px solid rgba(0,0,0,.15);
  background: var(--bs-body-bg);
  box-shadow: 0 2px 6px rgba(0,0,0,.15);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  opacity: .2;               /* ≈80% прозрачности */
  z-index: 3;
  user-select: none;
}

/* конкретные позиции */
.history-scroll-btn:hover { opacity: .9; }
.history-scroll-btn.top    { top: 6px; }
.history-scroll-btn.bottom { bottom: 6px; }

  .chat-bubble p, .chat-bubble small, .chat-bubble strong {
    color: #000 !important;
  }

  .input-group-send {
    display: flex;
    align-items: stretch;
    gap: 8px;
  }

  .input-group-send textarea {
    flex: 1;
    resize: vertical;
    min-height: 60px;
    max-height: 200px;
  }

  .input-group-send .btn {
    white-space: nowrap;
  }

  /* Стили для бизнесов */
  .business-sushi {
    background-color: #F25F79 !important;
    color: white !important;
  }

  .business-blin {
    background-color: #FFD504 !important;
    color: black !important;
  }

  th[data-column="business"] {
    width: 115px;
    min-width: 115px;
    text-align: center;
  }

  td.business-cell {
    text-align: center;
    width: 115px;
  }

  .actions-cell .btn.btn-sm {
    font-size: 0.79rem;
    padding: 0.225rem 0.45rem;
  }

  .actions-cell .actions-layout {
    display: flex;
    align-items: stretch;
    gap: 0.5rem;
  }

  .actions-cell .actions-column {
    display: flex;
    flex-direction: column;
    gap: 0.35rem;
    flex: 1 1 auto;
  }

  .actions-cell .actions-column .btn {
    width: 100%;
  }

  .actions-cell .actions-side {
    display: flex;
    align-items: center;
  }

  /* Стили для resize столбцов */
  .table th {
    position: relative;
    user-select: none;
  }

  .resize-handle {
    position: absolute;
    top: 0;
    right: 0;
    width: 5px;
    height: 100%;
    background-color: #ddd;
    cursor: col-resize;
    user-select: none;
  }

  .clickable-client {
    cursor: pointer;
    color: #0d6efd;
    text-decoration: underline;
  }

  .clickable-client:hover {
    color: #0a58ca;
  }

  .column-toggle {
    max-height: 300px;
    overflow-y: auto;
  }

  .problem-info {
    background-color: #f8f9fa;
    border-left: 4px solid #0d6efd;
    padding: 10px;
    margin-bottom: 15px;
    border-radius: 4px;
  }

  .resizing {
    cursor: col-resize;
    user-select: none;
  }

  .table-column-hidden {
    display: none;
  }

  /* Адаптивность для таблицы */
  .table th, .table td {
    word-break: break-word;
  }

  /* Стили для выпадающего меню категорий */
  .category-selector .dropdown-menu {
    margin-left: 10px !important;
    min-width: 1000px !important;
    padding: 0.5rem;
  }

  .category-selector .form-check {
    margin: 0;
    padding: 0.25rem 1.5rem;
    white-space: nowrap;
  }

  .category-selector .form-check-input {
    margin-right: 0.5rem;
  }

  .category-selector .form-check-label {
    cursor: pointer;
    user-select: none;
    display: inline-block;
    width: calc(100% - 1.5rem);
  }

  .selected-categories {
    display: flex;
    flex-wrap: wrap;
    gap: 0.35rem;
    align-items: center;
  }

  .selected-categories .selected-label {
    font-size: 0.75rem;
    font-weight: 600;
    letter-spacing: 0.04em;
    text-transform: uppercase;
    margin-right: 0.25rem;
  }

  .category-chip {
    display: inline-flex;
    align-items: center;
    padding: 0.25rem 0.65rem;
    border-radius: 999px;
    font-weight: 600;
    font-size: 0.85rem;
    line-height: 1;
    color: #fff;
    background: var(--chip-color, #0d6efd);
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.16);
  }
.min-height-0 {
  min-height: 0 !important;
}
/* === История переписки: высота и раскладка === */
#historyModal .modal-dialog {
  width: 80vw !important;
  height: 90vh !important;
  max-width: 90vw;
  max-height: 90vh;
  margin: 5vh auto;
  display: flex;
}

#historyModal.fullscreen {
  align-items: stretch;
}

#historyModal.fullscreen .modal-dialog {
  width: calc(100vw - var(--history-sidebar-offset, 0px)) !important;
  height: 100vh !important;
  max-width: none;
  max-height: 100vh;
  margin: 0;
  margin-left: var(--history-sidebar-offset, 0px);
  border-radius: 0;
}

#historyModal.fullscreen .modal-content {
  height: 100vh;
  border-radius: 0;
}

#historyModal.fullscreen .modal-body {
  flex: 1 1 auto;
}

#historyModal .modal-content {
  height: 100%;
  display: flex !important;
  flex-direction: column;
  flex: 1 1 auto;
  gap: 0;
}

#historyModal .modal-body {
  display: flex;
  flex-direction: column;
  flex: 1 1 auto;
  min-height: 0;
  gap: 0;
}

.resizable-modal .modal-dialog {
  resize: both;
  overflow: auto;
  min-width: 400px;
  min-height: 300px;
}

#historyModal,
#historyModal .modal-dialog,
#historyModal .modal-content {
  overscroll-behavior: contain;
}

#historyModal .sidebar-pane,
#historyModal .sidebar-content,
#historyModal .chat-container {
  overscroll-behavior: contain;
}

#historyModal .modal-header{ flex: 0 0 auto; }

/* Тело модалки — вертикальный flex-контейнер, занимают 1fr строки грида */
#historyModal .modal-body {
  padding: 0 !important;
  flex: 1;
  min-height: 0;
}

#historyModal .modal-footer{ flex: 0 0 auto; }

/* Контейнер с двумя колонками */
#historyModal .container-fluid {
  height: 100%;
  min-height: 0;
}

#historyModal .row {
  height: 100%;
  min-height: 0;
  margin: 0 !important;
  --bs-gutter-x: 0;
}

//* Внутри тела всё тянем по flex-цепочке без процентов */
#historyModal .modal-body > .container-fluid{
  display: flex;
  flex: 1 1 auto;
  min-height: 0;
  padding: 0 !important;
}

#historyModal .modal-body > .container-fluid > .row{
  display: flex;
  flex: 1 1 auto;
  min-height: 0;
  align-items: stretch;
  margin: 0 !important;
  --bs-gutter-x: 0;
  --bs-gutter-y: 0;
}

/* Убираем padding у колонок в модалке истории */
#historyModal .modal-body .col-md-4,
#historyModal .modal-body .col-md-8 {
  padding-left: 0 !important;
  padding-right: 0 !important;
}

/* Левая колонка */
#historyModal .sidebar-pane {
  position: relative;
  display: flex;
  flex-direction: column;
  min-height: 0;
  min-width: 300px;
  max-width: 70%;
  width: var(--sidebar-expanded-width, 400px);
  background: #f8f9fa;
  border-right: 1px solid #dee2e6;
  flex: 0 0 auto;
  height: 100%;
  overflow: hidden;
  transition: width .25s ease;
}
#historySidebar .sidebar-content {
  transition: opacity .2s ease;
  flex: 1 1 auto;
  min-height: 0;
  overflow: hidden;
}

#historySidebar .sidebar-scroll {
  flex: 1 1 auto;
  min-height: 0;
  overflow-y: auto;
  padding-bottom: 1rem;
}

#historySidebar .sidebar-scroll > *:last-child {
  margin-bottom: 1rem;
}
#historySidebar.collapsed {
  width: var(--sidebar-collapsed-width, 56px) !important;
  min-width: var(--sidebar-collapsed-width, 56px) !important;
}
#historySidebar.collapsed .sidebar-content {
  opacity: 0;
  pointer-events: none;
}
#historySidebar.collapsed:hover {
  width: var(--sidebar-hover-width, 360px) !important;
}
#historySidebar.collapsed:hover .sidebar-content {
  opacity: .6;
  pointer-events: auto;
}
#historySidebar .sidebar-collapse-toggle {
  position: absolute;
  top: 12px;
  right: -28px;
  z-index: 20;
  border-radius: 999px;
  width: 60px;
  height: 60px;
  padding: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.5rem;
}
#historySidebar .sidebar-collapse-toggle .toggle-icon {
  transition: transform .2s ease;
}
#historySidebar.collapsed .sidebar-collapse-toggle .toggle-icon {
  transform: rotate(180deg);
}
#historySidebar.collapsed .sidebar-collapse-toggle {
  right: -28px;
}
.history-pane-resizer.invisible {
  opacity: 0;
  pointer-events: none;
}

#historyModal .history-avatar-wrapper {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.5rem;
}

#historyModal .history-avatar {
  width: 100%;
  max-width: 192px;
  aspect-ratio: 1 / 1;
  object-fit: cover;
  border: 1px solid rgba(0, 0, 0, .1);
  cursor: zoom-in;
  margin-inline: auto;
  transition: transform .2s ease;
}

#historyModal .history-avatar:hover {
  transform: scale(1.03);
}

/* Правая колонка (история) */
#historyModal .history-pane {
  position: relative;
  z-index: 1;
  display: flex;
  flex-direction: column;
  flex: 1 1 auto;
  min-height: 0;
  height: 100%;
}

/* Убираем возможность сжатия правой колонки */
#historyModal .col-md-8 {
  flex: 1 1 0%;
  min-width: 400px;
}

#historyModal .history-pane > .d-flex.flex-column {
  display: flex !important;
  flex: 1 1 auto !important;
  min-height: 0 !important;
  gap: 0;
  height: 100%;
}

/* Сама лента сообщений */
#historyModal .chat-container {
  flex: 1 1 auto;
  min-height: 0;
  overflow-y: auto;
  padding: 16px 16px 0px;
  display: flex;
  flex-direction: column;
   gap: 12px;
  justify-content: flex-start;
  margin-bottom: 0;
  background-color: #f8f9fa !important;
}

/* Обеспечиваем правильное отображение пузырей на фоне */
#historyModal .chat-bubble.from-user {
  background: #e3f2fd;
  border: 1px solid #bbdefb;
}

#historyModal .chat-bubble.from-support {
  background: #d1f7d1;
  border: 1px solid #a5d6a7;
}

#historyModal .input-group-send {
  margin-top: 0 !important;
  flex: 0 0 auto;
}

#historyModal .input-group-send {
  margin-top: 0 !important;
}

/* === История: разные шрифты для времени, автора и текста === */
#historyModal .chat-bubble .msg-time {
  /* моноширинный — лучше читаются цифры времени */
  font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
  font-size: calc(0.80rem * var(--history-font-scale, 1)); /* фиксированный размер от масштаба истории */
  line-height: 1.2;
  color: #6c757d !important;
  letter-spacing: .01em;
  display: inline-block;
  margin-bottom: .15rem;
}

#historyModal .chat-bubble .msg-author {
  /* плотный санс-сериф для имени */
  font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, "Noto Sans", sans-serif;
  font-weight: 700;
  font-size: calc(0.95rem * var(--history-font-scale, 1));
  line-height: 1.25;
  display: inline-block;
  margin-bottom: .05rem;
}

#historyModal .chat-bubble .msg-text {
  /* нейтральный читабельный санс-сериф для тела сообщения */
  font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, "Noto Sans", sans-serif;
  font-size: calc(1.50rem * var(--history-font-scale, 1));
  line-height: 1.45;
  color: #000 !important;
}

/* На очень узких экранах — чутка ужмём */
@media (max-width: 768px) {
  #historyModal .chat-bubble .msg-time   { font-size: calc(.75rem * var(--history-font-scale, 1)); }
  #historyModal .chat-bubble .msg-author { font-size: calc(.90rem * var(--history-font-scale, 1)); }
  #historyModal .chat-bubble .msg-text   { font-size: calc(.95rem * var(--history-font-scale, 1)); }
}
/* Стек: время сверху, ниже — имя с минимальным зазором */
#historyModal .chat-bubble .msg-time {
  display: block;
  margin: 0;                 /* без лишних отступов */
}
#historyModal .chat-bubble .msg-author {
  display: block;
  margin: 1px 0 2px 0;       /* компактный отступ между временем и именем */
}

/* Обёртка каждого превью для позиционирования иконки */
#historyModal .chat-bubble .media-wrap {
  position: relative;
}

/* Кнопка-иконка скачивания в правом верхнем углу превью */
#historyModal .chat-bubble .media-download {
  position: absolute;
  top: 6px;
  right: 6px;
  width: 28px;
  height: 28px;
  border-radius: 50%;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  background: rgba(255,255,255,.9);
  border: 1px solid rgba(13,110,253,.25);
  text-decoration: none;
  font-size: 1rem;
  line-height: 1;
  color: #0d6efd !important;
  box-shadow: 0 2px 6px rgba(0,0,0,.15);
  opacity: .85;
  transition: transform .15s ease, opacity .15s ease;
}
#historyModal .chat-bubble .media-download:hover {
  opacity: 1;
  transform: translateY(-1px);
}

/* Подпись типа медиа: моноширинный, мелкий, «системный» */
#historyModal .chat-bubble .media-type {
  font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
  font-size: calc(.78rem * var(--history-font-scale, 1));
  line-height: 1.2;
  letter-spacing: .03em;
  text-transform: uppercase;
  color: #495057;
}

/* Подпись к медиа (если была) — обычный текст */
#historyModal .chat-bubble .media-caption {
  font-size: calc(.95rem * var(--history-font-scale, 1));
  line-height: 1.35;
}
/* === Twemoji: нормальный размер и выравнивание === */
#historyModal img.emoji,
#historyModal .msg-text img.emoji,
#historyModal .msg-author img.emoji {
  width: 1.1em !important;
  height: 1.1em !important;
  max-width: none !important;
  max-height: none !important;
  vertical-align: -0.12em;         /* чуть опускаем, чтобы сидели на базовой линии текста */
  margin: 0 .06em;
  border: 0 !important;
  padding: 0 !important;
  background: transparent !important;
  box-shadow: none !important;
}

/* На мелких экранах чуть компактнее */
@media (max-width: 768px) {
  #historyModal img.emoji,
  #historyModal .msg-text img.emoji,
  #historyModal .msg-author img.emoji {
    width: 1.0em !important;
    height: 1.0em !important;
    vertical-align: -0.1em;
  }
}
/* правая колонка с кнопками */
.send-actions .btn { white-space: nowrap; }
#replyTextInHistory {
  padding-bottom: 0; /* динамически задаётся скриптом */
}
#composerDock .btn { line-height: 1; }

/* на узких экранах всё как раньше — под полем */
@media (max-width: 1024px) {
  .send-actions { width: 100% !important; }
}
/* Кнопка пикера — полупрозрачная, пока не активна */
.dock-btn { opacity:.45; transition:opacity .15s ease; }
.dock-btn:hover, .dock-btn.active { opacity:1; }

/* История: компактнее зазор между текстом и кнопками действий */
#historyModal .chat-bubble .msg-text { margin-bottom: 2px !important; }
#historyModal .chat-bubble p { margin-bottom: 2px !important; }

#clientTicketsSection {
  display: none;
}

#clientTicketsSection .client-tickets-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 0.5rem;
}

#clientTicketsList {
  max-height: 260px;
  overflow-y: auto;
  margin-top: 0.75rem;
}

#clientTicketsList .list-group-item {
  cursor: pointer;
}

#clientTicketsList .list-group-item.active {
  background-color: #0d6efd;
  border-color: #0d6efd;
}

#clientTicketsList .list-group-item.active .text-muted,
#clientTicketsList .list-group-item.active .small {
  color: rgba(255, 255, 255, 0.85) !important;
}

/* подсветка целевого сообщения при переходе из «чипа» */
.reply-preview {
  border-left: 3px solid #007bff;
  background: #f0f8ff;
  padding: 6px 8px;
  border-radius: 6px;
  margin-bottom: 6px;
}
/* Цвет текста в превью ответа */
.reply-preview .rp-box {
  color: #2c3e50; /* Темно-синий текст */
  font-style: italic;
}

/* При наведении на превью ответа */
.reply-preview:hover {
  background: #e3f2fd; /* Более яркий голубой при наведении */
  border-left-color: #0056b3; /* Темнее синий при наведении */
}
.chat-bubble.reply-target {
  outline: 2px solid #9ad;
  outline-offset: 2px;
  transition: outline-color .8s ease;
}

/* Экшен-бар внутри пузыря */
#historyModal .chat-bubble {
  position: relative;
  padding: 0 14px;
  overflow: visible;
}

#historyModal .bubble-meta {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 0.5rem;
  margin-bottom: 0.35rem;
}

#historyModal .bubble-meta .msg-time {
  margin-bottom: 0 !important;
}

#historyModal .chat-bubble .bubble-actions {
  position: static;
  display: flex;
  align-items: center;
  margin: 0 !important;
  opacity: .95;
  transition: opacity .15s ease;
}

#historyModal .chat-bubble .bubble-actions .btn {
  font-size: .85rem;
  line-height: 1;
  padding: 0 4px;
}

#historyModal .chat-bubble:hover .bubble-actions {
  opacity: 1;
}

/* Текст и отступы — чтобы ничего не перекрывалось */
#historyModal .chat-bubble .msg-time   { margin-bottom: .15rem; }
#historyModal .chat-bubble .msg-author { margin: 1px 0 2px 0; }
#historyModal .chat-bubble .msg-text   { margin-bottom: 0 !important; }

/* Мобильный фоллбек */
@media (max-width: 768px){
  #historyModal .bubble-meta {
    flex-wrap: wrap;
    row-gap: 0.25rem;
  }
  #historyModal .chat-bubble {
    padding: 0 12px;
  }
  #historyModal .chat-bubble .bubble-actions{
    width: 100%;
    justify-content: flex-end;
  }
}

.reply-preview .reply-text {
  font-size: 0.9em;
  color: #6c757d;
}

.reply-preview .btn-close {
  position: absolute;
  top: 5px;
  right: 5px;
  padding: 4px;
}
.header-meta-item {
  white-space: nowrap;
}
#historyHeaderMeta {
  gap: 1rem;
}
#historyHeaderMeta .form-select {
  min-width: 140px;
}
#historyContent {
  --history-font-scale: 1;
  font-size: calc(1rem * var(--history-font-scale));
}
#historyContent.font-size-small { --history-font-scale: 0.9; }
#historyContent.font-size-medium { --history-font-scale: 1; }
#historyContent.font-size-large { --history-font-scale: 1.2; }
#activeDialogsBlock { display: none; }
#activeDialogsBlock.show { display: block; }
#activeDialogList .status-heading {
  font-size: 0.7rem;
  font-weight: 600;
  text-transform: uppercase;
  color: #6c757d;
  letter-spacing: 0.05em;
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin: 0.75rem 0 0.35rem;
}
#activeDialogList .status-heading:first-child { margin-top: 0; }
#activeDialogList .status-heading .badge { font-size: 0.65rem; }
#activeDialogList .list-group-item {
  cursor: pointer;
  border-radius: 6px;
  border: 1px solid rgba(0,0,0,.05);
  margin-bottom: 6px;
  transition: background-color .15s ease, box-shadow .15s ease;
}
#activeDialogList .list-group-item:last-of-type { margin-bottom: 0; }
#activeDialogList .list-group-item.active {
  background-color: var(--bs-primary);
  border-color: var(--bs-primary);
  color: #fff;
  box-shadow: 0 6px 12px rgba(13,110,253,.35);
}
#activeDialogList .dialog-remove-btn {
  opacity: .6;
}
#activeDialogList .dialog-remove-btn:hover {
  opacity: 1;
}
#mediaViewerModal {
  --media-viewer-width: 720px;
  --media-viewer-height: 405px;
}
#mediaViewerModal .modal-dialog {
  max-width: min(95vw, calc(var(--media-viewer-width, 720px) + 3rem));
}
#mediaViewerBody {
  min-height: min(90vh, max(var(--media-viewer-height, 405px), 360px));
  display: flex;
  align-items: center;
  justify-content: center;
  min-width: min(95vw, max(var(--media-viewer-width, 480px), 320px));
}
#mediaViewerBody img,
#mediaViewerBody video {
  max-width: 100%;
  height: auto;
}
#mediaViewerBody video {
  width: min(100%, var(--media-viewer-width, 720px));
  max-height: min(var(--media-viewer-height, 405px), 90vh);
}
#mediaViewerBody iframe {
  width: 100%;
  height: min(90vh, max(var(--media-viewer-height, 405px), 360px));
  border: 0;
}
* === Редактирование / удаление === *
.chat-bubble.is-editing { outline: 2px dashed #6c757d; outline-offset: 2px; }
.chat-bubble.deleted    { opacity: .55; }
.badge-meta { font-weight: 500; border: 1px solid rgba(0,0,0,.08); }


.reply-target {
  outline: 2px dashed #0d6efd;
  outline-offset: 3px;
  animation: rt-blink 1.2s ease-in-out 1;
}

.chat-bubble.editing {
  box-shadow: 0 0 0 2px rgba(13,110,253,.35) inset;
}

@keyframes rt-blink {
  0% { background-color: rgba(13,110,253,.08); }
  100% { background-color: transparent; }
}
/* Стили для счётчика непрочитанных в таблице заявок */
#ticketsTable .unread-badge {
  font-size: 0.75rem;
  min-width: 20px;
  height: 20px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border: 2px solid #fff;
  box-shadow: 0 0 0 1px #dc3545;
}
.filter-badge {
  margin-right: 5px;
  margin-bottom: 5px;
  display: inline-block;
  font-size: 0.8em;
  padding: 4px 8px;
}

/* === Ресайзер для левой панели истории === */
.history-pane-resizer {
  position: absolute;
  top: 0;
  right: -4px;
  width: 8px;
  height: 100%;
  background: transparent;
  cursor: col-resize;
  z-index: 10;
}

.history-pane-resizer:hover,
.history-pane-resizer.resizing {
  background: rgba(0, 123, 255, 0.3);
}

.history-pane-resizer::after {
  content: '';
  position: absolute;
  top: 50%;
  left: 2px;
  width: 4px;
  height: 40px;
  background: #6c757d;
  border-radius: 2px;
  transform: translateY(-50%);
  opacity: 0;
  transition: opacity 0.2s;
}

.history-pane-resizer:hover::after {
  opacity: 0.7;
}

.history-pane-resizer.resizing::after {
  opacity: 1;
}

/* Обновляем стили для колонок с поддержкой ресайза */
.sidebar-pane {
  position: relative;
  min-width: 300px; /* минимальная ширина */
  max-width: 70%; /* максимальная ширина */
  resize: horizontal;
  overflow: auto;
}

.history-pane {
  position: relative;
  flex: 1;
  min-width: 400px; /* минимальная ширина правой части */
}

/* Исправление для модального окна аватара */
#avatarModal {
  z-index: 99999 !important;
}

#avatarModal .modal-dialog {
  max-width: 90vw;
  width: auto;
  z-index: 99999;
}

#avatarModal .modal-content {
  z-index: 99999;
  display: flex;
  flex-direction: column;
}

#avatarModal .modal-footer {
  background: transparent;
}

.modal.small-modal {
    align-items: center;
    justify-content: center;
  }

/* Центрирование маленького модального окна закрытия */
.modal.small-modal.show {
    display: flex !important;
  }

  .modal.small-modal .modal-dialog {
    margin: 0;
    position: relative;
    top: 0;
    --modal-transform: scale(var(--modal-scale));
  }

/* Центрирование окна закрытия заявки */
#closeTicketModal .modal-dialog {
  margin: 0;
  top: 50%;
  left: 50%;
  position: fixed;
  --modal-transform: translate(-50%, -50%) scale(var(--modal-scale));
}

/* Центрирование окна "Заявка закрыта" */
#ticketClosedModal .modal-dialog {
  margin: 0;
  top: 50%;
  left: 50%;
  position: fixed;
  --modal-transform: translate(-50%, -50%) scale(var(--modal-scale));
}

/* Стили для плавного появления аватара в модалке */
#avatarModalImg {
  transition: opacity 0.3s ease;
  opacity: 0;
}

#avatarModalImg.loaded {
  opacity: 1;
}

  /* === DEBUG: цветные контуры в модалке истории === */
#historyModal.debug { --dbg-alpha: .12; }
#historyModal.debug * { box-sizing: border-box; }

/* каркас модалки */
#historyModal.debug .modal-content   { outline: 3px solid #ff1744;    background-image: none; }
#historyModal.debug .modal-header    { outline: 2px dashed #ff9100; }
#historyModal.debug .modal-body      { outline: 2px solid #ffea00;   }

/* сетка внутри */
#historyModal.debug .container-fluid { outline: 3px solid #aa00ff; }
#historyModal.debug .row             { outline: 3px solid #00b0ff; }

/* колонки */
#historyModal.debug .sidebar-pane    { outline: 3px solid #e91e63; }
#historyModal.debug .history-pane    { outline: 3px solid #4caf50; }

/* внутренняя обёртка справа (grid: 1fr auto) */
#historyModal.debug .history-pane > .d-flex.flex-column { outline: 3px solid #1de9b6; }

/* контент истории и зона ввода */
#historyModal.debug #historyContent  { outline: 3px solid #3f51b5;
  background-image: repeating-linear-gradient(45deg, rgba(63,81,181,var(--dbg-alpha)) 0 8px, transparent 8px 16px);
}
#historyModal.debug .input-group-send{ outline: 3px solid #ff9800; }

/* блоки слева */
#historyModal.debug .problem-info    { outline: 3px solid #9e9e9e; }
#historyModal.debug .category-selector { outline: 3px solid #607d8b; }
#historyModal.debug .time-counter    { outline: 3px solid #9c27b0; }

/* Twemoji: делаем эмодзи размером с текст */
img.emoji {
  height: 1em;
  width: 1em;
  margin: 0 .05em 0 .1em;
  vertical-align: -0.1em;
}

</style>
<script src="{{ url_for('static', filename='common.js') }}"></script>
<script>
const CURRENT_OPERATOR = {{ (session.get('user_email') or session.get('username') or session.get('user') or '') | tojson }};

function getOperatorName() {
  const name = (typeof CURRENT_OPERATOR === 'string' ? CURRENT_OPERATOR : '').trim();
  return name || 'Bender';
}

function markTicketReopenedLocally() {
  // 1) Включаем кнопку «Закрыть заявку»
  const btn = document.getElementById('closeTicketBtn');
  if (btn) btn.removeAttribute('disabled');

  // 2) Чиним локальный статус, чтобы другой код не «переотключил» кнопку
  window.currentTicketStatus = 'open';

  // 3) Если у нас есть кэш списка тикетов — обновим там статус
  if (Array.isArray(window.allTickets)) {
    const i = window.allTickets.findIndex(t => String(t.ticket_id) === String(window.currentTicketId));
    if (i >= 0) window.allTickets[i].status = 'open';
  }

  // 4) (необязательно) визуально обновим бейдж статуса, если он есть
  const st = document.getElementById('ticketStatusBadge');
  if (st) { st.textContent = 'Открыта'; st.classList.remove('bg-secondary'); st.classList.add('bg-success'); }

  // 5) (необязательно) показать тост
  if (typeof showToast === 'function') showToast('Заявка переоткрыта');
}
</script>

</head>
<body class="with-sidebar sidebar-pinned">
  {% include "_sidebar.html" %}
  <main class="main-content container-fluid">

  <div class="container-fluid mt-4">
    <!-- Добавляем кнопку Фильтры и перемещаем Поиск -->
	<div class="d-flex justify-content-between align-items-center mb-3">
	  <h2>Список заявок</h2>
	  <div class="d-flex align-items-center">
		<!-- Поиск - теперь слева от кнопки Фильтры -->
		<div class="input-group me-2" style="width: 250px;">
		  <span class="input-group-text">🔍</span>
		  <input type="text" id="searchInput" class="form-control" placeholder="Поиск...">
		</div>

		<!-- Кнопка Фильтры -->
		<button class="btn btn-primary me-2" data-bs-toggle="modal" data-bs-target="#filtersModal">
		  <i class="bi bi-funnel"></i> Фильтры
		</button>

		<!-- Кнопка сброса фильтров -->
		<button class="btn btn-outline-secondary me-2" onclick="resetFilters()" title="Сбросить все фильтры">
		  🗑️ Сбросить
		</button>

		<!-- Остальные кнопки -->
		<button class="btn btn-outline-secondary me-2" onclick="toggleColumnSettings()">
		  ⚙️ Столбцы
		</button>

		<select id="tzSelect" class="form-select ms-2" style="width: 220px; display: inline-block;">
		  <option value="browser">Часовой пояс браузера</option>
		  <option value="Europe/Moscow">Europe/Moscow (GMT+3)</option>
		  <option value="Asia/Almaty">Asia/Almaty (GMT+6)</option>
		  <option value="Asia/Novosibirsk">Asia/Novosibirsk (GMT+7)</option>
		  <option value="Asia/Yekaterinburg">Asia/Yekaterinburg (GMT+5)</option>
		  <option value="Europe/Samara">Europe/Samara (GMT+4)</option>
		</select>

		<select id="pageSize" class="form-select ms-2" style="width: 120px; display: inline-block;">
		  <option value="5">5 заявок</option>
		  <option value="20" selected>20 заявок</option>
		  <option value="50">50 заявок</option>
		  <option value="100">100 заявок</option>
		  <option value="500">500 заявок</option>
		</select>
	  </div>
	</div>

	<!-- Убираем старый блок фильтров и заменяем его на более компактный -->
	<div class="filter-grid mb-3" style="display: none;" id="compactFilters">
	  <!-- Этот блок можно скрыть, так как фильтры теперь в модальном окне -->
	</div>

	<!-- Модальное окно фильтров для заявок -->
	<div class="modal fade" id="filtersModal" tabindex="-1">
	  <div class="modal-dialog modal-lg">
		<div class="modal-content">
		  <div class="modal-header">
			<h5 class="modal-title">Фильтры заявок</h5>
			<button type="button" class="btn-close" data-bs-dismiss="modal"></button>
		  </div>
		  <div class="modal-body">
			<div class="row filter-row">
			  <div class="col-md-6 mb-3">
				<label>Статус заявки</label>
				<select class="form-select" id="filterStatusModal">
				  <option value="">Все статусы</option>
				  <option value="pending">В обработке</option>
				  <option value="resolved">Решено</option>
				  <option value="Новая">Новая</option>
				  <option value="Ожидает реакции">Ожидает реакции</option>
				  <option value="Ожидает клиента">Ожидает клиента</option>
				</select>
			  </div>
			  <div class="col-md-6 mb-3">
				<label>ID клиента</label>
				<input type="text" class="form-control" id="filterUserModal" placeholder="Введите ID">
			  </div>
			  <div class="col-md-6 mb-3">
				<label>ID заявки</label>
				<input type="text" class="form-control" id="filterTicketIdModal" placeholder="Введите ID заявки">
			  </div>
			  <div class="col-md-6 mb-3">
				<label>Бизнес</label>
				<input type="text" class="form-control" id="filterBusinessModal" placeholder="Введите бизнес">
			  </div>
			  <div class="col-md-6 mb-3">
				<label>Локация</label>
				<input type="text" class="form-control" id="filterLocationModal" placeholder="Введите локацию">
			  </div>
			  <div class="col-md-6 mb-3">
				<label>Статус клиента</label>
				<input type="text" class="form-control" id="filterClientStatusModal" placeholder="Введите статус клиента">
			  </div>
			  <div class="col-md-6 mb-3">
				<label>Ответственный</label>
				<input type="text" class="form-control" id="filterResponsibleModal" placeholder="Введите ответственного">
			  </div>
			  <div class="col-md-6 mb-3">
				<label>Дата от</label>
				<input type="date" class="form-control" id="filterDateFromModal">
			  </div>
			  <div class="col-md-6 mb-3">
				<label>Дата до</label>
				<input type="date" class="form-control" id="filterDateToModal">
			  </div>
			</div>
			
			<!-- Активные фильтры -->
			<div class="mt-3" id="activeFiltersModal" style="display: none;">
			  <h6>Активные фильтры:</h6>
			  <div id="filterBadgesModal"></div>
			</div>
		  </div>
		  <div class="modal-footer">
			<button type="button" class="btn btn-secondary" onclick="resetFiltersModal()">Сбросить</button>
			<button type="button" class="btn btn-primary" onclick="applyFiltersModal()">Применить</button>
		  </div>
		</div>
	  </div>
	</div>

<!-- Модальное окно настроек столбцов -->
<div class="modal fade" id="columnSettingsModal" tabindex="-1">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Настройки столбцов</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
      </div>
      <div class="modal-body">
        <div class="column-toggle">
          <div class="form-check">
            <input class="form-check-input" type="checkbox" id="toggleClient" checked>
            <label class="form-check-label" for="toggleClient">Клиент</label>
          </div>
          <div class="form-check">
            <input class="form-check-input" type="checkbox" id="toggleClientStatus" checked>
            <label class="form-check-label" for="toggleClientStatus">Статус клиента</label>
          </div>
          <div class="form-check">
            <input class="form-check-input" type="checkbox" id="toggleChannel" checked>
            <label class="form-check-label" for="toggleChannel">Имя канала</label>
          </div>
          <div class="form-check">
            <input class="form-check-input" type="checkbox" id="toggleTicketId" checked>
            <label class="form-check-label" for="toggleTicketId">ID заявки</label>
          </div>
          <div class="form-check">
            <input class="form-check-input" type="checkbox" id="toggleBusiness" checked>
            <label class="form-check-label" for="toggleBusiness">Бизнес</label>
          </div>
          <div class="form-check">
            <input class="form-check-input" type="checkbox" id="toggleLocation" checked>
            <label class="form-check-label" for="toggleLocation">Локация</label>
          </div>
          <div class="form-check">
            <input class="form-check-input" type="checkbox" id="toggleProblem" checked>
            <label class="form-check-label" for="toggleProblem">Проблема</label>
          </div>
          <div class="form-check">
            <input class="form-check-input" type="checkbox" id="toggleResponsible" checked>
            <label class="form-check-label" for="toggleResponsible">Ответственный</label>
          </div>
          <div class="form-check">
            <input class="form-check-input" type="checkbox" id="toggleStatus" checked>
            <label class="form-check-label" for="toggleStatus">Статус</label>
          </div>
          <div class="form-check">
            <input class="form-check-input" type="checkbox" id="toggleDate" checked>
            <label class="form-check-label" for="toggleDate">Дата</label>
          </div>
          <div class="form-check">
            <input class="form-check-input" type="checkbox" id="toggleTime" checked>
            <label class="form-check-label" for="toggleTime">Время</label>
          </div>
          <div class="form-check">
            <input class="form-check-input" type="checkbox" id="toggleActions" checked>
            <label class="form-check-label" for="toggleActions">Действия</label>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Отмена</button>
        <button type="button" class="btn btn-primary" onclick="applyColumnSettings()">Применить</button>
      </div>
    </div>
  </div>
</div>

    <div class="table-responsive">
      <table class="table table-striped" id="ticketsTable">
        <thead>
          <tr>
            <th data-column="client" data-field="client" data-resizable="true">Клиент</th>
            <th data-column="clientStatus" data-field="clientStatus" data-resizable="true">Статус клиента</th>
			<th data-column="channel" data-field="channel" data-resizable="true">Имя канала</th>
            <th data-column="ticketId" data-field="ticketId" data-resizable="true">ID заявки</th>
            <th data-column="business" data-field="business" data-resizable="true" class="text-center">Бизнес</th>
            <th data-column="location" data-field="location" data-resizable="true">Локация</th>
            <th data-column="problem" data-field="problem" data-resizable="true">Проблема</th>
            <th data-column="responsible" data-field="responsible" data-resizable="true">Ответственный</th>
            <th data-column="status" data-field="status" data-resizable="true">
			  <span class="me-1">Статус</span>
			</th>
            <th data-column="date" data-field="date" data-resizable="true">Дата</th>
            <th data-column="time" data-field="time" data-resizable="true">Время</th>
            <th data-column="actions" data-field="actions" data-resizable="true">Действия</th>
          </tr>
        </thead>
        <tbody id="ticketsBody">
        </tbody>
      </table>
    </div>

    <nav aria-label="Page navigation">
      <ul class="pagination justify-content-center" id="pagination">
      </ul>
    </nav>
  </div>

<!-- Модальное окно: история -->
<div class="modal fade resizable-modal" id="historyModal" tabindex="-1">
  <div class="modal-dialog modal-xl">
    <div class="modal-content">
                <div class="modal-header flex-wrap align-items-center gap-3">
                  <div class="d-flex align-items-center flex-wrap gap-2">
                    <h5 class="modal-title mb-0 d-flex align-items-center flex-wrap gap-2" id="historyModalTitle">
                      <span class="me-1">💬 Диалог №</span>
                      <span id="ticketIdDisplay"></span>
                      <span class="d-inline-flex align-items-center gap-2">
                        <span id="clientDisplayName">—</span>
                        <span class="badge bg-info" id="clientStatusDisplay"></span>
                      </span>
                      <span id="unreadBadge" class="badge bg-danger ms-2 d-none">0</span>
                    </h5>
                    <button type="button" class="btn btn-sm btn-outline-primary" id="editClientBtn" title="Редактировать имя">✏️</button>
                  </div>
                  <div class="d-flex align-items-center flex-wrap ms-auto" id="historyHeaderMeta">
                    <div class="header-meta-item text-muted small">
                      <span class="fw-semibold me-1">Бизнес:</span><span id="headerBusiness">—</span>
                    </div>
                    <div class="header-meta-item text-muted small">
                      <span class="fw-semibold me-1">Локация:</span><span id="headerLocation">—</span>
                    </div>
                    <div class="header-meta-item d-flex align-items-center gap-2 flex-wrap" id="responsibleControl">
                      <span class="small text-muted">Ответственный:</span>
                      <span id="dialogResponsibleDisplay" class="fw-semibold">ещё не в работе</span>
                      <select id="dialogResponsibleSelect" class="form-select form-select-sm w-auto"></select>
                      <button type="button" class="btn btn-outline-primary btn-sm" id="assignResponsibleBtn">Назначить</button>
                    </div>
                    <div class="header-meta-item d-flex align-items-center gap-2">
                      <label for="historyFontSizeControl" class="form-label mb-0 small text-muted">Размер текста</label>
                      <select id="historyFontSizeControl" class="form-select form-select-sm w-auto">
                        <option value="small">Мелкий</option>
                        <option value="medium" selected>Обычный</option>
                        <option value="large">Крупный</option>
                      </select>
                    </div>
                    <button type="button" class="btn btn-outline-secondary btn-sm header-meta-item" id="toggleHistoryFullscreenBtn" aria-pressed="false" title="Развернуть окно истории">⛶</button>
                    <button type="button" class="btn btn-outline-secondary btn-sm header-meta-item" id="inviteToDialogBtn" disabled>
                      Пригласить коллегу
                    </button>
                  </div>
                  <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
      <div class="modal-body p-0 flex-grow-1">
        <div class="container-fluid p-0 d-flex flex-column flex-fill min-height-0">
          <div class="row g-0 flex-fill min-height-0">
            <!-- Левая часть - информация о проблеме и категории -->
            <div class="col-md-4 sidebar-pane border-end" id="historySidebar">
              <button type="button" class="btn btn-light btn-sm sidebar-collapse-toggle" id="sidebarCollapseToggle" aria-expanded="true" title="Свернуть панель">
                <span class="toggle-icon">❮</span>
              </button>
              <div class="d-flex flex-column flex-fill min-height-0 sidebar-content">
                <div class="sidebar-scroll d-flex flex-column gap-3">
                  <div class="p-3 sidebar-info" id="activeDialogsBlock">
                  <div class="d-flex justify-content-between align-items-center flex-wrap gap-2">
                    <div class="d-flex align-items-center gap-2">
                      <strong class="me-1 mb-0">Активные диалоги</strong>
                      <span class="badge bg-secondary" id="activeDialogCount">0</span>
                    </div>
                    <button type="button" class="btn btn-link btn-sm text-decoration-none px-1" id="clearActiveDialogsBtn">Очистить</button>
                  </div>
                  <div class="list-group mt-2" id="activeDialogList"></div>
                  </div>
                  <!-- Проблема -->
                  <div class="problem-info p-3 sidebar-info">
                  <strong>Проблема:</strong>
                  <span id="problemText" class="ellipsis-100ch" title=""></span>
                </div>

                <!-- Категория обращения -->
                  <div class="category-selector p-3 sidebar-info">
                  <label class="form-label" for="categoryTemplateSelect">Категория обращения:</label>
                  <select id="categoryTemplateSelect" class="form-select form-select-sm mb-2"></select>
                  <div class="selected-categories mt-2 ellipsis-100ch" id="selectedCategories" style="font-size: 0.9rem;" title=""></div>
                  <select id="ticketCategorySelect" class="form-select" multiple hidden></select>
                  <div class="dropdown" data-bs-auto-close="outside">
                    <button class="btn btn-outline-secondary dropdown-toggle w-100" type="button" id="categoryDropdown" data-bs-toggle="dropdown" aria-expanded="false">
                      Выберите категории...
                    </button>
                    <ul class="dropdown-menu" aria-labelledby="categoryDropdown" id="categoryOptionsList" style="max-height: 300px; overflow-y: auto;"></ul>
                  </div>
                  <div class="form-text">Можно выбрать несколько категорий</div>
                  <button type="button" class="btn btn-outline-primary mt-2 w-100" onclick="saveTicketCategory()">
                    💾 Сохранить категорию
                  </button>
                  </div>

                  <!-- Фото клиента -->
                  <div class="p-3 text-center history-avatar-wrapper">
                  <img id="clientAvatarInHistory" src="" alt="Аватар" class="rounded-circle history-avatar">
                  <div class="small text-muted mt-2">Фото клиента</div>
                </div>

                <!-- Дополнительные данные клиента -->
                  <div class="p-3 sidebar-info text-start" id="historyClientMeta">
                  <div><strong>Бизнес:</strong> <span id="historyBusiness">—</span></div>
                  <div class="mt-1">
                    <strong>Локация:</strong>
                    <a href="#" id="historyLocationLink" class="link-primary text-decoration-none disabled" role="button" aria-disabled="true" tabindex="-1">—</a>
                  </div>
                </div>
                </div>

                <!-- Таймер/счётчик времени -->
                <div class="time-counter p-3 sidebar-info mt-3">
                  <label class="form-label">Время обращения:</label>
                  <div class="time-info bg-light p-3 rounded" id="timeInfo" title="">
                    <div id="timeCounter">Загрузка...</div>
                    <div id="timeDetails" class="small text-muted mt-1"></div>
                  </div>
                                        <button type="button" id="closeTicketBtn" class="btn btn-danger w-100 mt-3">
                                                Закрыть заявку
                                        </button>
                </div>

                <div class="p-3 sidebar-info mt-3" id="clientTicketsSection">
                  <div class="client-tickets-header">
                    <span class="fw-semibold">Обращения клиента</span>
                    <span class="badge bg-secondary" id="clientTicketsCount">0</span>
                  </div>
                  <div class="list-group list-group-flush" id="clientTicketsList"></div>
                </div>
              </div>
            </div>
                        <div class="history-pane-resizer" id="historyPaneResizer"></div>

            <!-- Правая часть - история переписки -->
            <div class="col-md-8 history-pane">
              <div class="d-flex flex-column flex-fill min-height-0">
                <!-- Блок переписки -->
                <div class="chat-container flex-grow-1 min-height-0 font-size-medium" id="historyContent"></div>

                <!-- Поле ввода сообщения и кнопка отправки -->
                <div class="input-group-send border-top bg-light w-100 px-3 pt-3 pb-0">
                  <!-- Левая часть: textarea + «док» с эмодзи/стикерами/GIF ВНУТРИ поля -->
                  <div class="flex-grow-1 position-relative">
                    <div class="w-100">
                      <div class="mb-2" id="questionTemplateSection">
                        <label class="form-label small mb-1" for="questionTemplateSelect">Шаблон типовых вопросов</label>
                        <div class="input-group input-group-sm">
                          <select id="questionTemplateSelect" class="form-select"></select>
                          <button type="button" class="btn btn-outline-secondary" id="applyQuestionTemplateBtn">Вставить все</button>
                        </div>
                        <div class="mt-2 d-flex flex-wrap gap-2" id="questionTemplateQuestions"></div>
                      </div>
                      <div class="d-flex gap-2 mb-1 flex-wrap">
                        <button type="button" class="btn btn-light btn-sm fmt" data-tag="b" title="Жирный">B</button>
                        <button type="button" class="btn btn-light btn-sm fmt" data-tag="i" title="Курсив"><em>I</em></button>
                        <button type="button" class="btn btn-light btn-sm fmt" data-tag="u" title="Подчёркнутый"><u>U</u></button>
                        <button type="button" class="btn btn-light btn-sm fmt" data-tag="s" title="Зачёркнутый"><s>S</s></button>
                        <button type="button" class="btn btn-light btn-sm fmt" data-tag="code" title="Моноширинный">code</button>
                        <button type="button" class="btn btn-light btn-sm fmt" data-tag="blockquote" title="Цитата">❝ ❞</button>
                        <button type="button" class="btn btn-light btn-sm" id="fmtLink" title="Ссылка">🔗</button>
                      </div>
                      <textarea id="replyTextInHistory" class="form-control" placeholder="Введите ответ." rows="2"></textarea>
                    </div>

                    <!-- ЕДИНАЯ кнопка выбора (эмодзи/стикеры/GIF) -->
                    <div id="composerDock" class="position-absolute" style="right:10px; bottom:15px;">
                      <button type="button"
                              id="btnPicker"
                              class="btn btn-sm btn-light px-3 dock-btn"
                              title="Эмодзи/Стикеры/GIF"
                              aria-expanded="false">😀</button>
                    </div>

                    <!-- Панель пикера (одно окно с вкладками) -->
                    <div id="pickerPanel" class="card shadow-sm"
                         style="position:absolute; right:10px; bottom:56px; width:360px; max-height:380px; display:none; z-index:5;">
                      <div class="card-header py-1 px-2">
                        <ul class="nav nav-tabs card-header-tabs" id="pickerTabs" role="tablist">
                          <li class="nav-item"><button class="nav-link active" id="tab-emoji" data-bs-toggle="tab" data-bs-target="#pane-emoji" type="button" role="tab">Эмодзи</button></li>
                          <li class="nav-item"><button class="nav-link" id="tab-sticker" data-bs-toggle="tab" data-bs-target="#pane-sticker" type="button" role="tab">Стикеры</button></li>
                          <li class="nav-item"><button class="nav-link" id="tab-gif" data-bs-toggle="tab" data-bs-target="#pane-gif" type="button" role="tab">GIF</button></li>
                        </ul>
                      </div>
                      <div class="card-body p-2 tab-content" style="overflow:auto;">
                        <!-- Эмодзи -->
                        <div class="tab-pane fade show active" id="pane-emoji" role="tabpanel">
                          <input id="emojiSearch" class="form-control form-control-sm mb-2" placeholder="Поиск эмодзи">
                          <div class="small text-muted" id="emojiRecentWrap" style="display:none;">Недавние:</div>
                          <div id="emojiRecent" class="d-flex flex-wrap gap-1 mb-2"></div>
                          <div id="emojiGrid" class="d-flex flex-wrap gap-1"></div>
                        </div>
                        <!-- Стикеры -->
                        <div class="tab-pane fade" id="pane-sticker" role="tabpanel">
                          <div class="small text-muted mb-2">Недавние</div>
                          <div id="stickerRecent" class="d-flex flex-wrap gap-2 mb-2"></div>
                          <label class="btn btn-sm btn-outline-secondary">
                            Загрузить стикер
                            <input id="fileSticker" type="file" class="d-none" accept=".webp,.webm,.tgs">
                          </label>
                        </div>
                        <!-- GIF -->
                        <div class="tab-pane fade" id="pane-gif" role="tabpanel">
                          <div class="small text-muted mb-2">Загрузить GIF</div>
                          <input id="fileGif" type="file" accept=".gif" class="form-control form-control-sm" />
                          <div id="gifPreview" class="mt-2 d-flex flex-wrap gap-2"></div>
                        </div>
                      </div>
                    </div>
                  </div>

                  <!-- ПРАВАЯ колонка: «Прикрепить» + «Отправить» -->
                  <div class="send-actions d-flex flex-column ms-2" style="width:160px;">
                    <input type="file" id="replyFiles" class="d-none" multiple>
                    <label for="replyFiles" id="replyFilesBtn" class="btn btn-outline-secondary w-100 mb-2">
                      📎
                    </label>
                    <button type="button" id="sendReplyInHistory" class="btn btn-primary w-100">📤</button>
                  </div>
                </div>

              </div>
            </div>
          </div>
        </div>
      </div>
  </div>
</div>

     </div>
  </div>
</div>

  <!-- Модальное окно: ответ -->
  <div class="modal fade" id="replyModal" tabindex="-1">
    <div class="modal-dialog">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title">Ответить</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
        </div>
        <div class="modal-body">
          <textarea id="replyText" class="form-control" rows="4" placeholder="Введите ответ..."></textarea>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Отмена</button>
          <button type="button" class="btn btn-success" onclick="sendReply()">Отправить</button>
        </div>
      </div>
    </div>
  </div>
	
  <!-- Модальное окно: закрытие с категорией -->
<div class="modal fade" id="closeTicketModal" tabindex="-1">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Закрыть заявку</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
      </div>
      <div class="modal-body">
          <div class="category-selector mb-3">
            <label class="form-label" for="closeCategoryTemplateSelect">Категория обращения:</label>
            <select id="closeCategoryTemplateSelect" class="form-select form-select-sm mb-2"></select>
            <select id="closeCategorySelect" class="form-select" multiple hidden></select>
            <div class="dropdown" data-bs-auto-close="outside">
              <button class="btn btn-outline-secondary dropdown-toggle w-100" type="button" id="closeCategoryDropdown" data-bs-toggle="dropdown" aria-expanded="false">
                Выберите категории...
              </button>
              <ul class="dropdown-menu" aria-labelledby="closeCategoryDropdown" id="closeCategoryOptionsList" style="max-height: 300px; overflow-y: auto;"></ul>
            </div>
            <div class="selected-categories mt-2" id="closeSelectedCategories" style="font-size: 0.9rem;"></div>
            <div class="form-text">Можно выбрать несколько категорий</div>
          </div>
          <div class="mb-3">
            <label class="form-label" for="completionTemplateSelect">Шаблон действий после диалога:</label>
            <select id="completionTemplateSelect" class="form-select form-select-sm mb-2"></select>
            <div id="completionTemplateDetails" class="small text-muted"></div>
          </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Отмена</button>
        <button type="button" id="confirmCloseTicketBtn" class="btn btn-danger">Закрыть</button>
      </div>
    </div>
  </div>
</div>

<!-- Модальное окно: подтверждение успешного закрытия -->
<div class="modal fade small-modal" id="ticketClosedModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content text-center p-4">
      <div class="modal-body">
        <h5 class="mb-2">Заявка закрыта</h5>
        <p class="text-muted mb-0">Обращение успешно переведено в завершённое состояние.</p>
      </div>
      <div class="modal-footer justify-content-center border-0">
        <button type="button" class="btn btn-primary" data-bs-dismiss="modal">Ок</button>
      </div>
    </div>
  </div>
</div>

  <!-- Модальное окно: редактирование имени клиента -->
  <div class="modal fade" id="editClientNameModal" tabindex="-1">
    <div class="modal-dialog">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title">Редактирование имени клиента</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
        </div>
        <div class="modal-body">
          <div class="mb-3">
            <label for="clientNameInput" class="form-label">Имя клиента</label>
            <input type="text" class="form-control" id="clientNameInput" placeholder="Введите имя клиента">
          </div>
          <div class="mb-3">
            <label for="clientUsernameInput" class="form-label">Username</label>
            <input type="text" class="form-control" id="clientUsernameInput" placeholder="Введите username">
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Отмена</button>
          <button type="button" class="btn btn-primary" onclick="saveClientName()">Сохранить</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Подключение JS -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  <script>
    window.settings = {
      categories: {{ settings.categories | tojson | safe }},
      dialogConfig: {{ settings.dialog_config | tojson | safe }}
    };
    if (!window.settings.dialogConfig || typeof window.settings.dialogConfig !== 'object') {
      window.settings.dialogConfig = { category_templates: [], question_templates: [], completion_templates: [] };
    }
  </script>
  <script src="{{ url_for('static', filename='modal-transitions.js') }}"></script>
  <script>
        const savedPage = parseInt(localStorage.getItem('ticketsCurrentPage') || '1', 10);
        let currentPage = Number.isFinite(savedPage) && savedPage > 0 ? savedPage : 1;
        let totalPages = 1;
        let allTickets = [];
        const pageParams = new URLSearchParams(window.location.search || '');
        window.initialClientStatusFilter = pageParams.get('client_status');
        window.initialClientStatusFilterApplied = false;
    let currentUserId = null;
    let currentTicketId = null;
    let historyPolling = null;
    window.currentTicketDetails = window.currentTicketDetails || {};
        window.lastReadAtByTicket = JSON.parse(localStorage.getItem('lastReadAtByTicket') || '{}');
    let currentPageSize = 20;
    let filtersCurrentlyActive = false;
    const responsibleControlState = {
      ticketId: null,
      auto: '',
      manual: '',
      effective: '',
      source: ''
    };
                function persistCurrentPageIfUnfiltered() {
          if (!window.filteredTickets) {
                localStorage.setItem('ticketsCurrentPage', String(currentPage));
          }
        }

        function ensureCurrentPageBounds(totalItems) {
          const maxPage = Math.max(1, Math.ceil(totalItems / currentPageSize) || 1);
          if (currentPage > maxPage) currentPage = maxPage;
          if (currentPage < 1) currentPage = 1;
          return maxPage;
        }
	let unreadCount = 0;
		function setUnread(n) {
		  unreadCount = Math.max(0, n|0);
		  const b = document.getElementById('unreadBadge');
		  if (!b) return;
		  if (unreadCount > 0) {
			b.textContent = String(unreadCount);
			b.classList.remove('d-none');
		  } else {
			b.textContent = '0';
			b.classList.add('d-none');
		  }
		}
let renderedMsgIds = new Set();

const activeDialogs = new Map();
const ACTIVE_DIALOG_ALLOWED_STATUSES = new Set(['Ожидает реакции', 'Ожидает клиента']);
let cachedAdminUsers = null;

	function safeId(msg) {
	  // Берём любой доступный «телеграмный»/сквозной идентификатор
	  return (msg.tg_message_id ?? msg.message_id ?? msg.tg_id ?? msg.id ?? null);
	}

	function msgKey(msg) {
	  const sid = safeId(msg);
	  if (sid != null && sid !== '') return 'tg:' + String(sid);

	  const ts = Date.parse(msg.timestamp ?? msg.date ?? msg.created_at ?? '') || 0;
	  const s  = (msg.sender || '').toLowerCase();

	  // ВАЖНО: учитывать альтернативные поля текста, иначе разные ответы оператора
	  // будут иметь одинаковый ключ и «теряться»
	  const h  = (msg.message ?? msg.text ?? msg.body ?? '').toString().slice(0, 160);

	  return `${s}|${ts}|${h}`;
	}
	
	function telegramMid(msg) {
	  // Берём ТОЛЬКО реальные ID телеграм-сообщений
	  return (msg.tg_message_id ?? msg.message_id ?? null);
	}

        // Флаг «это сообщение оператора?»
        function isSupportMsg(msg) {
          const raw = String(msg.sender || '').toLowerCase().trim();
          return (
                ['support','operator','admin','поддержка','оператор','staff','agent'].includes(raw) ||
                msg.is_support === true ||
                msg.from_support === true ||
                msg.is_outgoing === true ||
                msg.sender_type === 'support' ||
                msg.direction === 'out' ||
                msg.sender === 'support'
          );
        }

        function isSupportSenderLabel(label) {
          const raw = String(label || '').toLowerCase().trim();
          if (!raw) return false;
          return (
            raw.includes('support') ||
            ['support','operator','admin','поддержка','оператор','staff','agent','system','bot','manager'].includes(raw)
          );
        }

        function isUserSenderLabel(label) {
          const raw = String(label || '').toLowerCase().trim();
          if (!raw) return false;
          return ['user','client','customer','клиент','пользователь','telegram_user','customer'].includes(raw);
        }

	// Единый UTC-timestamp (ms) для сортировки
	function sortTsMs(msg) {
	  const tsRaw = (msg.timestamp ?? msg.date ?? msg.created_at ?? msg.createdAt ?? msg.tg_date ?? null);
	  const iso   = normalizeToISO(tsRaw);      // уже возвращает корректный ISO в UTC
	  return Date.parse(iso) || 0;
	}

        function wrapSelection(tag, before='', after=''){
          const ta = document.getElementById('replyTextInHistory');
          const [start, end] = [ta.selectionStart, ta.selectionEnd];
          const sel = ta.value.substring(start, end) || 'текст';
          const open = `<${tag}${before}>`;
          const close = `</${tag.split(' ')[0]}>${after}`;
          ta.setRangeText(open + sel + close, start, end, 'end');
          ta.focus();
        }

        function normalizeAvatarUrl(src) {
          if (!src) return '';
          let value = String(src).trim();
          if (!value) return '';
          if (value.toLowerCase() === 'null' || value.toLowerCase() === 'undefined') return '';
          if (value.startsWith('data:')) return value;
          if (value.startsWith('http://') || value.startsWith('https://')) return value;
          if (value.startsWith('//')) return window.location.protocol + value;
          if (!value.startsWith('/')) value = '/' + value.replace(/^\/+/, '');
          return value;
        }

        function ensureFullAvatarUrl(src) {
          const normalized = normalizeAvatarUrl(src);
          if (!normalized) return '';
          if (!normalized.startsWith('/')) return normalized;
          if (normalized.includes('?full=1')) return normalized;
          return normalized.includes('?') ? `${normalized}&full=1` : `${normalized}?full=1`;
        }
	document.querySelectorAll('.fmt').forEach(btn=>{
	  btn.addEventListener('click', ()=>{
		const tag = btn.dataset.tag;
		if (tag === 'blockquote') wrapSelection('blockquote');
		else wrapSelection(tag);
	  });
	});
	document.getElementById('fmtLink')?.addEventListener('click', ()=>{
	  const url = prompt('Вставьте ссылку (https://)…','https://');
	  if (!url) return;
	  wrapSelection(`a href="${escapeHtml(url)}"`);
	});

	// Мини набор эмодзи (можно расширять)
	const EMOJI_LIST = window.EMOJI_LIST || Array.from("😀😁😂🤣😅😊🙂😉😍😘😋😎🤩🤔😴😷🤒🤕🤑🤯🤗🤝👍👎👏🙏💪🔥✨💥🎉❤️🧡💛💚💙💜🤍🤎🖤👌🙌🤌🤞✌️🤟👋🤙🤘🫶");
	const RECENT_KEY = "its_recent_emoji_v1";

	(function initEmojiUI(){
	  const ta         = document.getElementById('replyTextInHistory');
	  const panel      = document.getElementById('pickerPanel');
	  const grid       = document.getElementById('emojiGrid');
	  const recentWrap = document.getElementById('emojiRecentWrap');
	  const recentBox  = document.getElementById('emojiRecent');
	  const search     = document.getElementById('emojiSearch');

	  if (!ta || !panel || !grid) return; // тихо выходим, если секции нет

	  function renderEmoji(list){
		grid.innerHTML = "";
		list.forEach(ch => {
		  const b = document.createElement('button');
		  b.type = "button";
		  b.className = "btn btn-sm btn-light";
		  b.textContent = ch;
		  b.dataset.emoji = ch;          // для делегации кликов
		  grid.appendChild(b);
		});
	  }

	  function getRecent(){
		try { return JSON.parse(localStorage.getItem(RECENT_KEY) || "[]"); }
          catch (error) { return []; }
	  }
	  function pushRecent(ch){
		const arr = getRecent().filter(x => x !== ch);
		arr.unshift(ch);
		localStorage.setItem(RECENT_KEY, JSON.stringify(arr.slice(0, 16)));
	  }
	  function updateRecent(){
		const arr = getRecent();
		recentBox.innerHTML = "";
		recentWrap && (recentWrap.style.display = arr.length ? "" : "none");
		arr.forEach(ch => {
		  const b = document.createElement('button');
		  b.type = "button";
		  b.className = "btn btn-sm btn-outline-secondary";
		  b.textContent = ch;
		  b.addEventListener('click', () => {
			insertAtCaret(ta, ch + " ");
			pushRecent(ch);
			updateRecent();
		  });
		  recentBox.appendChild(b);
		});
	  }
	  function insertAtCaret(el, text){
		const start = el.selectionStart ?? el.value.length;
		const end   = el.selectionEnd ?? el.value.length;
		el.value = el.value.slice(0, start) + text + el.value.slice(end);
		el.focus();
		el.selectionStart = el.selectionEnd = start + text.length;
	  }

	  // Делегация кликов по основной сетке эмодзи
	  grid.addEventListener('click', (e)=>{
		const btn = e.target.closest('button[data-emoji]');
		if (!btn) return;
		const ch = btn.dataset.emoji;
		insertAtCaret(ta, ch + " ");
		pushRecent(ch);
		updateRecent();
	  });

	  // Поиск по эмодзи
	  search?.addEventListener('input', () => {
		const q = (search.value || "").trim();
		renderEmoji(q ? EMOJI_LIST.filter(ch => ch.includes(q)) : EMOJI_LIST);
	  });

	  // Первый рендер
	  renderEmoji(EMOJI_LIST);
	  updateRecent();
	})();

	/* ЕДИНАЯ кнопка (😀) → показать/спрятать панель с вкладками Эмодзи/Стикеры/GIF */
	(function initUnifiedPicker(){
	  const dock   = document.getElementById('composerDock');
	  const btn    = document.getElementById('btnPicker');
	  const panel  = document.getElementById('pickerPanel');

	  const tabEmoji   = document.getElementById('tab-emoji');
	  const tabSticker = document.getElementById('tab-sticker');
	  const tabGif     = document.getElementById('tab-gif');

	  if (!dock || !btn || !panel) return;

	  let lastTab = localStorage.getItem('pickerLastTab') || 'emoji';

	  function open(tab = lastTab){
		panel.style.display = 'block';
		btn.classList.add('active');
		(tab === 'sticker' ? tabSticker :
		 tab === 'gif'     ? tabGif     : tabEmoji)?.click();
	  }
	  function close(){
		panel.style.display = 'none';
		btn.classList.remove('active');
	  }

	  btn.addEventListener('click', () => {
		(panel.style.display === 'block') ? close() : open();
	  });

	  // запоминаем последнюю активную вкладку (через bootstrap tab)
	  [['emoji', tabEmoji], ['sticker', tabSticker], ['gif', tabGif]].forEach(([name, el])=>{
		el?.addEventListener('shown.bs.tab', () => {
		  lastTab = name;
		  localStorage.setItem('pickerLastTab', name);
		});
	  });

	  // клик вне панели/кнопки — закрываем; ESC — тоже
          document.addEventListener('click', (e)=>{
                if (!panel.contains(e.target) && !dock.contains(e.target)) close();
          }, true);
          document.addEventListener('keydown', (e)=>{
                if (e.key === 'Escape') close();
          });

          adjustComposerPadding();
        })();

	async function uploadOneFile(file) {
	  const fd = new FormData();
	  fd.append('user_id', String(currentUserId));
	  fd.append('ticket_id', String(currentTicketId));
	  fd.append('admin', getOperatorName());
	  fd.append('file', file);

	  const tmp = document.createElement('div');
	  tmp.className = 'chat-bubble from-support opacity-75';
	  tmp.dataset.temp = '1';
    tmp.innerHTML = '<small>Отправка…</small><br><strong>🤖 Bender</strong>';
	  historyContent.appendChild(tmp);
	  scrollToBottom(historyContent);
	  const resp = await fetch('/reply_file', { method: 'POST', body: fd });
	  const data = await resp.json();
	if (!data.success) throw new Error(data.error || 'upload failed');

	if (data.reopened) {
	  markTicketReopenedLocally();
	  try { await autoRefreshTickets(); } catch (e) {}
	}

	// ⬇️ вместо оптимистичного рендера — принудительно обновляем историю из API
	if (typeof updateHistory === 'function') {
	  await updateHistory();
	  const c = document.getElementById('historyContent');
	  if (c) c.scrollTop = c.scrollHeight;
	}
	document.querySelectorAll('#historyContent .chat-bubble[data-temp="1"]').forEach(n => n.remove());
	}

// Стикеры
document.getElementById('fileSticker')?.addEventListener('change', async (e)=>{
  const f = e.target.files?.[0]; if (!f) return;
  try { await uploadOneFile(f); } catch(err){ alert('❌ ' + err.message); } finally { e.target.value=''; }
});

// GIF
document.getElementById('fileGif')?.addEventListener('change', async (e)=>{
  const f = e.target.files?.[0]; if (!f) return;
  try { await uploadOneFile(f); } catch(err){ alert('❌ ' + err.message); } finally { e.target.value=''; }
});

		// На переходный период (чтобы не вылавливать все вызовы сразу)
		function updateUnreadBadge(n) { setUnread(n ?? unreadCount); }
	let lastSeenAt = null;
    let columnSettings = {
		client: true,
		clientStatus: true,
		channel: true,
		ticketId: true,
		business: true,
		location: true,
		problem: true,
		responsible: true,
		status: true,
		date: true,
		time: true,
		actions: true
    };
	let lastRenderedAt = null;     // ISO-время последнего отрисованного сообщения
	let unreadCountValue = 0;           // счётчик непрочитанных во время открытой модалки
	let historyModalIsOpen = false;
	    let historyHasFocus = true;    // фокус внутри модалки
        let unreadCountByTicket = JSON.parse(localStorage.getItem('unreadCountByTicket') || '{}');     // { [ticketId]: number }
        function getTicketById(ticketId) {
          const id = String(ticketId);
          return window.allTickets?.find(t => String(t.ticket_id) === id)
                || window.filteredTickets?.find(t => String(t.ticket_id) === id)
                || null;
        }

        function updateTicketResponsible(ticketId, effective, source = '', manual = '', autoValue = '', assignedAt = null, assignedBy = '') {
          const normalizedId = String(ticketId);

          const apply = (ticket) => {
            if (!ticket || typeof ticket !== 'object') return;
            ticket.responsible = (effective || '').trim();
            ticket.responsible_source = source || '';
            ticket.manual_responsible = (manual || '').trim();
            ticket.auto_responsible = (autoValue || '').trim();
            if (assignedAt !== undefined) {
              ticket.responsible_assigned_at = assignedAt;
            }
            if (assignedBy !== undefined) {
              ticket.responsible_assigned_by = assignedBy;
            }
          };

          apply(getTicketById(normalizedId));

          if (Array.isArray(window.filteredTickets)) {
            const idx = window.filteredTickets.findIndex(t => String(t.ticket_id) === normalizedId);
            if (idx >= 0) apply(window.filteredTickets[idx]);
          }

          if (window.currentTicketDetails && String(window.currentTicketDetails.ticket_id || window.currentTicketDetails.ticketId || '') === normalizedId) {
            apply(window.currentTicketDetails);
            responsibleControlState.ticketId = normalizedId;
            responsibleControlState.effective = (effective || '').trim();
            responsibleControlState.manual = (manual || '').trim();
            responsibleControlState.auto = (autoValue || '').trim();
            responsibleControlState.source = source || '';
            updateResponsibleDisplay(responsibleControlState.effective);
            const selectEl = document.getElementById('dialogResponsibleSelect');
            if (selectEl) {
              const targetValue = responsibleControlState.manual || responsibleControlState.effective || '';
              if (targetValue) {
                if (!Array.from(selectEl.options).some(opt => opt.value.toLowerCase() === targetValue.toLowerCase())) {
                  const opt = document.createElement('option');
                  opt.value = targetValue;
                  opt.textContent = `${targetValue} (вне списка)`;
                  selectEl.appendChild(opt);
                }
              }
              selectEl.value = targetValue;
            }
          }

          if (filtersCurrentlyActive && window.filteredTickets) {
            displayTicketsForCurrentPageFiltered();
            updatePaginationFiltered();
          } else {
            displayTicketsForCurrentPage();
            updatePagination();
          }
        }

        function toBool(value) {
          return value === true || value === 1 || value === '1';
        }

        function normalizeSingleTicket(rawTicket) {
          if (!rawTicket || typeof rawTicket !== 'object') {
            return rawTicket;
          }

          const ticket = { ...rawTicket };

          ticket.responsible = (ticket.responsible || '').trim();
          ticket.manual_responsible = (ticket.manual_responsible || '').trim();
          ticket.auto_responsible = (ticket.auto_responsible || '').trim();
          ticket.responsible_source = ticket.responsible_source || '';
          const statusLower = String(ticket.status || '').toLowerCase();
          const rawStatusLower = String(ticket.raw_status || '').toLowerCase();

          const isResolved = statusLower.includes('решен') || statusLower.includes('закрыт')
            || ['resolved', 'closed'].includes(rawStatusLower);

          if (!isResolved) {
            const supportResponded = toBool(ticket.has_support_reply);
            const lastSenderRaw = (ticket.last_sender ?? ticket.last_sender_type ?? '') || '';
            const lastSender = String(lastSenderRaw).toLowerCase().trim();

            if (!supportResponded) {
              ticket.status = 'Новая';
            } else if (['user', 'client', 'клиент'].includes(lastSender)) {
              ticket.status = 'Ожидает реакции';
            } else if (lastSender) {
              ticket.status = 'Ожидает клиента';
            }
          }

          return ticket;
        }

        function normalizeTicketsFromServer(rawTickets) {
          if (!Array.isArray(rawTickets)) return [];
          return rawTickets.map(normalizeSingleTicket);
        }

        function getTicketCreatedAt(ticket) {
          if (!ticket) return null;
          const raw = ticket.created_at
            || ticket.createdAt
            || (ticket.created_date && ticket.created_time ? `${ticket.created_date} ${ticket.created_time}` : null)
            || ticket.created
            || ticket.createdDate;
          if (!raw) return null;
          const iso = normalizeToISO(raw);
          const date = new Date(iso);
          return isNaN(date) ? null : date;
        }

        function formatTicketListTime(ticket) {
          const date = getTicketCreatedAt(ticket);
          if (!date) return '—';
          const dd = String(date.getDate()).padStart(2, '0');
          const mm = String(date.getMonth() + 1).padStart(2, '0');
          const hh = String(date.getHours()).padStart(2, '0');
          const mi = String(date.getMinutes()).padStart(2, '0');
          return `${dd}.${mm} ${hh}:${mi}`;
        }

        function renderClientTicketsList(userId, activeTicketId) {
          const section = document.getElementById('clientTicketsSection');
          const list = document.getElementById('clientTicketsList');
          const counter = document.getElementById('clientTicketsCount');
          if (!section || !list) return;

          const tickets = (window.allTickets || []).filter(t => String(t.user_id ?? t.userId ?? '') === String(userId));
          if (!tickets.length) {
            section.style.display = 'none';
            list.innerHTML = '';
            if (counter) counter.textContent = '0';
            return;
          }

          const sorted = tickets.slice().sort((a, b) => {
            const ta = getTicketCreatedAt(a)?.getTime() ?? 0;
            const tb = getTicketCreatedAt(b)?.getTime() ?? 0;
            return tb - ta;
          });

          const html = sorted.map(ticket => {
            const isActive = String(ticket.ticket_id) === String(activeTicketId);
            const status = ticket.status || '—';
            const created = formatTicketListTime(ticket);
            const unread = unreadCountByTicket?.[String(ticket.ticket_id)] ?? 0;
            const unreadBadge = unread > 0
              ? `<span class="badge bg-danger ms-2">${unread}</span>`
              : '';

            return `
              <button type="button"
                      class="list-group-item list-group-item-action ${isActive ? 'active' : ''}"
                      data-ticket-id="${ticket.ticket_id}"
                      data-user-id="${ticket.user_id}">
                <div class="d-flex justify-content-between align-items-center">
                  <span class="fw-semibold">#${escapeHtml(String(ticket.ticket_id))}</span>
                  <span class="text-muted small">${escapeHtml(created)}</span>
                </div>
                <div class="d-flex justify-content-between align-items-center mt-1">
                  <span class="small">${escapeHtml(String(status))}</span>
                  ${unreadBadge}
                </div>
              </button>
            `;
          }).join('');

          list.innerHTML = html;
          section.style.display = 'block';
          if (counter) counter.textContent = String(tickets.length);
        }

        function adjustComposerPadding() {
          const ta = document.getElementById('replyTextInHistory');
          if (!ta) return;
          const dock = document.getElementById('composerDock');
          const dockHeight = dock ? (dock.offsetHeight || dock.clientHeight || 0) : 0;
          const extra = dockHeight ? dockHeight + 8 : 0;
          ta.style.paddingBottom = extra ? `${extra}px` : '';
        }

        window.addEventListener('resize', adjustComposerPadding, { passive: true });
		        function shouldDisplayUnreadBadge(ticket, overrideStatus) {
          if (!ticket) return true;
          const resolvedBy = String(ticket.resolved_by || '').toLowerCase();
          const autoClosed = resolvedBy.includes('авто') || resolvedBy.includes('auto');
          if (autoClosed) return true;

          const rawStatus = String(ticket.raw_status || '').toLowerCase();
          const humanStatus = String(overrideStatus || ticket.status || '').toLowerCase();
          const resolvedStatuses = ['resolved', 'closed'];
          const isResolvedRaw = resolvedStatuses.includes(rawStatus);
          const isResolvedHuman = humanStatus.includes('решено') || humanStatus.includes('закрыт') || humanStatus.includes('resolved') || humanStatus.includes('closed');
          return !(isResolvedRaw || isResolvedHuman);
        }
        const unreadFetchQueue = [];
        const unreadFetchInFlight = new Map();
        const unreadFetchTimestamps = new Map();
        const MAX_CONCURRENT_UNREAD_FETCHES = 2;
                function setTicketUnread(ticketId, n) {
          const key = String(ticketId);
          // Обновляем в таблице заявок
          const badgeInTable = document.querySelector(`.unread-badge[data-ticket="${key}"]`);
          if (badgeInTable) {
                n = Math.max(0, n | 0);
                badgeInTable.textContent = String(n);
                const ticketData = getTicketById(ticketId);
                const canShowUnread = shouldDisplayUnreadBadge(ticketData);
                badgeInTable.style.display = (n > 0 && canShowUnread) ? 'inline-flex' : 'none';
          }

          // Обновляем в модальном окне истории (если открыто)
          const badgeInHistory = document.getElementById('unreadBadge');
          if (badgeInHistory && String(currentTicketId) === key) {
                badgeInHistory.textContent = String(n);
                badgeInHistory.classList.toggle('d-none', n === 0);
          }

          unreadCountByTicket[key] = Math.max(0, n | 0);
          // 💾 Сохраняем в localStorage
                localStorage.setItem('unreadCountByTicket', JSON.stringify(unreadCountByTicket));
        }
        function recalcTicketUnreadFromDOM(ticketId) {
          const lastRead = lastReadAtByTicket[ticketId] || 0;
          let count = 0;

          // Если история открыта — считаем по DOM
	  if (currentTicketId == ticketId) {
		const content = document.getElementById('historyContent');
		if (content) {
		  content.querySelectorAll('.chat-bubble.from-user').forEach(b => {
			const ts = Number(b.dataset.ts) || 0;
			if (ts > lastRead) count++;
		  });
		}
	  } else {
		// Если история не открыта — используем сохранённое значение
		count = unreadCountByTicket[ticketId] || 0;
	  }

	  setTicketUnread(ticketId, count);
	  
          // Сохраняем в localStorage для отображения в таблице
          localStorage.setItem('unreadCountByTicket', JSON.stringify(unreadCountByTicket));
        }

        function refreshUnreadIndicators(scheduleFetch = true) {
          allTickets.forEach(ticket => {
                if (!ticket || ticket.ticket_id == null) return;
                const ticketId = String(ticket.ticket_id);

                if (String(currentTicketId) === ticketId) {
                  recalcTicketUnreadFromDOM(ticketId);
                } else {
                  const saved = unreadCountByTicket[ticketId];
                  setTicketUnread(ticketId, saved == null ? 0 : saved);
                }

                if (scheduleFetch) {
                  scheduleUnreadUpdate(ticket);
                }
          });
        }

	// Сохранение ширины столбцов
function saveColumnWidths() {
  const widths = {};
  document.querySelectorAll('th[data-column]').forEach(th => {
    const column = th.getAttribute('data-column');
    widths[column] = th.style.width || getComputedStyle(th).width;
  });
  localStorage.setItem('columnWidths', JSON.stringify(widths));
}

function isAtBottom(el) {
  return (el.scrollHeight - el.scrollTop - el.clientHeight) < 4;
}

function scrollToBottom(el) {
  el.scrollTop = el.scrollHeight;
}

// === Плавающие кнопки скролла в истории ===
function ensureHistoryScrollButtons() {
  const content = document.getElementById('historyContent');
  if (!content) return;

  // Родитель — хост для оверлея (не скроллится)
  const host = content.closest('.history-pane') || content.parentElement;
  if (!host) return;

  // Делаем его якорем позиционирования
  host.classList.add('history-viewport');
  if (getComputedStyle(host).position === 'static') {
    host.style.position = 'relative';
  }

  // Если кнопок ещё нет — создаём их в host (а не в content!)
  if (!host.querySelector('.history-scroll-btn.top')) {
    const topBtn = document.createElement('button');
    topBtn.type = 'button';
    topBtn.className = 'history-scroll-btn top';
    topBtn.title = 'Вверх списка сообщений';
    topBtn.innerText = '⬆️';
    topBtn.addEventListener('click', () => {
      content.scrollTo({ top: 0, behavior: 'smooth' });
    });
    host.appendChild(topBtn);
  }

  if (!host.querySelector('.history-scroll-btn.bottom')) {
    const bottomBtn = document.createElement('button');
    bottomBtn.type = 'button';
    bottomBtn.className = 'history-scroll-btn bottom';
    bottomBtn.title = 'Вниз списка сообщений';
    bottomBtn.innerText = '⬇️';
    bottomBtn.addEventListener('click', () => {
	  content.scrollTo({ top: content.scrollHeight, behavior: 'smooth' });
	  // фиксируем «прочитано»
	  lastSeenAt = new Date();
	  lastReadAtByTicket[currentTicketId] = Date.now();
	  localStorage.setItem('lastReadAtByTicket', JSON.stringify(lastReadAtByTicket));
	  setUnread(0);
	  setTicketUnread(currentTicketId, 0);
	});
    host.appendChild(bottomBtn);
  }

  // Обновлять видимость кнопок в зависимости от положения скролла
	const updateBtns = () => {
		const topBtn = host.querySelector('.history-scroll-btn.top');
		const bottomBtn = host.querySelector('.history-scroll-btn.bottom');
		if (!topBtn || !bottomBtn) return;

		const atTop = content.scrollTop <= 0;
		const atBottom = content.scrollHeight - content.clientHeight - content.scrollTop <= 10;

		topBtn.style.visibility = atTop ? 'hidden' : 'visible';
		bottomBtn.style.visibility = atBottom ? 'hidden' : 'visible';
		// Динамический зазор от зоны ввода
		const sendArea = host.querySelector('.input-group-send');
		// --- Сообщаем CSS фактическую высоту панели ввода (для padding-bottom истории)
			if (sendArea) {
			  const updateSendH = () => host.style.setProperty('--send-h', sendArea.offsetHeight + 'px');
			  updateSendH();

			  // Следим за изменениями высоты (переразмер textarea, адаптив и т.п.)
			  try {
				const ro = new ResizeObserver(updateSendH);
				ro.observe(sendArea);
			  } catch (e) {
				// Fallback для старых браузеров
				window.addEventListener('resize', updateSendH);
			  }
			}
		const pad = (sendArea?.offsetHeight || 0) + 9; // 6px как и раньше
		bottomBtn.style.bottom = pad + 'px';
	};

	  // навешиваем один раз
	  if (!content._scrollBtnsBound) {
		content.addEventListener('scroll', updateBtns, { passive: true });
		content._scrollBtnsBound = true;
	  }
	  updateBtns();
	}

	// Наблюдатель чтения
	let io;                          // IntersectionObserver
	const observedBubbles = new WeakSet();

	function setupReadObserver() {
	  const chatEl = document.getElementById('historyContent');
	  if (!chatEl) return;
	  if (io) io.disconnect();

	  io = new IntersectionObserver((entries) => {
		let maxTs = lastReadAtByTicket[currentTicketId] || 0;
		let changed = false;

		entries.forEach(e => {
		  if (!e.isIntersecting) return;
		  const el = e.target;
		  // Нас интересуют только клиентские пузыри
		  if (!el.classList.contains('from-user')) return;

		  const ts = Number(el.dataset.ts) || 0;
		  if (ts > maxTs) { maxTs = ts; changed = true; }
		});

		if (changed) {
		  // Обновляем «прочитано до» по тикету
		  lastReadAtByTicket[currentTicketId] = maxTs;
		  localStorage.setItem('lastReadAtByTicket', JSON.stringify(lastReadAtByTicket));

		  // Пересчитываем непрочитанные: все клиентские с ts > maxTs
		  const chatEl = document.getElementById('historyContent');
		  let count = 0;
		  chatEl.querySelectorAll('.chat-bubble.from-user').forEach(b => {
			const ts = Number(b.dataset.ts) || 0;
			if (ts > maxTs) count++;
		  });
		  setUnread(count);
		}
	  }, { root: document.getElementById('historyContent'), threshold: 0.7 });
	}

	function watchUserBubbles() {
	  const chatEl = document.getElementById('historyContent');
	  if (!chatEl || !io) return;
	  chatEl.querySelectorAll('.chat-bubble.from-user').forEach(b => {
		if (!observedBubbles.has(b)) {
		  io.observe(b);
		  observedBubbles.add(b);
		}
	  });
	}

	function tzOffsetMinutes(tz, at = new Date()) {
	  try {
		const parts = new Intl.DateTimeFormat('en-US', {
		  timeZone: tz, year:'numeric', month:'2-digit', day:'2-digit',
		  hour:'2-digit', minute:'2-digit', second:'2-digit', hour12:false
		}).formatToParts(at).reduce((o,p)=>{o[p.type]=p.value; return o;}, {});
		const asUTC = Date.UTC(+parts.year, +parts.month - 1, +parts.day, +parts.hour, +parts.minute, +parts.second);
		return Math.round((asUTC - at.getTime()) / 60000);
    } catch (error) { return 0; }
	}

		
	function normalizeToISO(x) {
	  if (x == null) return new Date().toISOString();
	  if (typeof x === 'number') {
		const ms = x < 1e12 ? x * 1000 : x;
		return new Date(ms).toISOString();
	  }
	  if (typeof x === 'string') {
		const s = x.trim();
		// Уже ISO с Z или смещением — используем как есть
		if (/[zZ]$/.test(s) || /[+-]\d{2}:\d{2}$/.test(s)) {
		  const d = new Date(s);
		  return isNaN(d) ? new Date().toISOString() : d.toISOString();
		}
		// Без таймзоны — считаем UTC (все времена в БД хранятся как UTC)
		if (/^\d{4}-\d{2}-\d{2}[ T]\d{2}:\d{2}:\d{2}$/.test(s)) {
		  const norm = s.replace(' ', 'T') + 'Z';
		  const d = new Date(norm);
		  return isNaN(d) ? new Date().toISOString() : d.toISOString();
		}
		// Иное — даём JS распарсить
		const d = new Date(s);
		return isNaN(d) ? new Date().toISOString() : d.toISOString();
	  }
	  return new Date().toISOString();
	}

        function sortMessagesStable(arr) {
          return arr.sort((a, b) => {
                const ta = sortTsMs(a), tb = sortTsMs(b);
                if (ta !== tb) return ta - tb;

                // дальше — детерминированные догоняющие ключи
                const ma = Number(telegramMid(a) ?? 0);
                const mb = Number(telegramMid(b) ?? 0);
                if (ma && mb && ma !== mb) return ma - mb;

                const ka = msgKey(a);
                const kb = msgKey(b);
                return ka.localeCompare(kb);
          });
        }

        function scheduleUnreadUpdate(ticket) {
          if (!ticket || ticket.ticket_id == null) return;

          const ticketId = String(ticket.ticket_id);
          if (historyModalIsOpen && String(currentTicketId) === ticketId) return;

          const lastSenderRaw = ticket.last_sender ?? ticket.last_sender_type ?? ticket.last_message_sender ?? ticket.last_message_from ?? ticket.last_author ?? '';
          const lastSender = String(lastSenderRaw || '').toLowerCase().trim();
          const direction = String(ticket.last_message_direction || ticket.direction || ticket.last_direction || ticket.last_message_side || '').toLowerCase().trim();

          const fromSupport = isSupportSenderLabel(lastSenderRaw) || ['out','outgoing','support','operator'].includes(direction);
          if (fromSupport) return;

          const fromUser = isUserSenderLabel(lastSenderRaw) || ['in','incoming','user','client','customer'].includes(direction);
          if (!fromUser && !lastSender && !direction) {
            // не удалось определить отправителя — всё равно делаем один запрос
          }

          const now = Date.now();
          if (unreadFetchInFlight.has(ticketId)) return;
          if (unreadFetchQueue.some(item => String(item.ticket.ticket_id) === ticketId)) return;

          const lastFetch = unreadFetchTimestamps.get(ticketId) || 0;
          if (now - lastFetch < 5000) return;

          unreadFetchQueue.push({ ticket });
          processUnreadFetchQueue();
        }

        function processUnreadFetchQueue() {
          if (unreadFetchInFlight.size >= MAX_CONCURRENT_UNREAD_FETCHES) return;

          const next = unreadFetchQueue.shift();
          if (!next) return;

          const ticketId = String(next.ticket.ticket_id);
          const promise = requestUnreadCountForTicket(next.ticket)
            .catch(err => {
              console.error('Не удалось обновить счётчик непрочитанных для заявки', ticketId, err);
            })
            .finally(() => {
              unreadFetchInFlight.delete(ticketId);
              unreadFetchTimestamps.set(ticketId, Date.now());
              processUnreadFetchQueue();
            });

          unreadFetchInFlight.set(ticketId, promise);
        }

        async function requestUnreadCountForTicket(ticket) {
          const ticketId = String(ticket.ticket_id);
          const params = new URLSearchParams({
            ticket_id: ticketId,
            _: String(Date.now())
          });

          if (ticket.channel_id != null && ticket.channel_id !== '' && ticket.channel_id !== 'null') {
            params.set('channel_id', String(ticket.channel_id));
          }

          const resp = await fetch(`/history?${params.toString()}`, { cache: 'no-store' });
          if (!resp.ok) {
            throw new Error(`HTTP ${resp.status}`);
          }

          const data = await resp.json();
          if (data && data.success === false) {
            throw new Error(data.error || 'history response error');
          }
          const messages = Array.isArray(data.messages) ? data.messages : [];
          const lastRead = lastReadAtByTicket[ticketId] || 0;

          let count = 0;

          for (const msg of messages) {
            const sender = String(msg.sender || '').toLowerCase();
            if (sender !== 'user') continue;

            const ts = Date.parse(normalizeToISO(msg.timestamp));
            if (!Number.isFinite(ts)) continue;

            if (ts > lastRead) count += 1;
          }

          setTicketUnread(ticketId, count);
        }

        function scheduleUnreadUpdate(ticket) {
          if (!ticket || ticket.ticket_id == null) return;

          const ticketId = String(ticket.ticket_id);
          if (historyModalIsOpen && String(currentTicketId) === ticketId) return;

          const lastSender = String(ticket.last_sender || '').toLowerCase();
          if (lastSender !== 'user') return;

          const now = Date.now();
          if (unreadFetchInFlight.has(ticketId)) return;
          if (unreadFetchQueue.some(item => String(item.ticket.ticket_id) === ticketId)) return;

          const lastFetch = unreadFetchTimestamps.get(ticketId) || 0;
          if (now - lastFetch < 5000) return;

          unreadFetchQueue.push({ ticket });
          processUnreadFetchQueue();
        }

        function processUnreadFetchQueue() {
          if (unreadFetchInFlight.size >= MAX_CONCURRENT_UNREAD_FETCHES) return;

          const next = unreadFetchQueue.shift();
          if (!next) return;

          const ticketId = String(next.ticket.ticket_id);
          const promise = requestUnreadCountForTicket(next.ticket)
            .catch(err => {
              console.error('Не удалось обновить счётчик непрочитанных для заявки', ticketId, err);
            })
            .finally(() => {
              unreadFetchInFlight.delete(ticketId);
              unreadFetchTimestamps.set(ticketId, Date.now());
              processUnreadFetchQueue();
            });

          unreadFetchInFlight.set(ticketId, promise);
        }

        async function requestUnreadCountForTicket(ticket) {
          const ticketId = String(ticket.ticket_id);
          const params = new URLSearchParams({
            ticket_id: ticketId,
            _: String(Date.now())
          });

          if (ticket.channel_id != null && ticket.channel_id !== '' && ticket.channel_id !== 'null') {
            params.set('channel_id', String(ticket.channel_id));
          }

          const resp = await fetch(`/history?${params.toString()}`, { cache: 'no-store' });
          if (!resp.ok) {
            throw new Error(`HTTP ${resp.status}`);
          }

          const data = await resp.json();
          if (data && data.success === false) {
            throw new Error(data.error || 'history response error');
          }
          const messages = Array.isArray(data.messages) ? data.messages : [];
          const lastRead = lastReadAtByTicket[ticketId] || 0;

          let count = 0;

          for (const msg of messages) {
            const sender = String(msg.sender || '').toLowerCase();
            if (sender !== 'user') continue;

            const ts = Date.parse(normalizeToISO(msg.timestamp));
            if (!Number.isFinite(ts)) continue;

            if (ts > lastRead) count += 1;
          }

          setTicketUnread(ticketId, count);
        }

function displayTicketDateTime(t) {
  // берём пару полей, как сейчас рисуешь таблицу; если есть альтернативы — тоже пробуем
  const base = (t.created_date && t.created_time)
    ? `${t.created_date} ${t.created_time}`
    : (t.created_at || t.updated_at || t.last_message_at || null);

  if (!base) return { date: '—', time: '—' };

  const iso = normalizeToISO(base);   // учтёт локаль сервера и вернёт UTC ISO
  const formatted = fmtTsISO(iso);    // форматирует под выбранную TZ оператора, напр. "26.09.2025, 13:45:12"
  const [date, time] = formatted.split(',').map(s => s.trim());
  return { date: date || '—', time: time || '—' };
}

// Универсальный рендерер сообщений
function renderMessagesHTML(ticket_id, messages, clientData) {
  return (messages || []).map(msg => {
    const rawSender = String(msg.sender || '').toLowerCase().trim();
    const isSupport =
      ['support','operator','admin','поддержка','оператор','staff','agent'].includes(rawSender) ||
      msg.is_support === true ||
      msg.from_support === true ||
      msg.is_outgoing === true ||
      msg.sender_type === 'support' ||
      msg.direction === 'out' ||
      msg.sender === 'support';

    const cls  = isSupport ? 'from-support' : 'from-user';
    let name   = isSupport ? '🤖 Bender' : '👤 Клиент';

	const tsRaw = (msg.timestamp ?? msg.date ?? msg.created_at ?? msg.createdAt ?? null);
	const isMedia = !!(msg.message_type && msg.message_type !== 'text' && msg.attachment);
	const iso   = normalizeToISO(tsRaw, isMedia);
	const time  = fmtTsISO(iso);                 // применит текущую TZ оператора
	const tsMs  = Date.parse(iso);               // для data-ts

    const bodyText = (msg.message ?? msg.text ?? msg.body ?? '').toString();

    // Имя отправителя
    if (!isSupport) {
      const clientName = clientData?.client_name;
      const username   = clientData?.username;
      if (clientName && clientName !== 'не задано') name = '👤 ' + clientName;
      else if (username) name = '👤 @' + username;
      else name = '👤 Клиент';
    } else {
      name = msg.sender_name || '🤖 Bender';
    }

    let mediaHtml = '';
    if (msg.message_type && msg.message_type !== 'text' && msg.attachment) {
      mediaHtml = createMediaHtml(ticket_id, {
        message_type: msg.message_type,
        attachment: msg.attachment,
        text: bodyText
      });
    }

    return `
      <div class="chat-bubble ${cls} ${msg.deleted_at ? 'opacity-50' : ''}"
         data-sender="${isSupport ? 'support' : 'user'}"
         data-ts="${tsMs}"
         data-tg-id="${safeId(msg) ?? ''}"
         data-mid="${telegramMid(msg) ?? ''}">
        <div class="bubble-meta">
          <small class="msg-time" data-iso="${iso}">${fmtTsISO(iso)}</small>
          <div class="bubble-actions dropdown">
            <button class="btn btn-sm btn-light p-1 px-2" data-bs-toggle="dropdown" aria-expanded="false"
                    title="Действия" style="line-height:1">⋯</button>
            <ul class="dropdown-menu dropdown-menu-end">
              <li><button class="dropdown-item action-reply">↩ Ответить</button></li>
              ${isSupport ? `
                <li><button class="dropdown-item action-edit">✏️ Редактировать</button></li>
                <li><button class="dropdown-item text-danger action-delete">🗑 Удалить</button></li>
                <li><hr class="dropdown-divider"></li>
                <li><button class="dropdown-item action-download">⤓ Скачать вложение</button></li>
              ` : `
                <li><button class="dropdown-item action-download">⤓ Скачать вложение</button></li>
              `}
            </ul>
          </div>
        </div>
        <strong class="msg-author">${name}</strong>
                ${msg.edited_at ? `<span class="badge-meta">изменено</span>` : ``}
                ${msg.deleted_at ? `<span class="badge-meta">удалено у клиента</span>` : ``}

        ${(msg.reply_preview || msg.reply_to_tg_id) ? `
		  <div
			class="reply-preview rp-jump"
			data-target="${msg.reply_to_tg_id || ''}"
			title="Показать исходное сообщение"
			style="cursor:pointer"
		  >
			<div class="rp-box">${escapeHtml(msg.reply_preview || '').replace(/\n/g,'<br>')}</div>
		  </div>
		` : ''}
	
        ${bodyText && (!msg.message_type || msg.message_type === 'text')
          ? `<p class="msg-text mb-1">${escapeHtml(bodyText).replace(/\n/g,'<br>')}</p>`
          : ''}

        ${mediaHtml}

      </div>
    `;
  }).join('');
}

function escapeHtml(s=''){return s.replace(/[&<>"']/g,m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;' }[m]));}

function normalizeActiveDialogStatus(value) {
  if (value == null) return '';
  const trimmed = String(value).trim();
  return ACTIVE_DIALOG_ALLOWED_STATUSES.has(trimmed) ? trimmed : '';
}

function getSidebarCurrentWidth() {
  const sidebar = document.getElementById('app-sidebar');
  if (!sidebar) return 0;
  const rect = sidebar.getBoundingClientRect();
  return Math.max(0, Math.round(rect.width || 0));
}

function updateHistoryModalSidebarOffset() {
  const modal = document.getElementById('historyModal');
  if (!modal || !modal.classList.contains('fullscreen')) return;
  modal.style.setProperty('--history-sidebar-offset', `${getSidebarCurrentWidth()}px`);
}

function setHistoryModalFullscreen(expanded) {
  const modal = document.getElementById('historyModal');
  const toggleBtn = document.getElementById('toggleHistoryFullscreenBtn');
  const nextState = Boolean(expanded);
  if (!modal) return;

  modal.classList.toggle('fullscreen', nextState);
  if (nextState) {
    updateHistoryModalSidebarOffset();
  } else {
    modal.style.removeProperty('--history-sidebar-offset');
  }

  if (toggleBtn) {
    toggleBtn.setAttribute('aria-pressed', nextState ? 'true' : 'false');
    toggleBtn.title = nextState ? 'Свернуть окно истории' : 'Развернуть окно истории';
    toggleBtn.textContent = nextState ? '🗗' : '⛶';
  }
}

function persistActiveDialogs() {
  try {
    const data = Array.from(activeDialogs.values());
    localStorage.setItem('historyActiveDialogs', JSON.stringify(data));
  } catch (e) {
    console.error('Не удалось сохранить список активных диалогов', e);
  }
}

function renderActiveDialogs() {
  const list = document.getElementById('activeDialogList');
  const block = document.getElementById('activeDialogsBlock');
  const clearBtn = document.getElementById('clearActiveDialogsBtn');
  const counter = document.getElementById('activeDialogCount');
  if (!list || !block) return;

  list.innerHTML = '';
  const dialogs = Array.from(activeDialogs.values())
    .map(dialog => {
      const status = normalizeActiveDialogStatus(dialog.status);
      if (!status) return null;
      if (dialog.status !== status) dialog.status = status;
      return dialog;
    })
    .filter(Boolean)
    .sort((a, b) => (b.updatedAt || 0) - (a.updatedAt || 0));

  const total = dialogs.length;
  if (counter) {
    counter.textContent = String(total);
    counter.classList.toggle('bg-secondary', total > 0);
    counter.classList.toggle('bg-light', total === 0);
    counter.classList.toggle('text-muted', total === 0);
  }

  if (!total) {
    block.classList.remove('show');
    if (clearBtn) clearBtn.disabled = true;
    return;
  }

  block.classList.add('show');
  if (clearBtn) clearBtn.disabled = false;

  const currentId = currentTicketId != null ? String(currentTicketId) : null;
  const orderedStatuses = Array.from(ACTIVE_DIALOG_ALLOWED_STATUSES);

  orderedStatuses.forEach(status => {
    const groupItems = dialogs.filter(dialog => dialog.status === status);
    if (!groupItems.length) return;

    const heading = document.createElement('div');
    heading.className = 'status-heading';
    heading.innerHTML = `
      <span>${escapeHtml(status)}</span>
      <span class="badge bg-light text-muted">${groupItems.length}</span>
    `;
    list.appendChild(heading);

    groupItems.forEach(dialog => {
      const ticketId = String(dialog.ticketId || '');
      if (!ticketId) return;
      const isActive = currentId === ticketId;
      const item = document.createElement('div');
      item.className = `list-group-item list-group-item-action${isActive ? ' active' : ''}`;
      item.dataset.ticketId = ticketId;
      item.dataset.userId = String(dialog.userId || '');
      item.dataset.status = dialog.status;

      const business = escapeHtml(dialog.business || '—');
      const location = escapeHtml(dialog.location || '—');
      const clientName = escapeHtml(dialog.clientName || '—');
      const ticketLabel = escapeHtml(ticketId);
      const badgeClass = dialog.status === 'Ожидает реакции'
        ? 'badge bg-danger'
        : 'badge bg-info text-dark';

      item.innerHTML = `
        <div class="d-flex w-100 align-items-start">
          <div class="flex-grow-1">
            <div class="fw-semibold d-flex align-items-center justify-content-between gap-2">
              <span>${clientName} <span class="${isActive ? 'text-light' : 'text-muted'}">#${ticketLabel}</span></span>
              <span class="${badgeClass}">${escapeHtml(dialog.status)}</span>
            </div>
            <div class="small ${isActive ? 'text-light' : 'text-muted'}">${business} • ${location}</div>
          </div>
          <button type="button" class="btn btn-link btn-sm text-decoration-none text-muted dialog-remove-btn" data-ticket-id="${ticketLabel}" aria-label="Убрать диалог">✕</button>
        </div>`;

      list.appendChild(item);
    });
  });
}

function registerActiveDialog(info = {}) {
  const ticketId = info.ticketId != null ? String(info.ticketId) : null;
  const userId = info.userId != null ? String(info.userId) : null;
  if (!ticketId || !userId) return;

  const status = normalizeActiveDialogStatus(info.status);
  const hasSupport = info.hasSupport === true;
  if (!status || !hasSupport) {
    removeActiveDialog(ticketId);
    return;
  }

  const existing = activeDialogs.get(ticketId) || {};
  const entry = {
    ticketId,
    userId,
    clientName: info.clientName || existing.clientName || '—',
    business: info.business || existing.business || '—',
    location: info.location || existing.location || '—',
    status,
    hasSupport: true,
    updatedAt: Date.now()
  };

  activeDialogs.set(ticketId, entry);
  persistActiveDialogs();
  renderActiveDialogs();
}

function removeActiveDialog(ticketId) {
  if (ticketId == null) return;
  activeDialogs.delete(String(ticketId));
  persistActiveDialogs();
  renderActiveDialogs();
}

function restoreActiveDialogs() {
  try {
    const raw = localStorage.getItem('historyActiveDialogs');
    if (raw) {
      const parsed = JSON.parse(raw);
      activeDialogs.clear();
      if (Array.isArray(parsed)) {
        parsed.forEach(item => {
          if (!item || item.ticketId == null || item.userId == null) return;
          const status = normalizeActiveDialogStatus(item.status);
          if (!status || item.hasSupport !== true) return;
          const ticketId = String(item.ticketId);
          activeDialogs.set(ticketId, {
            ticketId,
            userId: String(item.userId),
            clientName: item.clientName || '—',
            business: item.business || '—',
            location: item.location || '—',
            status,
            hasSupport: true,
            updatedAt: item.updatedAt || Date.now()
          });
        });
      }
    }
  } catch (e) {
    console.error('Не удалось восстановить список активных диалогов', e);
    activeDialogs.clear();
  }
  renderActiveDialogs();
}

// Гарантируем доступность функции в глобальном контексте,
// поскольку обработчики событий могут выполняться вне текущей области видимости.
window.restoreActiveDialogs = restoreActiveDialogs;

function parseMediaPayload(raw) {
  if (!raw) return null;
  try {
    return JSON.parse(decodeURIComponent(raw));
  } catch (e) {
    console.error('Не удалось распарсить данные медиа', e);
    return null;
  }
}

const MEDIA_VIEWER_MIN_WIDTH = 480;
const MEDIA_VIEWER_MIN_HEIGHT = 360;
const MEDIA_VIEWER_MAX_WIDTH = 1280;
const MEDIA_VIEWER_MAX_HEIGHT = 1024;
const VIDEO_MIME_TYPES = {
  mp4: 'video/mp4',
  m4v: 'video/mp4',
  webm: 'video/webm',
  mov: 'video/quicktime',
  mkv: 'video/x-matroska'
};

function clampMediaDimensions(width, height) {
  let w = Number(width) || 0;
  let h = Number(height) || 0;

  if (w <= 0 || h <= 0) {
    w = MEDIA_VIEWER_MIN_WIDTH;
    h = MEDIA_VIEWER_MIN_HEIGHT;
  }

  const minScale = Math.max(
    MEDIA_VIEWER_MIN_WIDTH / w,
    MEDIA_VIEWER_MIN_HEIGHT / h,
    1
  );
  w *= minScale;
  h *= minScale;

  const maxScale = Math.min(
    MEDIA_VIEWER_MAX_WIDTH / w,
    MEDIA_VIEWER_MAX_HEIGHT / h,
    1
  );
  w *= maxScale;
  h *= maxScale;

  const viewportWidth = Math.max(320, window.innerWidth - 64);
  const viewportHeight = Math.max(240, window.innerHeight - 180);
  const viewportScale = Math.min(1, viewportWidth / w, viewportHeight / h);
  if (viewportScale < 1) {
    w *= viewportScale;
    h *= viewportScale;
  }

  return {
    width: Math.round(Math.min(MEDIA_VIEWER_MAX_WIDTH, Math.max(w, MEDIA_VIEWER_MIN_WIDTH))),
    height: Math.round(Math.min(MEDIA_VIEWER_MAX_HEIGHT, Math.max(h, MEDIA_VIEWER_MIN_HEIGHT)))
  };
}

function applyMediaViewerSize(modalEl, width, height) {
  if (!modalEl) return { width: MEDIA_VIEWER_MIN_WIDTH, height: MEDIA_VIEWER_MIN_HEIGHT };
  const size = clampMediaDimensions(width, height);
  modalEl.style.setProperty('--media-viewer-width', `${size.width}px`);
  modalEl.style.setProperty('--media-viewer-height', `${size.height}px`);
  return size;
}

function getDisplayFilename(rawValue) {
  if (!rawValue) return '';
  const normalized = String(rawValue).trim();
  if (!normalized) return '';
  const parts = normalized.split(/[\\/]+/);
  return parts.pop() || '';
}

function openMediaViewer(payload) {
  if (!payload || !payload.url) return;
  const modalEl = document.getElementById('mediaViewerModal');
  const body = document.getElementById('mediaViewerBody');
  const titleEl = document.getElementById('mediaViewerTitle');
  const downloadLink = document.getElementById('mediaViewerDownload');
  if (!modalEl || !body || !titleEl || !downloadLink) return;

  body.innerHTML = '';
  const url = payload.url;
  const filename = String(payload.filename || '');
  const displayName = getDisplayFilename(filename);
  const caption = String(payload.caption || '');
  const type = String(payload.type || '').toLowerCase();
  const lowerName = (displayName || filename).toLowerCase();

  titleEl.textContent = displayName ? `Медиа: ${displayName}` : 'Просмотр медиа';
  downloadLink.href = url;
  if (displayName) {
    downloadLink.download = displayName;
  } else if (filename) {
    downloadLink.download = filename;
  } else {
    downloadLink.removeAttribute('download');
  }

  applyMediaViewerSize(modalEl, payload.width || payload.video_width || MEDIA_VIEWER_MIN_WIDTH, payload.height || payload.video_height || MEDIA_VIEWER_MIN_HEIGHT);

  let element = null;
  if (['photo', 'image'].includes(type) || /\.(png|jpe?g|gif|webp)$/i.test(lowerName)) {
    element = document.createElement('img');
    element.src = url;
    element.alt = filename || 'Медиа';
  } else if (['video', 'animation'].includes(type) || /\.(mp4|webm|mov|m4v)$/i.test(lowerName)) {
    const video = document.createElement('video');
    video.controls = true;
    video.preload = 'auto';
    video.playsInline = true;
    video.style.width = '100%';
    video.style.height = 'auto';
    video.style.display = 'block';

    const source = document.createElement('source');
    source.src = url;
    const extension = (payload.extension || lowerName.split('.').pop() || '').toLowerCase();
    if (VIDEO_MIME_TYPES[extension]) {
      source.type = VIDEO_MIME_TYPES[extension];
    }
    video.appendChild(source);
    video.textContent = 'Ваш браузер не поддерживает видео.';

    const desiredWidth = Number(payload.video_width || payload.width || 0);
    const desiredHeight = Number(payload.video_height || payload.height || 0);
    let appliedSize = applyMediaViewerSize(modalEl, desiredWidth, desiredHeight);

    video.addEventListener('loadedmetadata', () => {
      if (!modalEl.isConnected) return;
      const metadataWidth = Number(video.videoWidth || appliedSize.width);
      const metadataHeight = Number(video.videoHeight || appliedSize.height);
      appliedSize = applyMediaViewerSize(modalEl, metadataWidth, metadataHeight);
    }, { once: true });

    element = video;
  } else if (type === 'document' || /\.(pdf)$/i.test(lowerName)) {
    const frame = document.createElement('iframe');
    frame.src = url;
    frame.title = filename || 'Документ';
    frame.style.width = '100%';
    frame.style.height = '70vh';
    frame.setAttribute('loading', 'lazy');
    element = frame;
  } else {
    const fallback = document.createElement('div');
    fallback.className = 'text-center w-100';
    const message = document.createElement('p');
    message.className = 'mb-2';
    message.textContent = 'Предпросмотр недоступен. Скачайте файл, чтобы открыть его.';
    fallback.appendChild(message);
    if (caption) {
      const captionEl = document.createElement('p');
      captionEl.className = 'text-muted small mb-0';
      captionEl.textContent = caption;
      fallback.appendChild(captionEl);
    }
    element = fallback;
  }

  body.appendChild(element);

  if (element?.tagName === 'VIDEO') {
    requestAnimationFrame(() => {
      try {
        element.load();
      } catch (error) {
        console.warn('Не удалось подготовить видео перед воспроизведением', error);
      }
    });
  }

  if (caption && element.tagName !== 'DIV') {
    const captionEl = document.createElement('p');
    captionEl.className = 'text-muted small mt-3 mb-0 text-center w-100';
    captionEl.textContent = caption;
    body.appendChild(captionEl);
  }

  const modal = bootstrap.Modal.getOrCreateInstance(modalEl);
  modal.show();
}

async function fetchAdminUsersList() {
  if (Array.isArray(cachedAdminUsers)) return cachedAdminUsers;
  try {
    const resp = await fetch('/api/admin/users', { credentials: 'same-origin' });
    if (!resp.ok) {
      throw new Error(`HTTP ${resp.status}`);
    }
    const data = await resp.json();
    const users = Array.isArray(data?.users)
      ? data.users.map(u => String(u || '').trim()).filter(Boolean)
      : [];
    cachedAdminUsers = users;
    return users;
  } catch (e) {
    cachedAdminUsers = null;
    throw e;
  }
}

function updateResponsibleDisplay(name) {
  const displayEl = document.getElementById('dialogResponsibleDisplay');
  if (displayEl) {
    displayEl.textContent = name ? name : 'ещё не в работе';
  }
}

async function populateResponsibleSelect() {
  const selectEl = document.getElementById('dialogResponsibleSelect');
  const assignBtn = document.getElementById('assignResponsibleBtn');
  if (!selectEl) return;

  if (assignBtn) assignBtn.disabled = true;
  selectEl.innerHTML = '';

  const placeholder = document.createElement('option');
  placeholder.value = '';
  placeholder.textContent = '— Не назначен —';
  selectEl.appendChild(placeholder);

  try {
    const users = await fetchAdminUsersList();
    const seen = new Set();
    users.forEach(user => {
      const normalized = String(user || '').trim();
      if (!normalized) return;
      const key = normalized.toLowerCase();
      if (seen.has(key)) return;
      seen.add(key);
      const opt = document.createElement('option');
      opt.value = normalized;
      opt.textContent = normalized;
      selectEl.appendChild(opt);
    });

    const effective = responsibleControlState.manual || responsibleControlState.effective;
    if (effective) {
      const key = effective.toLowerCase();
      if (!Array.from(selectEl.options).some(opt => opt.value.toLowerCase() === key)) {
        const opt = document.createElement('option');
        opt.value = effective;
        opt.textContent = `${effective} (вне списка)`;
        selectEl.appendChild(opt);
      }
    }

    const manualValue = responsibleControlState.manual || '';
    selectEl.value = manualValue;
  } catch (error) {
    console.error('Не удалось загрузить список сотрудников', error);
    selectEl.innerHTML = '';
    const option = document.createElement('option');
    option.value = '';
    option.textContent = '— Ошибка загрузки —';
    selectEl.appendChild(option);
    selectEl.value = '';
  } finally {
    if (assignBtn) assignBtn.disabled = false;
  }
}

async function setupResponsibleControl(ticketDetails = {}) {
  responsibleControlState.ticketId = ticketDetails?.ticket_id ?? ticketDetails?.ticketId ?? currentTicketId ?? null;
  responsibleControlState.auto = (ticketDetails?.auto_responsible || ticketDetails?.autoResponsible || '').trim();
  responsibleControlState.manual = (ticketDetails?.manual_responsible || ticketDetails?.manualResponsible || '').trim();
  const effective = (ticketDetails?.responsible || '').trim()
    || responsibleControlState.manual
    || responsibleControlState.auto;
  responsibleControlState.effective = effective ? effective.trim() : '';
  responsibleControlState.source = ticketDetails?.responsible_source
    || (responsibleControlState.manual ? 'manual' : (responsibleControlState.auto ? 'auto' : ''));

  updateResponsibleDisplay(responsibleControlState.effective);
  await populateResponsibleSelect();
}

async function assignResponsibleFromControl() {
  const ticketId = responsibleControlState.ticketId;
  const selectEl = document.getElementById('dialogResponsibleSelect');
  const assignBtn = document.getElementById('assignResponsibleBtn');
  if (!ticketId || !selectEl || !assignBtn) {
    return;
  }

  const chosen = (selectEl.value || '').trim();
  assignBtn.disabled = true;

  try {
    const resp = await fetch(`/api/tickets/${encodeURIComponent(ticketId)}/responsible`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      credentials: 'same-origin',
      body: JSON.stringify({ responsible: chosen })
    });
    const data = await resp.json().catch(() => ({}));
    if (!resp.ok || data.success === false) {
      throw new Error(data.error || `HTTP ${resp.status}`);
    }

    responsibleControlState.manual = (data.manual || '').trim();
    responsibleControlState.auto = (data.auto || responsibleControlState.auto || '').trim();
    responsibleControlState.effective = (data.responsible || '').trim();
    responsibleControlState.source = data.source || '';

    updateResponsibleDisplay(responsibleControlState.effective);
    await populateResponsibleSelect();

    updateTicketResponsible(
      ticketId,
      responsibleControlState.effective,
      responsibleControlState.source,
      responsibleControlState.manual,
      responsibleControlState.auto,
      data.responsible_assigned_at || null,
      data.responsible_assigned_by || ''
    );
  } catch (error) {
    console.error('assignResponsibleFromControl failed', error);
    alert('Не удалось назначить ответственного: ' + error.message);
  } finally {
    assignBtn.disabled = false;
  }
}

async function inviteUserToDialog(ticketId, invitee) {
  const cleanTicket = ticketId != null ? String(ticketId) : '';
  const cleanInvitee = (invitee || '').trim();
  if (!cleanTicket || !cleanInvitee) {
    throw new Error('Не указан пользователь или диалог');
  }

  const resp = await fetch(`/api/tickets/${encodeURIComponent(cleanTicket)}/invite`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    credentials: 'same-origin',
    body: JSON.stringify({ invitee: cleanInvitee })
  });

  const data = await resp.json().catch(() => ({}));
  if (!resp.ok || data.success === false) {
    throw new Error(data.error || `HTTP ${resp.status}`);
  }
  return data;
}

// Восстановление ширины столбцов
function restoreColumnWidths() {
  const savedWidths = localStorage.getItem('columnWidths');
  if (savedWidths) {
    const widths = JSON.parse(savedWidths);
    Object.keys(widths).forEach(column => {
      const th = document.querySelector(`th[data-column="${column}"]`);
      if (th && widths[column]) {
        th.style.width = widths[column];
        const index = Array.from(th.parentNode.children).indexOf(th);
        document.querySelectorAll('#ticketsBody tr').forEach(row => {
          const cell = row.children[index];
          if (cell) cell.style.width = widths[column];
        });
      }
    });
  }
}
    // Загрузка сохраненных настроек столбцов
    const savedColumnSettings = localStorage.getItem('columnSettings');
    if (savedColumnSettings) {
      columnSettings = JSON.parse(savedColumnSettings);
    }

    // Загрузка сохраненного размера страницы
    const savedPageSize = localStorage.getItem('pageSize');
    if (savedPageSize) {
      currentPageSize = parseInt(savedPageSize);
      document.getElementById('pageSize').value = currentPageSize;
    }

    // === Инициализация resize столбцов ===
function initColumnResize() {
  const headers = document.querySelectorAll('th[data-resizable="true"]');
  headers.forEach(header => {
    const oldHandle = header.querySelector('.resize-handle');
    if (oldHandle) {
      oldHandle.remove();
    }
    
    const handle = document.createElement('div');
    handle.className = 'resize-handle';
    header.appendChild(handle);
    
    let startX, startWidth;
    
    handle.addEventListener('mousedown', function(e) {
  // 1) Жёстко фиксируем текущую ширину в пикселях, чтобы не было пересчёта и «скачка»
  const computed = getComputedStyle(header).width;
  header.style.width = computed;

  // 2) Синхронно фиксируем соответствующие клетки tbody
  const index = Array.from(header.parentNode.children).indexOf(header);
  document.querySelectorAll('#ticketsBody tr').forEach(row => {
    const cell = row.children[index];
    if (cell) cell.style.width = computed;
  });

  startX = e.pageX;
  startWidth = parseFloat(computed);
  document.documentElement.classList.add('resizing');

  function onMouseMove(e) {
    const width = startWidth + (e.pageX - startX);
    if (width > 50) {
      header.style.width = width + 'px';
      const idx = Array.from(header.parentNode.children).indexOf(header);
      document.querySelectorAll('#ticketsBody tr').forEach(row => {
        const cell = row.children[idx];
        if (cell) cell.style.width = width + 'px';
      });
    }
  }

  function onMouseUp() {
    document.removeEventListener('mousemove', onMouseMove);
    document.removeEventListener('mouseup', onMouseUp);
    document.documentElement.classList.remove('resizing');
    saveColumnWidths();
  }

  document.addEventListener('mousemove', onMouseMove);
  document.addEventListener('mouseup', onMouseUp);
  e.preventDefault();
});

  });

    }

    // === Настройки столбцов ===
    function toggleColumnSettings() {
      // Устанавливаем текущие значения чекбоксов
      Object.keys(columnSettings).forEach(key => {
        const checkbox = document.getElementById(`toggle${key.charAt(0).toUpperCase() + key.slice(1)}`);
        if (checkbox) {
          checkbox.checked = columnSettings[key];
        }
      });
      new bootstrap.Modal(document.getElementById('columnSettingsModal')).show();
    }

    function applyColumnSettings() {
    // Сохраняем новые настройки
    Object.keys(columnSettings).forEach(key => {
        const checkbox = document.getElementById(`toggle${key.charAt(0).toUpperCase() + key.slice(1)}`);
        if (checkbox) {
            columnSettings[key] = checkbox.checked;
        }
    });
    
    // Сохраняем настройки в localStorage
    localStorage.setItem('columnSettings', JSON.stringify(columnSettings));
    
    // Применяем настройки к таблице
    document.querySelectorAll('th[data-column]').forEach(th => {
        const column = th.getAttribute('data-column');
        const index = Array.from(th.parentNode.children).indexOf(th);
        
        if (columnSettings[column]) {
            th.classList.remove('table-column-hidden');
            // Показываем колонку в теле таблицы
            document.querySelectorAll('#ticketsBody tr').forEach(row => {
                if (row.children[index]) {
                    row.children[index].classList.remove('table-column-hidden');
                }
            });
        } else {
            th.classList.add('table-column-hidden');
            // Скрываем колонку в теле таблицы
            document.querySelectorAll('#ticketsBody tr').forEach(row => {
                if (row.children[index]) {
                    row.children[index].classList.add('table-column-hidden');
                }
            });
        }
    });
    
    // Закрываем модальное окно только если оно существует
    const modalElement = document.getElementById('columnSettingsModal');
    if (modalElement) {
        const modal = bootstrap.Modal.getInstance(modalElement);
        if (modal) {
            modal.hide();
        }
    }
}
    function applyColumnSettingsFromState() {
  // Применяем настройки к шапке
  document.querySelectorAll('th[data-column]').forEach(th => {
    const column = th.getAttribute('data-column');
    const show = !!columnSettings[column];
    th.classList.toggle('table-column-hidden', !show);
  });

  // Применяем к телу таблицы
  const ths = Array.from(document.querySelectorAll('th[data-column]'));
  document.querySelectorAll('#ticketsBody tr').forEach(tr => {
    ths.forEach((th, idx) => {
      const column = th.getAttribute('data-column');
      const td = tr.children[idx];
      if (td) td.classList.toggle('table-column-hidden', !columnSettings[column]);
    });
  });
}

    // === Открыть окно ответа ===
    function openReplyModal(user_id) {
      currentUserId = user_id;
      document.getElementById('replyText').value = '';
      new bootstrap.Modal(document.getElementById('replyModal')).show();
    }

    // === Отправить ответ (с поддержкой reply/edit) ===
                async function sendReply() {
                  const ta    = document.getElementById('replyText');
                  const text  = (ta?.value || '').trim();
                  const admin = getOperatorName();
                  if (!text) { alert('Введите текст ответа'); return; }

                  try {
                        const resp = await fetch('/reply', {
                          method: 'POST',
			  headers: { 'Content-Type':'application/json' },
			  body: JSON.stringify({
				user_id:   currentUserId,
				ticket_id: currentTicketId,
				admin,
				text,
				reply_to_tg_id: (window.currentReplyToTgId || null)
			  })
			});

			const data = await resp.json();
                        if (!data.success) {
                          if (typeof data.retry_after === 'number' && data.retry_after > 0) {
                                alert(`⏳ Лимит Telegram. Подождите ${data.retry_after} сек и повторите отправку.`);
                                return;
                          }
                          throw new Error(data.error || 'Ошибка отправки');
                        }

                        if (data.reopened) {
                          markTicketReopenedLocally();
                          document.getElementById('closeTicketBtn')?.removeAttribute('disabled');
                          if (typeof showToast === 'function') showToast('Заявка переоткрыта');
                        }

                        updateTicketStatus(currentTicketId, 'Ожидает клиента');
                        try { await autoRefreshTickets(); } catch(e) { console.debug('Auto-refresh failed:', e); }

			window.currentReplyToTgId = null;
			window.currentEditTgId = null;
			if (typeof updateHistory === 'function') {
			  await updateHistory();
			  const container = document.getElementById('historyContent');
			  if (container) container.scrollTop = container.scrollHeight;
			}
			if (ta) ta.value = '';
		  } catch (e) {
			alert('❌ ' + e.message);
		  }
		}

	// === Настройка отправки: хранение, отрисовка, обработчики ===
		function getSendMode() {
		  return localStorage.getItem('sendKeySetting') || 'enter';
		}
		function setSendMode(mode) {
		  localStorage.setItem('sendKeySetting', mode);
		  syncSendUI(mode);
		}

		// Обновляет бейдж на кнопке и активный пункт меню
		function syncSendUI(mode) {
		  const labelMap = {
			enter: 'Enter — отправить',
			ctrlEnter: 'Ctrl+Enter — отправить',
			enterNewline: 'Enter — новая строка'
		  };
		  const shortMap = {
			enter: 'Enter',
			ctrlEnter: 'Ctrl+Enter',
			enterNewline: 'Enter↵'
		  };
			const hint = document.getElementById('sendKeySettingCurrent');
			if (hint) hint.textContent = labelMap[mode] || '—';

		  document.querySelectorAll('#sendKeySetting .dropdown-menu .dropdown-item')
			.forEach(a => {
			  const m = a.getAttribute('data-mode');
			  a.classList.toggle('active', m === mode);
			  // Обновим подписи на случай будущих локализаций
			  if (labelMap[m]) a.lastChild.nodeValue = ' ' + labelMap[m];
			});
		}

		// Инициализация при загрузке скрипта
		(function initSendKeySettings() {
		  const mode = getSendMode();
		  syncSendUI(mode);

		  // Клик по пунктам меню
		  document.querySelectorAll('#sendKeySetting .dropdown-menu .dropdown-item')
			.forEach(a => {
			  a.addEventListener('click', (e) => {
				e.preventDefault();
				const nextMode = a.getAttribute('data-mode');
				setSendMode(nextMode);
			  });
			});

		  // При открытии дропдауна — синхронизация актуального состояния
		  const btn = document.getElementById('sendKeySettingBtn');
		  if (btn) {
			btn.addEventListener('show.bs.dropdown', () => syncSendUI(getSendMode()));
		  }

		  // Обработка клавиш в textarea истории
		  const ta = document.getElementById('replyTextInHistory');
		  const sendBtn = document.getElementById('sendReplyInHistory');
			if (ta && sendBtn) {
				ta.addEventListener('keydown', (e) => {
				  const m = getSendMode();
				  const isEnter = (e.key === 'Enter');
				  const isCtrl = (e.ctrlKey || e.metaKey); // поддержим Cmd на Mac

				  if (m === 'enter' && isEnter && !isCtrl) {
					// Enter — отправить
					e.preventDefault();
					sendBtn.click();
				  } else if (m === 'ctrlEnter' && isEnter && isCtrl) {
					// Ctrl+Enter — отправить
					e.preventDefault();
					sendBtn.click();
				  } else if (m === 'enterNewline' && isEnter && !isCtrl) {
					// Enter — новая строка (ничего не делаем, только перенос)
					// Но предотвращаем «по умолчанию» отправку форм (на всякий случай)
					// e.preventDefault();  // не трогаем, пусть вставляет перенос
				  }
				});
			}
		})();

    
    // === Обработчики выпадающего списка ===
    document.querySelectorAll('#sendKeySettingBtn + .dropdown-menu a').forEach(item => {
      item.addEventListener('click', function (e) {
        e.preventDefault();
        const mode = this.getAttribute('data-mode');
        localStorage.setItem('sendKeySetting', mode);
        setSendMode(mode);
      });
    });

        function applyInitialClientStatusFilter() {
                if (!window.initialClientStatusFilter || window.initialClientStatusFilterApplied) {
                        return;
                }
                const value = window.initialClientStatusFilter;
                const modalInput = document.getElementById('filterClientStatusModal');
                if (modalInput) {
                        modalInput.value = value;
                }
                const inlineInput = document.getElementById('filterClientStatus');
                if (inlineInput) {
                        inlineInput.value = value;
                }
                applyFiltersModal();
                window.initialClientStatusFilterApplied = true;
        }

        // === Автообновление таблица ===
        async function autoRefreshTickets() {
		try {
			const responseStats = await fetch('/stats_data');
			const data = await responseStats.json();

			const totalEl = document.getElementById('total');
			const pendingEl = document.getElementById('pending');
			const resolvedEl = document.getElementById('resolved');

			if (totalEl) totalEl.textContent = data.total || 0;
			if (pendingEl) pendingEl.textContent = data.pending || 0;
			if (resolvedEl) resolvedEl.textContent = data.resolved || 0;

			const responseTable = await fetch('/tickets_list');
                          let tickets = await responseTable.json(); // ← переменная tickets объявлена здесь
                          tickets = normalizeTicketsFromServer(tickets);

			// подтягиваем статусы клиентов
			const statuses = await loadClientStatuses();
                          tickets = tickets.map(t => ({
                                  ...t,
                                  client_status: (statuses?.[t.user_id] ?? t.client_status ?? '—')
                          }));

			console.log("📩 Полученные заявки:", tickets);

                        // Сохраняем все заявки для пагинации
                        allTickets = tickets;

                        if (historyModalIsOpen && currentUserId && currentTicketId) {
                                renderClientTicketsList(currentUserId, currentTicketId);
                                const activeTicket = getTicketById(currentTicketId);
                                if (activeTicket) {
                                        window.currentTicketDetails = { ...window.currentTicketDetails, ...activeTicket };
                                        responsibleControlState.ticketId = String(activeTicket.ticket_id || currentTicketId);
                                        responsibleControlState.manual = (activeTicket.manual_responsible || '').trim();
                                        responsibleControlState.auto = (activeTicket.auto_responsible || '').trim();
                                        responsibleControlState.effective = (activeTicket.responsible || '').trim();
                                        responsibleControlState.source = activeTicket.responsible_source || '';
                                        updateResponsibleDisplay(responsibleControlState.effective);
                                        const selectEl = document.getElementById('dialogResponsibleSelect');
                                        if (selectEl) {
                                                const manualValue = responsibleControlState.manual || '';
                                                if (manualValue && !Array.from(selectEl.options).some(opt => opt.value.toLowerCase() === manualValue.toLowerCase())) {
                                                        const opt = document.createElement('option');
                                                        opt.value = manualValue;
                                                        opt.textContent = manualValue;
                                                        selectEl.appendChild(opt);
                                                }
                                                selectEl.value = manualValue;
                                        }
                                }
                        }

                        if (window.initialClientStatusFilter && !window.initialClientStatusFilterApplied) {
                                applyInitialClientStatusFilter();
                        } else if (filtersCurrentlyActive) {
                                applyFilters({ preservePage: true });
                        } else {
                                // Иначе отображаем все заявки как обычно
                                totalPages = Math.ceil(allTickets.length / currentPageSize);
                                displayTicketsForCurrentPage();
                                updatePagination();
                        }

                        refreshUnreadIndicators();

                } catch (e) {
                        console.error("❌ Ошибка в autoRefreshTickets:", e);
                }
        }

// === Отображение заявок для текущей страницы ===
function displayTicketsForCurrentPage() {
  const container = document.getElementById('ticketsBody');
  if (!container) return;

  container.innerHTML = '';

  totalPages = ensureCurrentPageBounds(allTickets.length);
  persistCurrentPageIfUnfiltered();

  // Рассчитываем индексы для текущей страницы
  const startIndex = (currentPage - 1) * currentPageSize;
  const endIndex = Math.min(startIndex + currentPageSize, allTickets.length);
  
  // Получаем заявки для текучной страницы
  const pageTickets = allTickets.slice(startIndex, endIndex);
  
  if (pageTickets.length === 0) {
    container.innerHTML = '<tr><td colspan="12" class="text-center text-muted py-3">Нет заявок для отображения</td></tr>';
    return;
  }
  
  pageTickets.forEach(t => {
  const username = t.username ? `@${t.username}` : 'нет юзернейма';
  const clientName = t.client_name || 'не задано';

  // СОЗДАЁМ СТРОКУ
  const row = document.createElement('tr');

  // Индекс для фильтрации (то, по чему работает applyFilters)
  const searchIndex = [
    String(t.user_id || ''),
    String(t.ticket_id || ''),
    String(t.client_status || ''),
    String(t.channel_name || ''),
    String(t.business || ''),
    String(t.city || ''),
    String(t.location_name || ''),
    String(t.problem || ''),
    String(t.responsible || ''),
    String(t.raw_status || ''),
    String(t.status || ''),
    String(t.created_date || ''),
    String(t.created_time || ''),
    String(t.username || ''),
    String(clientName || '')
  ].join(' ').toLowerCase();
  row.dataset.search = searchIndex;

  const clientCell = `
  <div class="d-flex align-items-center gap-2">
    <img src="${t.avatar_url || '/static/default-avatar.png'}" 
         alt="" 
         width="36" 
         height="36" 
         class="rounded-circle" 
         style="object-fit:cover; border:1px solid rgba(0,0,0,.08)"
         onerror="this.src='/static/default-avatar.png'">
    <span class="clickable-client" data-user-id="${t.user_id}" onclick="window.open('/client/${t.user_id}', '_blank')">${
      (t.client_name && t.client_name !== 'не задано') ? t.client_name :
      (t.username ? '@' + t.username : 'Клиент ' + t.user_id)
    }</span>
  </div>`;

	let statusBadge;

	if (t.raw_status === 'resolved') {
	  statusBadge = `<span class="badge bg-success">✅ Решено</span>`;
	} else {
	  if (t.status === 'Новая') {
		statusBadge = `<span class="badge bg-secondary">🆕 Новая</span>`;
	  } else if (t.status === 'Ожидает реакции') {
		statusBadge = `<span class="badge bg-danger">⏳ Ожидает реакции</span>`;
	  } else {
		statusBadge = `<span class="badge bg-info text-dark">⏳ Ожидает клиента</span>`;
	  }
	}

	// Счётчик непрочитанных (слева от статуса)
		const unreadBadge = `<span class="badge bg-danger me-1 unread-badge" data-ticket="${t.ticket_id}" style="display:none;">0</span>`;
		statusBadge = unreadBadge + statusBadge;

  let businessClass = '';
  if (t.business === 'СушиВесла') businessClass = 'business-sushi';
  else if (t.business === 'БлинБери') businessClass = 'business-blin';

  // Кнопка создания задачи (безопасно прокидываем текст через JSON.stringify, чтобы не париться с кавычками)
                let createTaskBtn;
                if (t.linked_task_id) {
                  createTaskBtn = `<button class="btn btn-sm btn-outline-primary open-task-btn" data-task-id="${t.linked_task_id}">
                     №DL_${t.linked_task_id}
                   </button>`;
                } else {
                  const sanitizedProblem = (t.problem || '').replace(/"/g, '&quot;');
                  const sanitizedLocation = (t.location_name || t.city || '').replace(/"/g, '&quot;');
                  createTaskBtn = `<button class="btn btn-sm btn-outline-primary create-task-btn"`
                     data-problem="${sanitizedProblem}"
                     data-location="${sanitizedLocation}"
                     data-ticket="${t.ticket_id}">
                     Создать задачу
                   </button>`;
                }

        const businessValue = t.business || '—';
        const responsibleDisplay = (t.responsible || '').trim() || 'ещё не в работе';
        const historyButton = `<button class="btn btn-sm btn-outline-secondary w-100" onclick="loadHistory(${t.user_id}, '${t.ticket_id}')">История</button>`;
        const closeButton = (t.raw_status !== 'resolved')
          ? `<button class="btn btn-sm btn-danger w-100" onclick="confirmClose(${t.user_id}, '${t.ticket_id}')">Закрыть</button>`
          : '';
        const actionsColumn = `<div class="actions-column">${historyButton}${closeButton}</div>`;
        const actionBtns = `<div class="actions-layout">${actionsColumn}<div class="actions-side">${createTaskBtn}</div></div>`;

  let rowHTML = '';
        rowHTML += `<td>${clientCell}</td>`;
        rowHTML += `<td>${t.client_status || '—'}</td>`;
        rowHTML += `<td>${t.channel_name || '—'}</td>`;
        rowHTML += `<td><code>${t.ticket_id}</code></td>`;
        rowHTML += `<td class="business-cell ${businessClass}">${businessValue}</td>`;
        rowHTML += `<td>${t.city}<br><small>${t.location_name}</small></td>`;
        rowHTML += `<td>${t.problem}</td>`;
        rowHTML += `<td>${responsibleDisplay}</td>`;
        rowHTML += `<td>${statusBadge}</td>`;
        const dt = displayTicketDateTime(t);
                rowHTML += `<td>${dt.date}</td>`;
                rowHTML += `<td>${dt.time}</td>`;
        rowHTML += `<td class="actions-cell">${actionBtns}</td>`;
	row.innerHTML = rowHTML;
	container.appendChild(row);
		// --- ВОССТАНОВЛЕНИЕ СЧЁТЧИКА НЕПРОЧИТАННЫХ ПРИ ОТРИСОВКЕ ---
		let unread = 0;
		const lastRead = lastReadAtByTicket[t.ticket_id] || 0;
		if (unreadCountByTicket[t.ticket_id] !== undefined) {
		  unread = unreadCountByTicket[t.ticket_id];
		} else {
		  // Если вообще нет данных — считаем 0
		  unread = 0;
		}

                setTicketUnread(t.ticket_id, unread);
                scheduleUnreadUpdate(t);
                });
	parseEmojis(document.getElementById('ticketsBody'));
		applyColumnSettingsFromState();
		initColumnResize(); // Инициализируем resize после обновления таблицы
		}


	// === Обновление пагинации ===
	function updatePagination() {
	  const paginationContainer = document.getElementById('pagination');
	  if (!paginationContainer) return;
	  
	  paginationContainer.innerHTML = '';
	  
	  if (totalPages <= 1) return;
	  
	  // Кнопка "Назад"
	  const prevLi = document.createElement('li');
	  prevLi.className = `page-item ${currentPage === 1 ? 'disabled' : ''}`;
	  prevLi.innerHTML = `<a class="page-link" href="#" onclick="changePage(${currentPage - 1})">&laquo;</a>`;
	  paginationContainer.appendChild(prevLi);
	  
	  // Нумерация страниц
		const startPage = Math.max(1, currentPage - 2);
		const endPage = Math.min(totalPages, startPage + 4);
	  
		for (let i = startPage; i <= endPage; i++) {
			const pageLi = document.createElement('li');
			pageLi.className = `page-item ${i === currentPage ? 'active' : ''}`;
			pageLi.innerHTML = `<a class="page-link" href="#" onclick="changePage(${i})">${i}</a>`;
			paginationContainer.appendChild(pageLi);
			}
			  
			  // Кнопка "Вперед"
			  const nextLi = document.createElement('li');
			  nextLi.className = `page-item ${currentPage === totalPages ? 'disabled' : ''}`;
			  nextLi.innerHTML = `<a class="page-link" href="#" onclick="changePage(${currentPage + 1})">&raquo;</a>`;
			  paginationContainer.appendChild(nextLi);
			}

			// === Смена страницы ===
			function changePage(page) {
                          if (page < 1 || page > totalPages) return;

                          currentPage = page;
                          persistCurrentPageIfUnfiltered();
                          displayTicketsForCurrentPage();
                          updatePagination();
			  
			  // Прокручиваем к верху таблицы
			  document.querySelector('.table-responsive').scrollIntoView({ behavior: 'smooth' });
			}

			// === Обработчик изменения количества отображаемых заявок ===
                                document.getElementById('pageSize')?.addEventListener('change', function() {
                                  currentPageSize = parseInt(this.value);
                                  localStorage.setItem('pageSize', currentPageSize);
                                  currentPage = 1; // Сбрасываем на первую страницу
                                  const sourceLength = window.filteredTickets ? window.filteredTickets.length : allTickets.length;
                                  totalPages = ensureCurrentPageBounds(sourceLength);
                                  persistCurrentPageIfUnfiltered();
                                  if (window.filteredTickets) {
                                        displayTicketsForCurrentPageFiltered();
                                        updatePaginationFiltered();
                                  } else {
                                        displayTicketsForCurrentPage();
                                        updatePagination();
                                  }
                                  });
                          // Делегированный клик по миниатюрам (у тебя класс .js-preview уже проставляется)
                                  document.addEventListener('click', (e) => {
                                    const target = e.target.closest('.js-preview');
                                    if (!target) return;
                                    const full = target.getAttribute('data-fullsrc') || target.src;
                                    const img = document.getElementById('imageViewerImg');
                                    if (img) {
                                          img.src = full;
                                          const modal = document.getElementById('imageViewerModal');
                                          if (modal) {
                                                new bootstrap.Modal(modal).show();
                                          }
                                    }
                                  });
                          // Клик по блоку "Ответ на" — перейти к исходному сообщению
                                  document.addEventListener('click', function (e) {
                                    const box = e.target.closest('.reply-preview.rp-jump');
                                    if (!box) return;

                                    const targetTgId = box.getAttribute('data-target');
                                    if (!targetTgId) return;

                                    const target = document.querySelector(`.chat-bubble[data-tg-id="${targetTgId}"]`);
                                    if (target) {
                                          target.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                          target.classList.add('reply-target');
                                          setTimeout(() => target.classList.remove('reply-target'), 1200);
                                    }
                                  });
                          // Не закрывать дропдауны категорий при клике по лейблу/чекбоксу (история и закрытие)
                                  document.addEventListener('click', function(e) {
                                                    const menu = e.target.closest('.dropdown-menu');
                                                    if (!menu) return;

                                            // Клик был внутри меню категорий истории?
							if (menu.closest('#historyModal')) {
								const item = e.target.closest('.form-check');
								if (item) {
								  e.preventDefault();
								  e.stopPropagation();
								  const input = item.querySelector('input[type="checkbox"]');
								  if (input && e.target !== input) {
									input.checked = !input.checked;
								  }
								  if (typeof syncCategorySelection === 'function') {
									syncCategorySelection();
								  }
								}
							}

						  // Клик был внутри меню категорий модалки закрытия?
							if (menu.closest('#closeTicketModal')) {
								const item = e.target.closest('.form-check');
								if (item) {
								  e.preventDefault();
								  e.stopPropagation();
								  const input = item.querySelector('input[type="checkbox"]');
								  if (input && e.target !== input) {
									input.checked = !input.checked;
								  }
								  if (typeof syncCloseCategorySelection === 'function') {
									syncCloseCategorySelection();
								  }
								}
								if (selectedCategory) {
								  // категория выбрана → закрываем напрямую без второго окна
								  closeTicketDirectly(ticketId, selectedCategory);
								  return;
								}
							}
						}, true);

			  // === Загрузка статусов клиентов ===
						async function loadClientStatuses() {
							try {
								const response = await fetch('/client_statuses');
								if (response.ok) {
									return await response.json();
								}
							} catch (e) {
								console.error("Ошибка загрузки статусов клиентов:", e);
							}
							return {};
						}


					// === Фильтрация ===
					// === Фильтрация (применяется ко всем данным) ===
						function collectInlineFilterValues() {
        return {
                search: document.getElementById('searchInput')?.value.toLowerCase() || '',
                status: document.getElementById('filterStatus')?.value.toLowerCase() || '',
                user: document.getElementById('filterUser')?.value.toLowerCase() || '',
                ticketId: document.getElementById('filterTicketId')?.value.toLowerCase() || '',
                business: document.getElementById('filterBusiness')?.value.toLowerCase() || '',
                location: document.getElementById('filterLocation')?.value.toLowerCase() || '',
                responsible: document.getElementById('filterResponsible')?.value.toLowerCase() || '',
                clientStatus: document.getElementById('filterClientStatus')?.value.toLowerCase() || '',
                dateFrom: document.getElementById('filterDateFrom')?.value || '',
                dateTo: document.getElementById('filterDateTo')?.value || ''
        };
						}

						function applyFilters(optionsOrEvent = {}) {
        let options = {};
        if (optionsOrEvent && typeof optionsOrEvent === 'object' && typeof optionsOrEvent.preventDefault === 'function') {
                optionsOrEvent.preventDefault();
        } else if (optionsOrEvent && typeof optionsOrEvent === 'object') {
                options = optionsOrEvent;
        }
        const preservePage = !!options.preservePage;
        const values = collectInlineFilterValues();
        const { search, status, user, ticketId, business, location, responsible, clientStatus, dateFrom, dateTo } = values;
        const hasActiveFilters = [search, status, user, ticketId, business, location, responsible, clientStatus, dateFrom, dateTo].some(Boolean);

        if (!hasActiveFilters) {
                filtersCurrentlyActive = false;
                window.filteredTickets = null;
                totalPages = ensureCurrentPageBounds(allTickets.length);
                persistCurrentPageIfUnfiltered();
                displayTicketsForCurrentPage();
                updatePagination();
                return;
        }

        filtersCurrentlyActive = true;

        const filteredTickets = allTickets.filter(t => {
                const searchIndex = [
                        String(t.user_id || ''),
                        String(t.ticket_id || ''),
                        String(t.client_status || ''),
                        String(t.channel_name || ''),
                        String(t.business || ''),
                        String(t.city || ''),
                        String(t.location_name || ''),
                        String(t.problem || ''),
                        String(t.responsible || ''),
                        String(t.raw_status || ''),
                        String(t.status || ''),
                        String(t.created_date || ''),
                        String(t.created_time || ''),
                        String(t.username || ''),
                        String(t.client_name || '')
                ].join(' ').toLowerCase();

                const createdDate = t.created_date || '';

                return (!search || searchIndex.includes(search)) &&
                       (!status || searchIndex.includes(status)) &&
                       (!user || searchIndex.includes(user)) &&
                       (!ticketId || searchIndex.includes(ticketId)) &&
                       (!business || searchIndex.includes(business)) &&
                       (!location || searchIndex.includes(location)) &&
                       (!responsible || searchIndex.includes(responsible)) &&
                       (!clientStatus || searchIndex.includes(clientStatus)) &&
                       (!dateFrom || createdDate >= dateFrom) &&
                       (!dateTo || createdDate <= dateTo);
        });

        displayFilteredTickets(filteredTickets, { preservePage });

						}

						function displayFilteredTickets(filteredTickets, options = {}) {
        const preservePage = !!options.preservePage;
        if (!preservePage) {
                currentPage = 1;
        } else {
                ensureCurrentPageBounds(filteredTickets.length);
        }
        totalPages = ensureCurrentPageBounds(filteredTickets.length);
        window.filteredTickets = filteredTickets;
        displayTicketsForCurrentPageFiltered();
        updatePaginationFiltered();

						}

						function displayTicketsForCurrentPageFiltered() {
                                                        const container = document.getElementById('ticketsBody');
                                                        if (!container) return;

                                                        container.innerHTML = '';

                                                        // Используем отфильтрованные данные
                                                        const ticketsToDisplay = window.filteredTickets || allTickets;

                                                        totalPages = ensureCurrentPageBounds(ticketsToDisplay.length);

                                                        // Рассчитываем индексы для текущей страницы
                                                        const startIndex = (currentPage - 1) * currentPageSize;
                                                        const endIndex = Math.min(startIndex + currentPageSize, ticketsToDisplay.length);
							
							// Получаем заявки для текущей страницы
							const pageTickets = ticketsToDisplay.slice(startIndex, endIndex);
							
							if (pageTickets.length === 0) {
								container.innerHTML = '<tr><td colspan="12" class="text-center text-muted py-3">Нет заявок для отображения</td></tr>';
								return;
							}
							
							// Отрисовываем заявки (используем существующую логику отрисовки)
							pageTickets.forEach(t => {
								const username = t.username ? `@${t.username}` : 'нет юзернейма';
								const clientName = t.client_name || 'не задано';

								const row = document.createElement('tr');
								
								// Индекс для поиска (если понадобится)
								const searchIndex = [
									String(t.user_id || ''),
									String(t.ticket_id || ''),
									String(t.client_status || ''),
									String(t.channel_name || ''),
									String(t.business || ''),
									String(t.city || ''),
									String(t.location_name || ''),
									String(t.problem || ''),
									String(t.responsible || ''),
									String(t.raw_status || ''),
									String(t.status || ''),
									String(t.created_date || ''),
									String(t.created_time || ''),
									String(t.username || ''),
									String(clientName || '')
								].join(' ').toLowerCase();
								row.dataset.search = searchIndex;

								// Остальная логика отрисовки остается такой же, как в displayTicketsForCurrentPage()
								const clientCell = `
								<div class="d-flex align-items-center gap-2">
									<img src="${t.avatar_url || '/static/default-avatar.png'}" 
										 alt="" 
										 width="36" 
										 height="36" 
										 class="rounded-circle" 
										 style="object-fit:cover; border:1px solid rgba(0,0,0,.08)"
										 onerror="this.src='/static/default-avatar.png'">
									<span class="clickable-client" data-user-id="${t.user_id}" onclick="window.open('/client/${t.user_id}', '_blank')">${
									(t.client_name && t.client_name !== 'не задано') ? t.client_name :
									(t.username ? '@' + t.username : 'Клиент ' + t.user_id)
									}</span>
								</div>`;

								let statusBadge;
								if (t.raw_status === 'resolved') {
									statusBadge = `<span class="badge bg-success">✅ Решено</span>`;
								} else {
									if (t.status === 'Новая') {
										statusBadge = `<span class="badge bg-secondary">🆕 Новая</span>`;
									} else if (t.status === 'Ожидает реакции') {
										statusBadge = `<span class="badge bg-danger">⏳ Ожидает реакции</span>`;
									} else {
										statusBadge = `<span class="badge bg-info text-dark">⏳ Ожидает клиента</span>`;
									}
								}

								const unreadBadge = `<span class="badge bg-danger me-1 unread-badge" data-ticket="${t.ticket_id}" style="display:none;">0</span>`;
								statusBadge = unreadBadge + statusBadge;

								let businessClass = '';
								if (t.business === 'СушиВесла') businessClass = 'business-sushi';
								else if (t.business === 'БлинБери') businessClass = 'business-blin';

								const createTaskBtn = (t.linked_task_id)
									? `<button class="btn btn-sm btn-outline-primary open-task-btn" data-task-id="${t.linked_task_id}">
									   №DL_${t.linked_task_id}
									 </button>`
									: `<button class="btn btn-sm btn-outline-primary create-task-btn"
									   data-problem="${(t.problem||'').replace(/"/g,'&quot;')}"
									   data-location="${(t.location_name||t.city||'').replace(/"/g,'&quot;')}"
									   data-ticket="${t.ticket_id}">
									   Создать задачу
									 </button>`;

								                                                                  const businessValue = t.business || '—';
                                                                  const responsibleDisplay = (t.responsible || '').trim() || 'ещё не в работе';
                                                                  const historyButton = `<button class="btn btn-sm btn-outline-secondary w-100" onclick="loadHistory(${t.user_id}, '${t.ticket_id}')">История</button>`;
                                                                  const closeButton = (t.raw_status !== 'resolved')
                                                                          ? `<button class="btn btn-sm btn-danger w-100" onclick="confirmClose(${t.user_id}, '${t.ticket_id}')">Закрыть</button>`
                                                                          : '';
                                                                  const actionsColumn = `<div class="actions-column">${historyButton}${closeButton}</div>`;
                                                                  const actionBtns = `<div class="actions-layout">${actionsColumn}<div class="actions-side">${createTaskBtn}</div></div>`;

                                                                  let rowHTML = '';
                                                                  rowHTML += `<td>${clientCell}</td>`;
                                                                  rowHTML += `<td>${t.client_status || '—'}</td>`;
                                                                  rowHTML += `<td>${t.channel_name || '—'}</td>`;
                                                                  rowHTML += `<td><code>${t.ticket_id}</code></td>`;
                                                                  rowHTML += `<td class="business-cell ${businessClass}">${businessValue}</td>`;
                                                                  rowHTML += `<td>${t.city}<br><small>${t.location_name}</small></td>`;
                                                                  rowHTML += `<td>${t.problem}</td>`;
                                                                  rowHTML += `<td>${responsibleDisplay}</td>`;
                                                                  rowHTML += `<td>${statusBadge}</td>`;
                                                                  const dt = displayTicketDateTime(t);
                                                                          rowHTML += `<td>${dt.date}</td>`;
                                                                          rowHTML += `<td>${dt.time}</td>`;
                                                                  rowHTML += `<td class="actions-cell">${actionBtns}</td>`;
								row.innerHTML = rowHTML;
								container.appendChild(row);

								// Восстановление счетчика непрочитанных
								let unread = 0;
								const lastRead = lastReadAtByTicket[t.ticket_id] || 0;
								if (unreadCountByTicket[t.ticket_id] !== undefined) {
									unread = unreadCountByTicket[t.ticket_id];
								} else {
									unread = 0;
								}
								setTicketUnread(t.ticket_id, unread);
							});
							
							parseEmojis(document.getElementById('ticketsBody'));
							applyColumnSettingsFromState();
							initColumnResize();
						}

						// === Обновление пагинации для отфильтрованных данных ===
						function updatePaginationFiltered() {
							const paginationContainer = document.getElementById('pagination');
							if (!paginationContainer) return;
							
							paginationContainer.innerHTML = '';
							
                                                        const ticketsToDisplay = window.filteredTickets || allTickets;
                                                        totalPages = ensureCurrentPageBounds(ticketsToDisplay.length);
							
							if (totalPages <= 1) return;
							
							// Кнопка "Назад"
							const prevLi = document.createElement('li');
							prevLi.className = `page-item ${currentPage === 1 ? 'disabled' : ''}`;
							prevLi.innerHTML = `<a class="page-link" href="#" onclick="changePageFiltered(${currentPage - 1})">&laquo;</a>`;
							paginationContainer.appendChild(prevLi);
							
							// Нумерация страниц
							const startPage = Math.max(1, currentPage - 2);
							const endPage = Math.min(totalPages, startPage + 4);
							
							for (let i = startPage; i <= endPage; i++) {
								const pageLi = document.createElement('li');
								pageLi.className = `page-item ${i === currentPage ? 'active' : ''}`;
								pageLi.innerHTML = `<a class="page-link" href="#" onclick="changePageFiltered(${i})">${i}</a>`;
								paginationContainer.appendChild(pageLi);
							}
							
							// Кнопка "Вперед"
							const nextLi = document.createElement('li');
							nextLi.className = `page-item ${currentPage === totalPages ? 'disabled' : ''}`;
							nextLi.innerHTML = `<a class="page-link" href="#" onclick="changePageFiltered(${currentPage + 1})">&raquo;</a>`;
							paginationContainer.appendChild(nextLi);
						}

						// === Смена страницы для отфильтрованных данных ===
						function changePageFiltered(page) {
							if (page < 1 || page > totalPages) return;
							
							currentPage = page;
							displayTicketsForCurrentPageFiltered();
							updatePaginationFiltered();
							
							// Прокручиваем к верху таблицы
							document.querySelector('.table-responsive').scrollIntoView({ behavior: 'smooth' });
						}

						// === Сброс фильтров ===
						function resetFilters() {
							  // Сбрасываем значения фильтров (только существующие элементы)
							  const filterIds = [
								'searchInput', 'filterStatus', 'filterUser', 'filterTicketId', 
								'filterBusiness', 'filterLocation', 'filterClientStatus', 
								'filterResponsible', 'filterDateFrom', 'filterDateTo'
							  ];
							  
							  filterIds.forEach(id => {
								const element = document.getElementById(id);
								if (element) {
								  element.value = '';
								}
							  });
							  
							  // Возвращаемся к отображению всех заявок
                                                          currentPage = 1;
                                                          filtersCurrentlyActive = false;
                                                          window.filteredTickets = null;
                                                          totalPages = ensureCurrentPageBounds(allTickets.length);
                                                          persistCurrentPageIfUnfiltered();
                                                          displayTicketsForCurrentPage();
                                                          updatePagination();
                                                }

   // === Обновляем обработчики событий ===
		document.addEventListener('DOMContentLoaded', function() {
		  // Обработчики для основных фильтров (теперь применяются ко всем данным)
		  const searchInput = document.getElementById('searchInput');
		  if (searchInput) searchInput.addEventListener('input', applyFilters);
		  
		  // Добавьте обработчики для остальных фильтров аналогично
		  const filterStatus = document.getElementById('filterStatus');
		  if (filterStatus) filterStatus.addEventListener('change', applyFilters);
		  
		  const filterUser = document.getElementById('filterUser');
		  if (filterUser) filterUser.addEventListener('input', applyFilters);
		  
		  const filterTicketId = document.getElementById('filterTicketId');
		  if (filterTicketId) filterTicketId.addEventListener('input', applyFilters);
		  
		  const filterBusiness = document.getElementById('filterBusiness');
		  if (filterBusiness) filterBusiness.addEventListener('input', applyFilters);
		  
		  const filterLocation = document.getElementById('filterLocation');
		  if (filterLocation) filterLocation.addEventListener('input', applyFilters);
		  
		  const filterClientStatus = document.getElementById('filterClientStatus');
		  if (filterClientStatus) filterClientStatus.addEventListener('input', applyFilters);
		  
		  const filterDateFrom = document.getElementById('filterDateFrom');
		  if (filterDateFrom) filterDateFrom.addEventListener('input', applyFilters);
		  
		  const filterDateTo = document.getElementById('filterDateTo');
		  if (filterDateTo) filterDateTo.addEventListener('input', applyFilters);
		  
		  const filterResponsible = document.getElementById('filterResponsible');
		  if (filterResponsible) filterResponsible.addEventListener('input', applyFilters);
		});

    // Обработчик изменения количества отображаемых заявок
		document.addEventListener('DOMContentLoaded', () => {
		  // initSendKeySettings уже выполнился через IIFE, повторный вызов не нужен
		  autoRefreshTickets();
		  setInterval(autoRefreshTickets, 5000);

		const chat = document.getElementById('historyContent');
		chat.addEventListener('click', async (e) => {
		  const bubble = e.target.closest('.chat-bubble');
		  
		  if (!bubble) return;
		  const tgId = bubble.getAttribute('data-tg-id');
		  const isSupport = bubble.getAttribute('data-sender') === 'support';

		  // Переход к родительскому сообщению (из превью)
			// Клик по блоку превью ответа — плавный скролл к оригиналу
				const rpEl = e.target.closest('.reply-preview.rp-jump');
				if (rpEl) {
				  e.preventDefault();
				  const targetId = rpEl.getAttribute('data-target');
				  if (targetId) {
					const target = document.querySelector(`.chat-bubble[data-tg-id="${CSS.escape(targetId)}"]`);
					if (target) {
					  target.scrollIntoView({ behavior: 'smooth', block: 'center' });
					  target.classList.add('reply-target');
					  setTimeout(() => target.classList.remove('reply-target'), 1500);
					} else {
					  alert('Оригинальное сообщение не найдено в текущей странице истории');
					}
				  }
				  return;
				}

		   // Ответить (жёстко привязываемся к Telegram message_id)
			if (e.target.classList.contains('action-reply')) {
					   const midAttr = bubble.getAttribute('data-mid');   // <= ТОЛЬКО это поле
					   const mid = midAttr ? parseInt(midAttr, 10) : NaN;
					   window.currentReplyToTgId = Number.isFinite(mid) ? mid : null;
					   const ta = document.getElementById('replyTextInHistory');
					   ta.focus();
					   showReplyChip(
						 bubble.querySelector('.msg-text')?.innerText || 'сообщение',
						 window.currentReplyToTgId
					   );
						showReplyPreview(bubble.querySelector('.msg-text')?.textContent || '', window.currentReplyToTgId);
					 }

				  // Редактировать
				  if (e.target.classList.contains('action-edit') && isSupport && tgId) {
					window.currentEditTgId = parseInt(tgId, 10);
					// Подсветим редактируемый пузырь
					document.querySelector('.chat-bubble.editing')?.classList.remove('editing');
					bubble.classList.add('editing');
					window.currentReplyToTgId = null;
					const ta = document.getElementById('replyTextInHistory');
					ta.value = bubble.querySelector('.msg-text')?.innerText || '';
					ta.focus();
					showEditChip();
				  }
					  // Скачать вложение (если есть)
					  if (e.target.classList.contains('action-download')) {
						const link = bubble.querySelector('.media-download');
						if (link) link.click();
					  }

				  // Удалить
				  if (e.target.classList.contains('action-delete') && isSupport && tgId) {
					if (!confirm('Удалить сообщение?')) return;
					const fd = new FormData();
						fd.append('user_id',       String(currentUserId));
						fd.append('ticket_id',     String(currentTicketId));
						fd.append('tg_message_id', String(parseInt(tgId, 10)));

						const resp = await fetch('/message_delete', {
						  method: 'POST',
						  body: fd
						});
					const data = await resp.json();
					if (!data.success) return alert('❌ Не удалось удалить: '+(data.error||''));
					if (data.deleted_on_client) {
					  bubble.insertAdjacentHTML('beforeend', `<div class="badge-meta">удалено у клиента</div>`);
					}
					bubble.classList.add('opacity-50');
					bubble.querySelector('.bubble-actions')?.remove();
				  }
				});

				// «чипы» над textarea
				window.showReplyChip = function showReplyChip(title, targetTgId){
				  setChip(`↩ Ответ на: <a href="#" id="chipJump">«${title.slice(0,60)}…»</a>`, true, targetTgId);
			}
		window.showEditChip = function showEditChip(){
		  setChip(`✏️ Редактирование сообщения`, false, null);
		}
		window.clearChip = function clearChip(){
		  const chip = document.getElementById('composeChip');
		  if (chip) chip.remove();
		  // Снять спец-подсветку с редактируемого пузыря (если осталась)
		  document.querySelector('.chat-bubble.editing')?.classList.remove('editing');
		};
		window.setChip = function setChip(html, isReply, targetTgId){
		  clearChip();
		  const wrap = document.querySelector('.input-group-send');
		  const chip = document.createElement('div');
		  chip.id = 'composeChip';
		  chip.className = 'small text-muted px-2';
		  chip.innerHTML = `${html} <button class="btn btn-link btn-sm p-0">✖</button>`;
		  chip.querySelector('button').onclick = ()=>{
			window.currentReplyToTgId = null;
			window.currentEditTgId = null;
			clearChip();
		  };

		  // клик по ссылке в чипе — перейти к сообщению
		  const jump = chip.querySelector('#chipJump');
		  if (jump && targetTgId) {
			jump.addEventListener('click', (ev)=>{
			  ev.preventDefault();
			  const target = document.querySelector(`.chat-bubble[data-tg-id="${targetTgId}"]`);
			  if (target) {
				target.scrollIntoView({behavior:'smooth', block:'center'});
				target.classList.add('reply-target');
				setTimeout(()=>target.classList.remove('reply-target'), 1200);
			  }
			});
		  }
		  wrap.prepend(chip);
		}
		  
		// Восстанавливаем настройки столбцов
		setTimeout(() => {
		  applyColumnSettingsFromState(); // просто применяем из columnSettings
		  restoreColumnWidths();
		}, 100);
  
		window.addEventListener('beforeunload', saveColumnWidths);
  
		let resizeTimer;
		window.addEventListener('resize', () => {
			clearTimeout(resizeTimer);
			resizeTimer = setTimeout(() => {
				applyColumnSettings();
				initColumnResize();
			}, 250);
		});
	});

	// === Функция принудительного обновления истории ===	
	async function updateHistory() {
		try {
			const qs = new URLSearchParams({
				user_id: String(currentUserId),
				ticket_id: String(currentTicketId),
				_: String(Date.now())
			});
			
			if (window.currentChannelId != null && window.currentChannelId !== '' && window.currentChannelId !== 'null') {
				qs.set('channel_id', String(window.currentChannelId));
			}

			const resp = await fetch(`/history?${qs.toString()}`, { cache: 'no-store' });
			const data = await resp.json();

                        const container = document.getElementById('historyContent');
                        const clientData = window.currentClientData || allTickets.find(
                                t => t.user_id == currentUserId && t.ticket_id == currentTicketId
                        );

                        if (clientData) {
                                window.currentClientData = clientData;
                                updateHistoryClientMeta(clientData, window.currentTicketDetails || {});
                                renderClientTicketsList(currentUserId, currentTicketId);
                        } else {
                                updateHistoryClientMeta({}, window.currentTicketDetails || {});
                                renderClientTicketsList(currentUserId, currentTicketId);
                        }

			// 1) берем массив из ответа
			const msgs = (data.messages || []).slice();

			// 2) стабильная сортировка с тем же алгоритмом, что и в loadHistory
			msgs.sort((a, b) => {
				const ta = sortTsMs(a);
				const tb = sortTsMs(b);
				
				if (ta !== tb) return ta - tb;

				const am = Number(telegramMid(a) || 0);
				const bm = Number(telegramMid(b) || 0);
				if (am !== bm) return am - bm;

				const as = isSupportMsg(a) ? 1 : 0;
				const bs = isSupportMsg(b) ? 1 : 0;
				return as - bs;
			});

			// 3) ВАЖНО: полностью очищаем и перезаполняем renderedMsgIds
			renderedMsgIds.clear();
			msgs.forEach(m => renderedMsgIds.add(msgKey(m)));

			// 4) рендер строго отсортированного массива
			container.innerHTML = renderMessagesHTML(currentTicketId, msgs, clientData);
			parseEmojis(container);

			// 5) обновляем метки и наблюдатели
			if (msgs.length > 0) {
				lastRenderedAt = msgs[msgs.length - 1].timestamp;
			} else {
				lastRenderedAt = null;
			}
			
			setupReadObserver();
			watchUserBubbles();
			recalcTicketUnreadFromDOM(currentTicketId);

		} catch (error) {
			console.error('Ошибка при обновлении истории:', error);
		}
	}


        // Делаем доступной глобально
        window.updateHistory = updateHistory;

        function updateHistoryClientMeta(clientData = {}, ticketDetails = {}) {
                const businessValue = clientData?.business || ticketDetails?.business || '—';
                const locationValue =
                        clientData?.location_name ||
                        clientData?.location ||
                        ticketDetails?.location_name ||
                        '';

                const businessEl = document.getElementById('historyBusiness');
                if (businessEl) {
                        businessEl.textContent = businessValue || '—';
                }

                const headerBusiness = document.getElementById('headerBusiness');
                if (headerBusiness) {
                        headerBusiness.textContent = businessValue || '—';
                }

                const locationLink = document.getElementById('historyLocationLink');
                if (locationLink) {
                        if (locationValue) {
                                locationLink.textContent = locationValue;
                                locationLink.classList.remove('disabled');
                                locationLink.setAttribute('aria-disabled', 'false');
                                locationLink.dataset.location = locationValue;
                                locationLink.setAttribute('tabindex', '0');
                        } else {
                                locationLink.textContent = '—';
                                locationLink.classList.add('disabled');
                                locationLink.setAttribute('aria-disabled', 'true');
                                delete locationLink.dataset.location;
                                locationLink.setAttribute('tabindex', '-1');
                        }
                }

                const headerLocation = document.getElementById('headerLocation');
                if (headerLocation) {
                        headerLocation.textContent = locationValue || '—';
                }
        }

        async function openPassportForLocation(locationName) {
                const normalized = (locationName || '').trim();
                if (!normalized) {
                        return;
                }

                try {
                        const response = await fetch(`/api/object_passports?department=${encodeURIComponent(normalized)}`, {
                                cache: 'no-store'
                        });

                        if (response.status === 404) {
                                alert('Паспорт для этой локации не найден');
                                return;
                        }

                        if (!response.ok) {
                                throw new Error(`Failed to fetch passport: ${response.status}`);
                        }

                        const data = await response.json();
                        const items = Array.isArray(data?.items) ? data.items : [];

                        const match = items.find(item =>
                                String(item?.department || '').trim().toLowerCase() === normalized.toLowerCase()
                        ) || items[0];

                        if (match?.id) {
                                window.location.href = `/object_passports/${match.id}#networkCard`;
                        } else {
                                alert('Паспорт для этой локации не найден');
                        }
                } catch (error) {
                        console.error('Не удалось открыть паспорт для локации', error);
                        alert('Не удалось открыть паспорт. Попробуйте позже.');
                }
        }

        const HISTORY_ERROR_SNIPPET_LIMIT = 200;

        async function fetchJsonWithAuth(url, options = {}) {
                const fetchOptions = { ...options };
                if (!("credentials" in fetchOptions)) {
                        fetchOptions.credentials = 'same-origin';
                }
                const response = await fetch(url, fetchOptions);
                const rawText = await response.text();
                if (!response.ok) {
                        const snippet = rawText ? `: ${rawText.slice(0, HISTORY_ERROR_SNIPPET_LIMIT)}` : '';
                        throw new Error(`Запрос ${url} завершился с ошибкой ${response.status}${snippet}`);
                }
                if (!rawText.trim()) {
                        return null;
                }
                try {
                        return JSON.parse(rawText);
                } catch (parseError) {
                        const snippet = rawText.slice(0, HISTORY_ERROR_SNIPPET_LIMIT);
                        throw new Error(`Ответ ${url} не является валидным JSON: ${parseError.message}. Фрагмент: ${snippet}`);
                }
        }

        // === Загрузить историю ===
        async function loadHistory(user_id, ticket_id) {
                try {
                        await fetch(`/api/tickets/${ticket_id}/active`, {method:'POST', credentials:'same-origin'});
                } catch (e) {}

                try {
                        // Загружаем данные КОНКРЕТНОЙ заявки
                        const [ticketsRaw, ticketFull] = await Promise.all([
                                fetchJsonWithAuth('/tickets_list', { cache: 'no-store' }),
                                fetchJsonWithAuth(`/tickets/${ticket_id}`, { cache: 'no-store' })
                        ]);

                        const ticketsFromServer = normalizeTicketsFromServer(Array.isArray(ticketsRaw) ? ticketsRaw : []);
                        allTickets = ticketsFromServer;

                                const qs = new URLSearchParams({
                                        user_id: String(user_id),
                                        ticket_id: String(ticket_id),
                                        _: String(Date.now())
				});
				
				if (window.currentChannelId && Number(window.currentChannelId) > 0) {
					qs.set('channel_id', Number(window.currentChannelId));
				}

                        const historyData = await fetchJsonWithAuth(`/history?${qs.toString()}`, { cache: 'no-store' }) || {};

                                currentUserId = user_id;
                                currentTicketId = ticket_id;

                                // Ищем данные клиента в полученных тикетах
                                const clientData = ticketsFromServer.find(t => t.user_id == user_id && t.ticket_id == ticket_id);
                                if (clientData && ticketFull) {
                                                if (!clientData.client_name && ticketFull.client_name) clientData.client_name = ticketFull.client_name;
                                                if (!clientData.username && ticketFull.username) clientData.username = ticketFull.username;
                                }
                                window.currentClientData = clientData || {};
                                window.currentTicketDetails = ticketFull || {};
                                window.currentChannelId = clientData?.channel_id ?? null;

                                updateHistoryClientMeta(window.currentClientData, window.currentTicketDetails);
                                await setupResponsibleControl(window.currentTicketDetails);
                                renderClientTicketsList(currentUserId, currentTicketId);

                                const avaEl = document.getElementById('clientAvatarInHistory');
				if (avaEl) {
						const fallbackAvatar = '/static/default-avatar.png';
						const avatarCandidates = [
								clientData?.avatar_full_url,
								clientData?.avatar_url,
								ticketFull?.avatar_full_url,
								ticketFull?.avatar_url,
								clientData?.avatar,
								ticketFull?.avatar,
								`/avatar/${currentUserId}`
						];

						let avatarSrc = '';
						for (const candidate of avatarCandidates) {
								const normalized = normalizeAvatarUrl(candidate);
								if (normalized) { avatarSrc = normalized; break; }
						}
						if (!avatarSrc) avatarSrc = fallbackAvatar;

						let fullSrc = '';
						const fullCandidates = [
								clientData?.avatar_full_url,
								ticketFull?.avatar_full_url,
								avatarSrc === fallbackAvatar ? '' : avatarSrc
						];
						for (const candidate of fullCandidates) {
								const normalized = ensureFullAvatarUrl(candidate);
								if (normalized) { fullSrc = normalized; break; }
						}
						if (!fullSrc) fullSrc = avatarSrc;

						avaEl.src = avatarSrc;
						avaEl.dataset.fullsrc = fullSrc;
						avaEl.alt = 'Аватар клиента';
						avaEl.onerror = () => {
								avaEl.onerror = null;
								avaEl.src = fallbackAvatar;
								avaEl.dataset.fullsrc = fallbackAvatar;
						};
				}

				const messages = historyData.messages || [];
				
				// ВАЖНОЕ ИСПРАВЛЕНИЕ: Полностью очищаем renderedMsgIds перед загрузкой новой истории
				renderedMsgIds.clear();
				
				// Стабильная сортировка с приоритетом временных меток
				const msgs = messages.slice();
				msgs.sort((a, b) => {
					const ta = sortTsMs(a);
					const tb = sortTsMs(b);
					
					// Сначала по времени (основной критерий)
					if (ta !== tb) return ta - tb;
					
					// При одинаковом времени - по ID телеграм сообщения
					const am = Number(telegramMid(a) || 0);
					const bm = Number(telegramMid(b) || 0);
					if (am !== bm) return am - bm;
					
					// При полной ничьей - клиент раньше оператора
					const as = isSupportMsg(a) ? 1 : 0;
					const bs = isSupportMsg(b) ? 1 : 0;
					return as - bs;
				});

				// Заполняем renderedMsgIds ОТСОРТИРОВАННЫМИ сообщениями
				msgs.forEach(m => {
					renderedMsgIds.add(msgKey(m));
				});
				
				// И устанавливаем время последнего просмотра
				lastSeenAt = new Date();

				// Отображаем проблему (ограничение 100ch + полный текст в title)
				const problem = clientData?.problem || 'Не указана';
				const problemEl = document.getElementById('problemText');
				problemEl.textContent = problem;
				problemEl.title = problem;

				// Читаемый статус для правого блока
				const statusText =
					ticketFull.status === 'resolved' ? 'Решено' :
					(ticketFull.status === 'pending' || ticketFull.status === 'in_progress') ? 'В обработке' :
					(ticketFull.status || '—');

				// === ВРЕМЕННЫЕ МЕТРИКИ (СООТВЕТСТВУЮТ ВАШЕЙ ЛОГИКЕ) ===
				// "Создана" — когда заявка попала в список заявок.
				// 1) Пытаемся взять ticket.created_at (от бэка); 2) иначе — первое сообщение клиента.
                                let createdAt = parseDateFromAny(
                                        ticketFull.created_at
                                        || ticketFull.createdAt
                                        || ticketFull.first_user_message_at
                                        || ticketFull.firstUserMessageAt
                                );
                                if (!createdAt) {
                                        const firstUserMsg = messages.find(m => !isSupportMsg(m) && messageDate(m));
                                        createdAt = firstUserMsg ? messageDate(firstUserMsg) : null;
                                }

                                // "Первый ответ оператора" — первое сообщение support
                                let firstReply = parseDateFromAny(
                                        ticketFull.first_support_reply_at
                                        || ticketFull.firstSupportReplyAt
                                );
                                if (!firstReply) {
                                        const firstSupportMsg = messages.find(m => isSupportMsg(m) && messageDate(m));
                                        firstReply = firstSupportMsg ? messageDate(firstSupportMsg) : null;
                                }

                                // "Завершение" — resolved_at от бэка
                                const resolvedAt = parseDateFromAny(ticketFull.resolved_at || ticketFull.resolvedAt);

				// "Время до ответа" — от создания (createdAt) до первого ответа (firstReply)
				const timeToFirstReply = (createdAt && firstReply) ? diffHMin(createdAt, firstReply) : '—';

				// "Общее время" — время работы оператора: от первого ответа до завершения
				const totalWorkTime = (firstReply && resolvedAt) ? diffHMin(firstReply, resolvedAt) : '—';

				// Формируем HTML для блока "Время обращения"
				const info = document.getElementById('timeInfo');
				info.innerHTML = `
					<div id="timeCounter" style="font-size: 1.2em; font-weight: bold; margin-bottom: 8px;"></div>
					<div id="timeDetails" style="font-size: 0.95em; line-height: 1.6;">
						<div><strong>Статус:</strong> ${statusText}</div>
						<div><strong>Создана:</strong> ${formatRuDate(createdAt)}</div>
						<div><strong>Первый ответ оператора:</strong> ${formatRuDate(firstReply)}</div>
						<div><strong>Время до ответа:</strong> ${timeToFirstReply}</div>
						<div><strong>Завершение:</strong> ${formatRuDate(resolvedAt)}</div>
						<div><strong>Общее время:</strong> ${totalWorkTime}</div>
					</div>
				`;
				
				// первичный рендер всей ленты (и оператора, и клиента)
				const container = document.getElementById('historyContent');
				const html = renderMessagesHTML(ticket_id, msgs, clientData);
				window.currentChannelId = clientData?.channel_id ?? null;
				container.innerHTML = html || '<p class="text-muted">Нет сообщений</p>';
				container.scrollTop = container.scrollHeight;
				parseEmojis(container);

				ensureHistoryScrollButtons();

				// Устанавливаем lastRenderedAt на основе ОТСОРТИРОВАННОГО массива
				lastRenderedAt = msgs.length ? msgs[msgs.length - 1].timestamp : null;

				setupReadObserver();
				watchUserBubbles();
				recalcTicketUnreadFromDOM(currentTicketId);

				// Полный текст для ховера на блоке "Время обращения"
				const timeInfo = document.getElementById('timeInfo');
				const tooltipText = [
					`Статус: ${statusText}`,
					`Создана: ${formatRuDate(createdAt)}`,
					`Первый ответ оператора: ${formatRuDate(firstReply)}`,
					`Время до ответа: ${timeToFirstReply}`,
					`Завершение: ${formatRuDate(resolvedAt)}`,
					`Общее время: ${totalWorkTime}`
				].join('\n');
				timeInfo.title = tooltipText;

				// === ЖИВОЙ ТАЙМЕР (только если заявка НЕ закрыта): показываем, сколько прошло с момента "Создана" до сейчас
				if (ticketFull.status !== 'resolved' && createdAt) {
					const timerEl = info.querySelector('#timeCounter');
					const updateTimer = () => {
						const now = new Date();
						timerEl.textContent = diffHMin(createdAt, now);
					};
					updateTimer(); // первый вызов
					if (window.timeUpdateInterval) clearInterval(window.timeUpdateInterval);
					window.timeUpdateInterval = setInterval(updateTimer, 60000);
				} else {
					const timerEl = info.querySelector('#timeCounter');
					if (timerEl) timerEl.textContent = '';
					if (window.timeUpdateInterval) clearInterval(window.timeUpdateInterval);
				}

				// Обновляем состояние кнопки закрытия
				const closeButton = document.getElementById('closeTicketBtn');
				const isResolved = ticketFull.status === 'resolved';
				if (closeButton) {
					if (isResolved) {
						closeButton.disabled = true;
						closeButton.classList.add('disabled');
						closeButton.title = 'Заявка уже закрыта';
					} else {
						closeButton.disabled = false;
						closeButton.classList.remove('disabled');
						closeButton.title = '';
					}
				}

				// Загружаем текущую категорию заявки
				try {
					const respCat = await fetch(`/tickets/${ticket_id}/category`);
					const dataCat = await respCat.json();
					if (dataCat.category) setCategorySelection(dataCat.category);
				} catch (error) {
					console.error("Ошибка загрузки категории:", error);
				}

				// Обновляем заголовок: ID заявки
				document.getElementById('ticketIdDisplay').textContent = ticket_id;

				// Отображение имени клиента и статуса
                                const displayName = clientData?.client_name || clientData?.username || 'Клиент';
                                document.getElementById('clientDisplayName').textContent = displayName;
                                document.getElementById('clientStatusDisplay').textContent = clientData?.client_status || '—';

                                const businessForDialog = clientData?.business || ticketFull?.business || '—';
                                const locationForDialog =
                                        clientData?.location_name ||
                                        clientData?.location ||
                                        ticketFull?.location_name ||
                                        '—';

				// Отображаем проблему (ещё раз — вдруг обновилась)
                                document.getElementById('problemText').textContent = clientData?.problem || 'Не указана';

                                updateHistoryClientMeta(window.currentClientData, window.currentTicketDetails);

                                const normalizedTicketState = ticketFull ? normalizeSingleTicket(ticketFull) : null;
                                const dialogStatusForPool = normalizedTicketState?.status
                                        || clientData?.status
                                        || clientData?.client_status
                                        || ticketFull?.status
                                        || '';
                                const hasSupportParticipant = (historyData.messages || []).some(isSupportMsg);

                                registerActiveDialog({
                                        ticketId: ticket_id,
                                        userId: user_id,
                                        clientName: displayName,
                                        business: businessForDialog || '—',
                                        location: locationForDialog || '—',
                                        status: dialogStatusForPool,
                                        hasSupport: hasSupportParticipant
                                });

                                const inviteBtn = document.getElementById('inviteToDialogBtn');
                                if (inviteBtn) {
                                        inviteBtn.disabled = false;
                                        inviteBtn.dataset.ticketId = String(ticket_id);
                                        inviteBtn.dataset.userId = String(user_id);
                                }

				// Клик по карандашу → редактирование имени
				document.getElementById('editClientBtn').onclick = function () {
					document.getElementById('clientNameInput').value = clientData?.client_name || '';
					document.getElementById('clientUsernameInput').value = clientData?.username || '';
					new bootstrap.Modal(document.getElementById('editClientNameModal')).show();
				};

				// Устанавливаем маркер последнего отрисованного сообщения
				lastRenderedAt = messages.length ? messages[messages.length - 1].timestamp : null;
				
				// обновляем бейдж непрочитанных от клиента после прихода свежих данных
				const lastRead = lastReadAtByTicket[currentTicketId] || 0;
				const unread = (historyData.messages || []).filter(
					m => m.sender === 'user' && new Date(m.timestamp).getTime() > lastRead
				).length;
				setUnread(unread);

				// Показать модальное окно
                                const modal = new bootstrap.Modal(document.getElementById('historyModal'));
                                historyModalIsOpen = true;
                                modal.show();
                                adjustComposerPadding();

                                // после первичного рендера истории:
                                        const chatEl = document.getElementById('historyContent');

				// если оператор доскроллил до низа — обнуляем непрочитанные
				chatEl.addEventListener('scroll', () => {
				  if (isAtBottom(chatEl)) {
					lastSeenAt = new Date();
					lastReadAtByTicket[currentTicketId] = Date.now();
					localStorage.setItem('lastReadAtByTicket', JSON.stringify(lastReadAtByTicket));
					setUnread(0);
					setTicketUnread(currentTicketId, 0);
				  }
				}, { passive: true });

                                document.getElementById('historyModal').addEventListener('hidden.bs.modal', () => {
                                  historyModalIsOpen = false;
                                  currentTicketId = null;
                                  currentUserId = null;
                                  renderActiveDialogs();
                                  const inviteBtnEl = document.getElementById('inviteToDialogBtn');
                                  if (inviteBtnEl) {
                                        inviteBtnEl.disabled = true;
                                        delete inviteBtnEl.dataset.ticketId;
                                        delete inviteBtnEl.dataset.userId;
                                  }
                                  // НЕ сбрасываем счётчики — только останавливаем поллинг
                                  if (window.timeUpdateInterval) {
                                        clearInterval(window.timeUpdateInterval);
                                        window.timeUpdateInterval = null;
                                  }
                                  if (historyPolling) {
                                        clearInterval(historyPolling);
                                        historyPolling = null;
                                  }
                                });

				// === Автообновление истории (инкрементально) ===
				if (historyPolling) clearInterval(historyPolling);
					historyPolling = setInterval(async () => {
					  try {
						const resp = await fetch(`/history?user_id=${currentUserId}&ticket_id=${currentTicketId}&channel_id=${window.currentChannelId ?? ''}&_=${Date.now()}`, { cache: 'no-store' });
						const dataUp = await resp.json();
						const container = document.getElementById('historyContent');
						const msgs = dataUp.messages || [];

						const newOnes = msgs.filter(m => !renderedMsgIds.has(msgKey(m)));
						if (!newOnes.length) return;

						const wasAtBottom = isAtBottom(container);

						const html = renderMessagesHTML(currentTicketId, newOnes, window.currentClientData || null);
						container.insertAdjacentHTML('beforeend', html);
						parseEmojis(container);
						watchUserBubbles();
						recalcTicketUnreadFromDOM(currentTicketId);
						ensureHistoryScrollButtons();

						newOnes.forEach(m => renderedMsgIds.add(msgKey(m)));
						lastRenderedAt = newOnes[newOnes.length - 1].timestamp;

						if (wasAtBottom) {
						  scrollToBottom(container);
						  lastSeenAt = new Date();
						  lastReadAtByTicket[currentTicketId] = Date.now();
						  localStorage.setItem('lastReadAtByTicket', JSON.stringify(lastReadAtByTicket));
						  setUnread(0);
						} else {
						  const inc = newOnes.filter(m => String(m.sender).toLowerCase() === 'user').length;
						  if (inc) setUnread(unreadCount + inc);
						}
					  } catch (e) {
						console.error(e);
					  }
					}, 3000);

                } catch (error) {
                        console.error("Ошибка при загрузке истории:", error);
                        const reason = error && error.message ? `: ${error.message}` : '';
                        alert(`Не удалось загрузить историю заявки${reason}`);
                }
        }
	function _sizeHistoryHeights() {
		  const modal = document.getElementById('historyModal');
		  if (!modal) return;
		  const hdr = modal.querySelector('.modal-header');
		  const ftr = modal.querySelector('.modal-footer');
		  modal.style.setProperty('--hdr-h', (hdr?.offsetHeight || 0) + 'px');
		  modal.style.setProperty('--ftr-h', (ftr?.offsetHeight || 0) + 'px');
		}

                document.getElementById('historyModal').addEventListener('shown.bs.modal', () => {
                  historyModalIsOpen = true;
                  _sizeHistoryHeights();
                  adjustComposerPadding();
                  // пересчитываем при ресайзе и изменении высоты футера (textarea растёт)
                  new ResizeObserver(_sizeHistoryHeights).observe(document.getElementById('historyModal'));
                  window.addEventListener('resize', _sizeHistoryHeights, { passive: true });
                });

                document.addEventListener('click', function (e) {
                  const downloadLink = e.target.closest('.media-download');
                  if (downloadLink) return;
                  const wrap = e.target.closest('.media-wrap[data-media-interactive]');
                  if (!wrap) return;
                  const payload = parseMediaPayload(wrap.dataset.mediaPayload || '');
                  if (!payload) return;
                  e.preventDefault();
                  e.stopPropagation();
                  openMediaViewer(payload);
                });

                // Открытие превью изображения по клику на миниатюру .js-preview
                  document.addEventListener('click', function (e) {
                        const img = e.target.closest('.js-preview');
                        if (!img) return;

			const full = img.getAttribute('data-fullsrc') || img.src;
			const modalEl = document.getElementById('imagePreviewModal');
			document.getElementById('imagePreviewFull').src = full;
			document.getElementById('imageDownloadLink').href = full;

			const bsModal = bootstrap.Modal.getOrCreateInstance(modalEl);
			bsModal.show();
		  });
			// Обработчик события скрытия модального окна
                                document.getElementById('historyModal').addEventListener('hidden.bs.modal', function () {
                                        historyModalIsOpen = false;
                                        currentTicketId = null;
                                        currentUserId = null;
                                        renderActiveDialogs();
                                        const inviteBtnEl = document.getElementById('inviteToDialogBtn');
                                        if (inviteBtnEl) {
                                                inviteBtnEl.disabled = true;
                                                delete inviteBtnEl.dataset.ticketId;
                                                delete inviteBtnEl.dataset.userId;
                                        }
                                        if (window.timeUpdateInterval) {
                                                clearInterval(window.timeUpdateInterval);
                                                window.timeUpdateInterval = null;
                                        }
                                        if (historyPolling) {
                                                clearInterval(historyPolling);
                                                historyPolling = null;
                                        }
                                });

		// === Обновление счетчика времени ===
			function updateTimeCounter(ticketData) {
				if (!ticketData || !ticketData.created_date || !ticketData.created_time) {
					document.getElementById('timeCounter').textContent = 'Данные о времени отсутствуют';
					document.getElementById('timeDetails').textContent = '';
					return;
				}

				try {
					// Создаем дату создания заявки
					const [year, month, day] = ticketData.created_date.split('-');
					const [hours, minutes, seconds] = ticketData.created_time.split(':');
					const createdDate = new Date(year, month - 1, day, hours, minutes, seconds);
		
					const now = new Date();
					const diffMs = now - createdDate;
					const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
					const diffHours = Math.floor((diffMs % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
					const diffMinutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
		
					// Форматируем время
					let timeText = '';
					if (diffDays > 0) timeText += `${diffDays}д `;
					if (diffHours > 0) timeText += `${diffHours}ч `;
					timeText += `${diffMinutes}м`;
		
					document.getElementById('timeCounter').textContent = timeText;
		
					// Детальная информация
					const createdFormatted = createdDate.toLocaleString('ru-RU');
					const nowFormatted = now.toLocaleString('ru-RU');
					document.getElementById('timeDetails').innerHTML = `
					Создана: ${createdFormatted}<br>
					Текущее время: ${nowFormatted}
					`;
		
				} catch (error) {
					console.error("Ошибка расчета времени:", error);
					document.getElementById('timeCounter').textContent = 'Ошибка расчета';
					document.getElementById('timeDetails').textContent = '';
				}
			}
	// Функция для создания правильного URL медиафайла
		// Функция для создания правильного URL медиафайла
	function getMediaUrl(ticket_id, filename) {
		// Убираем путь из filename, если он есть
		const cleanFilename = filename.split('/').pop();
		return `/media/${ticket_id}/${cleanFilename}`;
	}

	// Функция для создания HTML медиафайла с улучшенным отображением (добавлены animation и sticker)
        function createMediaHtml(ticket_id, mediaInfo) {
          const { message_type, attachment, text } = mediaInfo;
          const filename = (attachment || '').split('/').pop();
          const mediaUrl = getMediaUrl(ticket_id, filename);
          const ext = (filename?.split('.').pop() || '').toLowerCase();
          const safeFilename = filename ? escapeHtml(String(filename)) : '';
          const normalizedType = (message_type || '').toLowerCase();
          const videoExtensions = new Set(['mp4', 'm4v', 'mov', 'webm', 'mkv', 'avi']);
          const isVideoExtension = videoExtensions.has(ext);
          const effectiveType = normalizedType === 'document' && isVideoExtension
            ? 'video'
            : (normalizedType || (isVideoExtension ? 'video' : ''));
          const isVideo = effectiveType === 'video' || isVideoExtension;
          const typeLabelMap = {
            photo: '🖼 ФОТО',
            video: '🎥 ВИДЕО',
            animation: '🎞 АНИМАЦИЯ',
            sticker: '🧩 СТИКЕР',
            document: '📄 ДОКУМЕНТ',
            voice: '🎤 ГОЛОСОВОЕ'
          };
          const typeLabel = typeLabelMap[isVideo ? 'video' : effectiveType] || '📎 МЕДИА';
          const safeCaption = text ? escapeHtml(String(text)) : '';
          const basePayload = {
            url: mediaUrl,
            type: isVideo ? 'video' : (effectiveType || message_type || 'attachment'),
            caption: text || '',
            filename: filename || '',
            extension: ext
          };

          const wrap = (inner, options = {}) => {
            const payloadObj = { ...basePayload, ...(options.payload || {}) };
            const encodedPayload = encodeURIComponent(JSON.stringify(payloadObj));
            const interactiveAttr = options.interactive ? ' data-media-interactive="1"' : '';
            return `
              <div class="mt-2 media-wrap"${interactiveAttr} data-media-payload="${encodedPayload}">
                <a class="media-download" href="${mediaUrl}" download title="Скачать оригинал">⤓</a>
                ${inner}
                <div class="media-type mt-1">${typeLabel}</div>
                ${safeCaption ? `<div class="media-caption mt-1">${safeCaption}</div>` : ''}
              </div>
            `;
          };

          if (effectiveType === 'photo') {
            return wrap(`
              <img src="${mediaUrl}"
                   data-fullsrc="${mediaUrl}"
                   loading="lazy" decoding="async"
                   class="img-thumbnail js-preview"
                   style="max-width: 100%; max-height: 400px; border-radius: 8px; cursor: zoom-in;"
                   alt="Фото">
            `);
          }

          if (isVideo) {
            return wrap(`
              <video controls
                     class="img-thumbnail"
                     style="max-width: 100%; max-height: 300px; border-radius: 8px;">
                <source src="${mediaUrl}">
                Ваш браузер не поддерживает видео.
              </video>
            `, { interactive: true, payload: { type: 'video' } });
          }

          if (effectiveType === 'animation') {
            return wrap(`
              <video autoplay loop muted playsinline controls
                     class="img-thumbnail"
                     style="max-width: 100%; max-height: 320px; border-radius: 8px;">
                <source src="${mediaUrl}">
                Ваш браузер не поддерживает видео.
              </video>
            `);
          }

          if (effectiveType === 'sticker') {
            if (ext === 'webp') {
              return wrap(`<img src="${mediaUrl}" alt="Стикер" style="max-width:160px; height:auto;">`);
            }
            if (ext === 'webm') {
              return wrap(`
                <video autoplay loop muted playsinline style="max-width:160px; border-radius:8px;">
                  <source src="${mediaUrl}">
                </video>
              `);
            }
            return wrap(`
              <div class="d-flex align-items-center gap-2">
                <span class="fs-5">🧩</span>
                <span class="small text-muted">${safeFilename || 'Стикер'}</span>
              </div>
            `, { interactive: true, payload: { type: 'sticker' } });
          }

          if (effectiveType === 'document') {
            return wrap(`
              <div class="d-flex align-items-center gap-2">
                <span class="fs-5">📄</span>
                <span class="small text-muted">${safeFilename || 'Документ'}</span>
              </div>
            `, { interactive: true, payload: { type: 'document' } });
          }

          if (message_type === 'voice') {
            return wrap(`
              <audio controls style="width: 100%;" class="mb-1">
                <source src="${mediaUrl}">
                Ваш браузер не поддерживает аудио.
              </audio>
            `);
          }

          if (attachment) {
            return wrap(`
              <div class="d-flex align-items-center gap-2">
                <span class="fs-5">📎</span>
                <span class="small text-muted">${safeFilename || '[медиа]'}</span>
              </div>
            `, { interactive: true, payload: { type: message_type || 'attachment' } });
          }
          return '';
        }


        // === ХЕЛПЕРЫ ДЛЯ ФОРМАТИРОВАНИЯ ДАТ И РАЗНИЦ ===
        function parseDateFromAny(value) {
                if (!value) return null;
                const iso = normalizeToISO(value);
                const d = new Date(iso);
                return isNaN(d) ? null : d;
        }

        function messageDate(msg) {
                if (!msg) return null;
                return parseDateFromAny(msg.timestamp ?? msg.date ?? msg.created_at ?? msg.createdAt ?? null);
        }

        function formatRuDate(d) {
                if (!(d instanceof Date) || isNaN(d)) return '—';
		const dd = String(d.getDate()).padStart(2,'0');
		const mm = String(d.getMonth()+1).padStart(2,'0');
		const yyyy = d.getFullYear();
		const hh = String(d.getHours()).padStart(2,'0');
		const mi = String(d.getMinutes()).padStart(2,'0');
		const ss = String(d.getSeconds()).padStart(2,'0');
		return `${dd}.${mm}.${yyyy}, ${hh}:${mi}:${ss}`;
	}

	function diffHMin(from, to) {
		if (!(from instanceof Date) || isNaN(from) || !(to instanceof Date) || isNaN(to)) return '—';
		const mins = Math.max(0, Math.round((to - from) / 60000));
		const h = Math.floor(mins / 60);
		const m = mins % 60;
		return `${h} ч ${m} мин`;
	}

	function safeParseISO(s) {
		if (!s) return null;
		const d = new Date(s);
		return isNaN(d) ? null : d;
	}
		
        const CATEGORY_COLOR_PALETTE = [
          '#0d6efd', '#6610f2', '#6f42c1', '#d63384', '#dc3545',
          '#fd7e14', '#20c997', '#198754', '#0dcaf0', '#343a40'
        ];

        function categoryColor(name = '') {
          if (!name) return CATEGORY_COLOR_PALETTE[0];
          let hash = 0;
          for (let i = 0; i < name.length; i++) {
            hash = (hash << 5) - hash + name.charCodeAt(i);
            hash |= 0;
          }
          const index = Math.abs(hash) % CATEGORY_COLOR_PALETTE.length;
          return CATEGORY_COLOR_PALETTE[index];
        }

        function renderCategoryBadges(container, categories, label = 'Выбрано:') {
          if (!container) return;
          if (!Array.isArray(categories) || categories.length === 0) {
            container.innerHTML = '';
            container.removeAttribute('title');
            container.classList.remove('has-categories');
            return;
          }

          const chips = categories.map(cat => {
            const rawCat = String(cat || '');
            const safeCat = escapeHtml(rawCat);
            const color = categoryColor(rawCat);
            return `<span class="category-chip" style="--chip-color:${color}">${safeCat}</span>`;
          }).join('');

          const labelHtml = label ? `<span class="selected-label text-muted me-2">${label}</span>` : '';
          container.innerHTML = `${labelHtml}${chips}`;
          container.title = categories.join(', ');
          container.classList.add('has-categories');
        }

        function normalizeCategoryTemplates(rawTemplates, fallbackCategories) {
          const result = [];
          const source = Array.isArray(rawTemplates) ? rawTemplates : [];
          const used = new Set();
          source.forEach((item, index) => {
            if (!item || typeof item !== 'object') return;
            let id = typeof item.id === 'string' && item.id.trim() ? item.id.trim() : `cat-${index}`;
            while (used.has(id)) {
              id = `cat-${index}-${Math.random().toString(36).slice(2, 6)}`;
            }
            used.add(id);
            const name = typeof item.name === 'string' && item.name.trim() ? item.name.trim() : `Шаблон ${index + 1}`;
            const categories = Array.isArray(item.categories)
              ? item.categories.map((cat) => String(cat || '').trim()).filter(Boolean)
              : [];
            result.push({ id, name, categories });
          });

          if (!result.length) {
            const fallback = Array.isArray(fallbackCategories)
              ? fallbackCategories.map((cat) => String(cat || '').trim()).filter(Boolean)
              : [];
            result.push({ id: 'cat-default', name: 'Общий шаблон', categories: fallback });
          }

          return result;
        }

        function normalizeQuestionTemplates(rawTemplates) {
          const result = [];
          const source = Array.isArray(rawTemplates) ? rawTemplates : [];
          const used = new Set();
          source.forEach((item, index) => {
            if (!item || typeof item !== 'object') return;
            let id = typeof item.id === 'string' && item.id.trim() ? item.id.trim() : `q-${index}`;
            while (used.has(id)) {
              id = `q-${index}-${Math.random().toString(36).slice(2, 6)}`;
            }
            used.add(id);
            const name = typeof item.name === 'string' && item.name.trim() ? item.name.trim() : `Шаблон вопросов ${index + 1}`;
            const questions = Array.isArray(item.questions)
              ? item.questions.map((question) => String(question || '').trim()).filter(Boolean)
              : [];
            result.push({ id, name, questions });
          });
          return result;
        }

        function normalizeCompletionTemplates(rawTemplates) {
          const result = [];
          const source = Array.isArray(rawTemplates) ? rawTemplates : [];
          const used = new Set();
          source.forEach((item, index) => {
            if (!item || typeof item !== 'object') return;
            let id = typeof item.id === 'string' && item.id.trim() ? item.id.trim() : `act-${index}`;
            while (used.has(id)) {
              id = `act-${index}-${Math.random().toString(36).slice(2, 6)}`;
            }
            used.add(id);
            const name = typeof item.name === 'string' && item.name.trim() ? item.name.trim() : `Шаблон действий ${index + 1}`;
            const items = Array.isArray(item.items)
              ? item.items.map((entry) => {
                  if (!entry || typeof entry !== 'object') return null;
                  const question = String(entry.question || '').trim();
                  const action = String(entry.action || '').trim();
                  if (!question && !action) return null;
                  return { question, action };
                }).filter(Boolean)
              : [];
            result.push({ id, name, items });
          });
          return result;
        }

        const rawDialogConfig = window.settings && typeof window.settings === 'object' ? window.settings.dialogConfig : {};
        const CATEGORY_TEMPLATES = normalizeCategoryTemplates(
          rawDialogConfig && rawDialogConfig.category_templates,
          window.settings && window.settings.categories
        );
        const QUESTION_TEMPLATES = normalizeQuestionTemplates(
          rawDialogConfig && rawDialogConfig.question_templates
        );
        const COMPLETION_TEMPLATES = normalizeCompletionTemplates(
          rawDialogConfig && rawDialogConfig.completion_templates
        );

        let activeCategoryTemplateId = CATEGORY_TEMPLATES.length ? CATEGORY_TEMPLATES[0].id : null;
        let activeQuestionTemplateId = QUESTION_TEMPLATES.length ? QUESTION_TEMPLATES[0].id : '';
        let activeCompletionTemplateId = COMPLETION_TEMPLATES.length ? COMPLETION_TEMPLATES[0].id : '';

        function getCategoryTemplateById(id) {
          return CATEGORY_TEMPLATES.find((template) => template.id === id) || null;
        }

        function getQuestionTemplateById(id) {
          return QUESTION_TEMPLATES.find((template) => template.id === id) || null;
        }

        function getCompletionTemplateById(id) {
          return COMPLETION_TEMPLATES.find((template) => template.id === id) || null;
        }

        function populateCategoryTemplateSelectors() {
          const historySelect = document.getElementById('categoryTemplateSelect');
          const closeSelect = document.getElementById('closeCategoryTemplateSelect');
          const fragmentHistory = document.createDocumentFragment();
          const fragmentClose = document.createDocumentFragment();

          CATEGORY_TEMPLATES.forEach((template) => {
            const optionHistory = document.createElement('option');
            optionHistory.value = template.id;
            optionHistory.textContent = template.name;
            fragmentHistory.appendChild(optionHistory);

            const optionClose = document.createElement('option');
            optionClose.value = template.id;
            optionClose.textContent = template.name;
            fragmentClose.appendChild(optionClose);
          });

          if (historySelect) {
            historySelect.innerHTML = '';
            if (fragmentHistory.childNodes.length) {
              historySelect.appendChild(fragmentHistory);
              const hasActive = CATEGORY_TEMPLATES.some((template) => template.id === activeCategoryTemplateId);
              const defaultId = hasActive ? activeCategoryTemplateId : (CATEGORY_TEMPLATES[0] ? CATEGORY_TEMPLATES[0].id : '');
              activeCategoryTemplateId = defaultId || null;
              historySelect.value = defaultId;
            } else {
              const option = document.createElement('option');
              option.value = '';
              option.textContent = 'Нет шаблонов';
              historySelect.appendChild(option);
              historySelect.value = '';
            }
          }

          if (closeSelect) {
            closeSelect.innerHTML = '';
            if (fragmentClose.childNodes.length) {
              closeSelect.appendChild(fragmentClose);
              closeSelect.value = activeCategoryTemplateId || '';
            } else {
              const option = document.createElement('option');
              option.value = '';
              option.textContent = 'Нет шаблонов';
              closeSelect.appendChild(option);
              closeSelect.value = '';
            }
          }
        }

        function buildCategoryOptionsForContext(selectId, listId, checkboxClass, idPrefix, categories) {
          const select = document.getElementById(selectId);
          const list = document.getElementById(listId);

          if (select) {
            select.innerHTML = '';
          }
          if (list) {
            list.innerHTML = '';
          }

          if (!Array.isArray(categories) || !categories.length) {
            if (list) {
              const empty = document.createElement('li');
              empty.className = 'dropdown-item text-muted';
              empty.textContent = 'Нет категорий в шаблоне';
              list.appendChild(empty);
            }
            return;
          }

          categories.forEach((category, index) => {
            const value = String(category || '').trim();
            if (!value) return;
            if (select) {
              const option = document.createElement('option');
              option.value = value;
              option.textContent = value;
              select.appendChild(option);
            }
            if (list) {
              const li = document.createElement('li');
              const inputId = `${idPrefix}${index}`;
              li.innerHTML = `
                <div class="form-check dropdown-item">
                  <input class="form-check-input ${checkboxClass}" type="checkbox" value="${escapeHtml(value)}" id="${inputId}">
                  <label class="form-check-label w-100" for="${inputId}">${escapeHtml(value)}</label>
                </div>
              `;
              list.appendChild(li);
            }
          });
        }

        function refreshCategoryControls(options) {
          const template = getCategoryTemplateById(activeCategoryTemplateId);
          const categories = template ? template.categories : [];
          const preservedHistory = new Set(
            (options && options.historySelected) ||
              Array.from(document.querySelectorAll('.category-checkbox:checked')).map((checkbox) => checkbox.value)
          );
          const preservedClose = new Set(
            (options && options.closeSelected) ||
              Array.from(document.querySelectorAll('.close-category-checkbox:checked')).map((checkbox) => checkbox.value)
          );

          buildCategoryOptionsForContext('ticketCategorySelect', 'categoryOptionsList', 'category-checkbox', 'cat', categories);
          buildCategoryOptionsForContext('closeCategorySelect', 'closeCategoryOptionsList', 'close-category-checkbox', 'closeCat', categories);

          document.querySelectorAll('.category-checkbox').forEach((checkbox) => {
            checkbox.checked = preservedHistory.has(checkbox.value);
          });
          document.querySelectorAll('.close-category-checkbox').forEach((checkbox) => {
            checkbox.checked = preservedClose.has(checkbox.value);
          });

          syncCategorySelection();
          syncCloseCategorySelection();
        }

        function setActiveCategoryTemplate(templateId, options) {
          if (!templateId) return;
          if (templateId === activeCategoryTemplateId && !(options && options.force)) {
            return;
          }
          activeCategoryTemplateId = templateId;
          const historySelect = document.getElementById('categoryTemplateSelect');
          if (historySelect) {
            historySelect.value = templateId;
          }
          const closeSelect = document.getElementById('closeCategoryTemplateSelect');
          if (closeSelect) {
            closeSelect.value = templateId;
          }
          refreshCategoryControls(options);
        }

        function injectCategoryOption(value) {
          const category = String(value || '').trim();
          if (!category) return;

          const historySelect = document.getElementById('ticketCategorySelect');
          if (historySelect && !Array.from(historySelect.options).some((option) => option.value === category)) {
            const option = document.createElement('option');
            option.value = category;
            option.textContent = category;
            historySelect.appendChild(option);
          }

          const closeSelect = document.getElementById('closeCategorySelect');
          if (closeSelect && !Array.from(closeSelect.options).some((option) => option.value === category)) {
            const option = document.createElement('option');
            option.value = category;
            option.textContent = category;
            closeSelect.appendChild(option);
          }

          const historyList = document.getElementById('categoryOptionsList');
          if (historyList && !Array.from(historyList.querySelectorAll('.category-checkbox')).some((checkbox) => checkbox.value === category)) {
            const li = document.createElement('li');
            const inputId = `catCustom-${Math.random().toString(36).slice(2, 7)}`;
            li.innerHTML = `
              <div class="form-check dropdown-item">
                <input class="form-check-input category-checkbox" type="checkbox" value="${escapeHtml(category)}" id="${inputId}">
                <label class="form-check-label w-100" for="${inputId}">${escapeHtml(category)}</label>
              </div>
            `;
            historyList.appendChild(li);
          }

          const closeList = document.getElementById('closeCategoryOptionsList');
          if (closeList && !Array.from(closeList.querySelectorAll('.close-category-checkbox')).some((checkbox) => checkbox.value === category)) {
            const inputId = `closeCatCustom-${Math.random().toString(36).slice(2, 7)}`;
            const li = document.createElement('li');
            li.innerHTML = `
              <div class="form-check dropdown-item">
                <input class="form-check-input close-category-checkbox" type="checkbox" value="${escapeHtml(category)}" id="${inputId}">
                <label class="form-check-label w-100" for="${inputId}">${escapeHtml(category)}</label>
              </div>
            `;
            closeList.appendChild(li);
          }
        }

        function initializeCategoryTemplatesUI() {
          populateCategoryTemplateSelectors();
          refreshCategoryControls({ historySelected: [], closeSelected: [] });

          const historySelect = document.getElementById('categoryTemplateSelect');
          if (historySelect) {
            historySelect.addEventListener('change', (event) => {
              setActiveCategoryTemplate(event.target.value, { historySelected: [], closeSelected: [] });
            });
          }

          const closeSelect = document.getElementById('closeCategoryTemplateSelect');
          if (closeSelect) {
            closeSelect.addEventListener('change', (event) => {
              setActiveCategoryTemplate(event.target.value, { historySelected: [], closeSelected: [] });
            });
          }

          document.addEventListener('change', (event) => {
            const target = event.target;
            if (!(target instanceof HTMLElement)) return;
            if (target.classList.contains('category-checkbox')) {
              syncCategorySelection();
            }
            if (target.classList.contains('close-category-checkbox')) {
              syncCloseCategorySelection();
            }
          });
        }

        function setActiveQuestionTemplate(templateId) {
          activeQuestionTemplateId = templateId || '';
          renderQuestionTemplateQuestions(activeQuestionTemplateId);
        }

        function renderQuestionTemplateSelect() {
          const select = document.getElementById('questionTemplateSelect');
          const applyBtn = document.getElementById('applyQuestionTemplateBtn');
          if (!select) return;

          select.innerHTML = '';
          if (!QUESTION_TEMPLATES.length) {
            const option = document.createElement('option');
            option.value = '';
            option.textContent = 'Нет шаблонов';
            select.appendChild(option);
            select.value = '';
            select.disabled = true;
            if (applyBtn) applyBtn.setAttribute('disabled', 'disabled');
            renderQuestionTemplateQuestions('');
            return;
          }

          select.disabled = false;
          QUESTION_TEMPLATES.forEach((template) => {
            const option = document.createElement('option');
            option.value = template.id;
            option.textContent = template.name;
            select.appendChild(option);
          });

          const defaultId = activeQuestionTemplateId && QUESTION_TEMPLATES.some((tpl) => tpl.id === activeQuestionTemplateId)
            ? activeQuestionTemplateId
            : QUESTION_TEMPLATES[0].id;
          select.value = defaultId;
          activeQuestionTemplateId = defaultId;
          if (applyBtn) applyBtn.removeAttribute('disabled');
          renderQuestionTemplateQuestions(activeQuestionTemplateId);
        }

        function renderQuestionTemplateQuestions(templateId) {
          const container = document.getElementById('questionTemplateQuestions');
          if (!container) return;

          container.innerHTML = '';
          const template = getQuestionTemplateById(templateId);
          if (!template || !template.questions.length) {
            const empty = document.createElement('span');
            empty.className = 'text-muted small';
            empty.textContent = template ? 'В этом шаблоне нет вопросов.' : 'Нет типовых вопросов.';
            container.appendChild(empty);
            return;
          }

          template.questions.forEach((question) => {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'btn btn-light btn-sm';
            btn.textContent = question;
            btn.addEventListener('click', () => {
              appendTextToReply(question);
            });
            container.appendChild(btn);
          });
        }

        function appendTextToReply(text) {
          const textarea = document.getElementById('replyTextInHistory');
          if (!textarea || !text) return;
          const current = textarea.value || '';
          const separator = current && !current.endsWith('\n') ? '\n' : '';
          textarea.value = current + separator + text;
          textarea.focus();
        }

        function initializeQuestionTemplatesUI() {
          renderQuestionTemplateSelect();
          const select = document.getElementById('questionTemplateSelect');
          if (select) {
            select.addEventListener('change', (event) => {
              setActiveQuestionTemplate(event.target.value);
            });
          }
          const applyBtn = document.getElementById('applyQuestionTemplateBtn');
          if (applyBtn) {
            applyBtn.addEventListener('click', () => {
              const template = getQuestionTemplateById(activeQuestionTemplateId);
              if (!template || !template.questions.length) return;
              appendTextToReply(template.questions.join('\n'));
            });
          }
        }

        function renderCompletionTemplateOptions() {
          const select = document.getElementById('completionTemplateSelect');
          if (!select) return;
          select.innerHTML = '';

          if (!COMPLETION_TEMPLATES.length) {
            const option = document.createElement('option');
            option.value = '';
            option.textContent = 'Нет шаблонов';
            select.appendChild(option);
            select.value = '';
            select.disabled = true;
            renderCompletionTemplateDetails('');
            return;
          }

          select.disabled = false;
          COMPLETION_TEMPLATES.forEach((template) => {
            const option = document.createElement('option');
            option.value = template.id;
            option.textContent = template.name;
            select.appendChild(option);
          });

          const defaultId = activeCompletionTemplateId && COMPLETION_TEMPLATES.some((tpl) => tpl.id === activeCompletionTemplateId)
            ? activeCompletionTemplateId
            : COMPLETION_TEMPLATES[0].id;
          select.value = defaultId;
          activeCompletionTemplateId = defaultId;
          renderCompletionTemplateDetails(activeCompletionTemplateId);
        }

        function renderCompletionTemplateDetails(templateId) {
          const container = document.getElementById('completionTemplateDetails');
          if (!container) return;
          container.innerHTML = '';
          const template = getCompletionTemplateById(templateId);
          if (!template) {
            container.textContent = 'Шаблон не выбран.';
            return;
          }
          if (!template.items.length) {
            container.textContent = 'В этом шаблоне нет действий.';
            return;
          }
          const list = document.createElement('ol');
          list.className = 'ps-3 mb-0';
          template.items.forEach((item) => {
            const li = document.createElement('li');
            const question = item.question ? `<strong>${escapeHtml(item.question)}</strong>` : '';
            const action = item.action ? `<div class="text-muted">${escapeHtml(item.action)}</div>` : '';
            li.innerHTML = `${question}${action}`;
            list.appendChild(li);
          });
          container.appendChild(list);
        }

        function setActiveCompletionTemplate(templateId) {
          activeCompletionTemplateId = templateId || '';
          renderCompletionTemplateDetails(activeCompletionTemplateId);
        }

        function initializeCompletionTemplatesUI() {
          renderCompletionTemplateOptions();
          const select = document.getElementById('completionTemplateSelect');
          if (select) {
            select.addEventListener('change', (event) => {
              setActiveCompletionTemplate(event.target.value);
            });
          }
        }

        document.addEventListener('DOMContentLoaded', () => {
          initializeCategoryTemplatesUI();
          initializeQuestionTemplatesUI();
          initializeCompletionTemplatesUI();
        });

// === Синхронизация категорий из истории в окно закрытия ===
                function syncCloseCategoriesFromHistory() {
                        // Получаем выбранные категории из истории
                                const historyCheckboxes = document.querySelectorAll('.category-checkbox:checked');
                                const selectedValues = Array.from(historyCheckboxes).map(cb => cb.value);

                        const closeTemplateSelect = document.getElementById('closeCategoryTemplateSelect');
                        if (closeTemplateSelect && activeCategoryTemplateId) {
                                closeTemplateSelect.value = activeCategoryTemplateId;
                        }

                        // Устанавливаем те же категории в окне закрытия
                                document.querySelectorAll('.close-category-checkbox').forEach(checkbox => {
                                        checkbox.checked = selectedValues.includes(checkbox.value);
                                });
	  
			// Обновляем отображение выбранных категорий
				syncCloseCategorySelection();
		}

		// === Синхронизация выбора категорий в модальном окне закрытия ===
		function syncCloseCategorySelection() {
			const checkboxes = document.querySelectorAll('.close-category-checkbox:checked');
			const select = document.getElementById('closeCategorySelect');
			const selectedContainer = document.getElementById('closeSelectedCategories');
	  
			// Очищаем текущий выбор
				Array.from(select.options).forEach(option => {
					option.selected = false;
				});
	  
			// Обновляем выбранные элементы
				const selectedValues = [];
				checkboxes.forEach(checkbox => {
					const value = checkbox.value;
					const option = Array.from(select.options).find(opt => opt.value === value);
					if (option) {
						option.selected = true;
						selectedValues.push(value);
					}
				});
	  
			// Обновляем отображение выбранных категорий
                                renderCategoryBadges(selectedContainer, selectedValues);
                                const closeDropdown = document.getElementById('closeCategoryDropdown');
                                if (closeDropdown) {
                                        closeDropdown.textContent = selectedValues.length > 0
                                          ? `Выбрано: ${selectedValues.length} категорий`
                                          : 'Выберите категории...';
                                }
	  
			return selectedValues;
		}

		// === Синхронизация категорий из истории (для основного select) ===
		function syncCategorySelection() {
			const checkboxes = document.querySelectorAll('.category-checkbox:checked');
			const select = document.getElementById('ticketCategorySelect');
			const selectedContainer = document.getElementById('selectedCategories');
	  
			// Очищаем текущий выбор
				Array.from(select.options).forEach(option => {
					option.selected = false;
				});
	  
			// Обновляем выбранные элементы
				const selectedValues = [];
				checkboxes.forEach(checkbox => {
					const value = checkbox.value;
					const option = Array.from(select.options).find(opt => opt.value === value);
					if (option) {
						option.selected = true;
						selectedValues.push(value);
					}
				});
	  
			// Обновляем отображение выбранных категорий
                                renderCategoryBadges(selectedContainer, selectedValues);
                                const historyDropdown = document.getElementById('categoryDropdown');
                                if (historyDropdown) {
                                        historyDropdown.textContent = selectedValues.length > 0
                                          ? `Выбрано: ${selectedValues.length} категорий`
                                          : 'Выберите категории...';
                                }
	  
			return selectedValues;
		}

		// === Установка выбранных категорий ===
                function setCategorySelection(categories) {
                        if (!categories) return;

                        const categoryArray = Array.isArray(categories) ? categories : categories.split(',').map(cat => cat.trim());

                        document.querySelectorAll('.category-checkbox').forEach(checkbox => {
                                checkbox.checked = false;
                        });
                        document.querySelectorAll('.close-category-checkbox').forEach(checkbox => {
                                checkbox.checked = false;
                        });

                        categoryArray.forEach(cat => {
                                if (!cat) return;
                                injectCategoryOption(cat);
                        });

                        document.querySelectorAll('.category-checkbox').forEach(checkbox => {
                                checkbox.checked = categoryArray.includes(checkbox.value);
                        });
                        document.querySelectorAll('.close-category-checkbox').forEach(checkbox => {
                                checkbox.checked = categoryArray.includes(checkbox.value);
                        });

                        syncCategorySelection();
                        syncCloseCategorySelection();
                }

		// === Загрузка текучной категории заявки ===
		async function loadTicketCategory(ticket_id) {
			try {
                                const response = await fetch('/tickets_list');
                                const tickets = normalizeTicketsFromServer(await response.json());
				const ticket = tickets.find(t => t.ticket_id == ticket_id);
		
				if (ticket && ticket.category) {
					const categories = ticket.category.split(',').map(cat => cat.trim());
					const select = document.getElementById('ticketCategorySelect');
		  
					// Снимаем все выделения
					Array.from(select.options).forEach(option => {
						option.selected = categories.includes(option.value);
					});
				}
			}
			catch (error) {
				console.error("Ошибка загрузки категории:", error);
			}
		}

		// === Сохранение категории заявки ===
		async function saveTicketCategory() {
			// Получаем выбранные чекбоксы
			const checkboxes = document.querySelectorAll('.category-checkbox:checked');
			const selectedCategories = Array.from(checkboxes).map(checkbox => checkbox.value);
	  
			if (selectedCategories.length === 0) {
				alert('Выберите хотя бы одну категорию');
				return;
			}

			try {
				const response = await fetch('/update_ticket_category', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({
						ticket_id: currentTicketId,
						category: selectedCategories.join(', ')
					})
				});

				const data = await response.json();
				if (data.success) {
					alert('✅ Категория обновлена');
				} 
				else {
					alert('❌ Ошибка: ' + data.error);
				}
			} 
			catch (error) {
				console.error('Ошибка сохранения категории:', error);
				alert('❌ Ошибка при сохранении категории');
			}
		}

		// === Обработка Enter/Ctrl+Enter ===
		document.getElementById('replyTextInHistory').addEventListener('keydown', function (e) {
		  const mode = localStorage.getItem('sendKeySetting') || 'enter';

			if (e.key === 'Enter') {
				if (mode === 'enter' && !e.shiftKey && !e.ctrlKey) {
					e.preventDefault();
					document.getElementById('sendReplyInHistory').click();
				} 
				else if (mode === 'ctrlEnter' && (e.ctrlKey || e.metaKey)) {
					e.preventDefault();
					document.getElementById('sendReplyInHistory').click();
				} 
				else if (mode === 'enterNewline' && (e.ctrlKey || e.metaKey)) {
					e.preventDefault();
					document.getElementById('sendReplyInHistory').click();
				}
			}
		});

	// === Отправить ответ из истории ===
	const sendReplyInHistoryBtn = document.getElementById('sendReplyInHistory');
	if (sendReplyInHistoryBtn) {
	  sendReplyInHistoryBtn.onclick = async function () {
		const ta = document.getElementById('replyTextInHistory');
		const text = ta.value.trim();
		if (!text) return;
		const admin = getOperatorName();
		const container = document.getElementById('historyContent');
		const wasAtBottom = isAtBottom(container);
		this.disabled = true;
		// === ДИАГНОСТИКА ПЕРЕД ОТПРАВКОЙ ===
		console.log('=== ДИАГНОСТИКА ПЕРЕД ОТПРАВКОЙ СООБЩЕНИЯ ===');
		console.log('Текущий ticket_id:', currentTicketId);
		console.log('Текущий user_id:', currentUserId);
		
		const currentTicket = window.allTickets?.find(t => String(t.ticket_id) === String(currentTicketId));
		if (currentTicket) {
		  console.log('Текущий статус заявки:', currentTicket.status);
		  console.log('Raw статус:', currentTicket.raw_status);
		  console.log('Дата создания:', currentTicket.created_date);
		  console.log('Время создания:', currentTicket.created_time);
		} else {
		  console.log('Заявка не найдена в allTickets');
		}
		console.log('==============================');
		try {
		  let resp, data;
		  if (window.currentEditTgId) {
			// Редактирование
			const fd = new FormData();
			fd.append('user_id', String(currentUserId));
			fd.append('ticket_id', String(currentTicketId));
			fd.append('tg_message_id', String(window.currentEditTgId));
			fd.append('text', text);
			resp = await fetch('/message_edit', { method: 'POST', body: fd });
			data = await resp.json();
			if (!data.success) throw new Error(data.error || 'Ошибка редактирования');
			window.currentEditTgId = null;
			if (window.clearChip) window.clearChip();
		  } else {
			// Обычная отправка
                        resp = await fetch('/reply', {
                          method: 'POST',
                          headers: { 'Content-Type': 'application/json' },
                          body: JSON.stringify({
                                user_id: currentUserId,
                                text,
                                admin,
                                ticket_id: currentTicketId,
                                reply_to_tg_id: (window.currentReplyToTgId || null)
                          })
                        });
                        data = await resp.json();
                                if (!data.success) throw new Error(data.error || 'Ошибка отправки');

                                updateTicketStatus(currentTicketId, 'Ожидает клиента');

                                try {
                                  await autoRefreshTickets();
                                } catch (e) {
                                  console.debug('Auto-refresh failed:', e);

                                }

                        window.currentReplyToTgId = null;
                        if (window.clearChip) window.clearChip();
		  }
		  
		  // Очищаем поле ввода
		  ta.value = '';
		  
		  // === ОБНОВЛЕНИЕ ИСТОРИИ ===
		  await updateHistory();
		  
		  const freshContainer = document.getElementById('historyContent');
		  if (freshContainer) {
			if (wasAtBottom) {
			  freshContainer.scrollTop = freshContainer.scrollHeight;
			}
			lastReadAtByTicket[currentTicketId] = Date.now();
			setUnread(0);
		  }
		  
		} catch (error) {
		  console.error('Ошибка отправки:', error);
		  alert('❌ ' + error.message);
		} finally {
		  this.disabled = false;
		}
	  };
	}
	// Функция для обновления статуса заявки локально
	function updateTicketStatus(ticketId, newStatus) {
	  console.log('🔄 Обновление статуса заявки:', ticketId, '->', newStatus);
	  
	  const found = findTicketEverywhere(ticketId);
	  if (!found) {
		console.log('❌ Не могу обновить статус: заявка не найдена');
		return false;
	  }
	  
	  const { source, ticket } = found;
	  
	  // Обновляем данные в зависимости от источника
	  if (source === 'allTickets' || source === 'filteredTickets') {
		// Обновляем в allTickets
		if (Array.isArray(window.allTickets)) {
		  const ticketIndex = window.allTickets.findIndex(t => String(t.ticket_id) === String(ticketId));
		  if (ticketIndex >= 0) {
                        const ticket = window.allTickets[ticketIndex];
                        ticket.status = newStatus;
                          if (newStatus === 'Ожидает клиента') ticket.raw_status = 'pending';
                          else if (newStatus === 'Открыта') ticket.raw_status = 'open';
                          else if (newStatus === 'Закрыта') ticket.raw_status = 'closed';
                          else if (newStatus === 'Ожидает оператора') ticket.raw_status = 'active';
                          else if (newStatus === 'Решено') ticket.raw_status = 'resolved';
                          else ticket.raw_status = 'pending';
                          if (newStatus === 'Ожидает клиента') {
                            ticket.last_sender = 'support';
                            ticket.has_support_reply = true;
                          } else if (newStatus === 'Ожидает реакции') {
                            ticket.last_sender = 'user';
                          } else if (newStatus === 'Новая') {
                            ticket.has_support_reply = false;
                            ticket.last_sender = 'user';
                          }
                        const statusLower = String(newStatus || '').toLowerCase();
                        const isResolvedLike = statusLower.includes('решен') || statusLower.includes('закры');
                        ticket.resolved_by = isResolvedLike ? ticket.resolved_by : null;
                        console.log('✅ Статус обновлен в allTickets');
		  }
		}
		
		// Обновляем в filteredTickets
		if (Array.isArray(window.filteredTickets)) {
		  const filteredIndex = window.filteredTickets.findIndex(t => String(t.ticket_id) === String(ticketId));
		  if (filteredIndex >= 0) {
                        const filteredTicket = window.filteredTickets[filteredIndex];
                        filteredTicket.status = newStatus;
                          if (newStatus === 'Ожидает клиента') filteredTicket.raw_status = 'pending';
                          else if (newStatus === 'Открыта') filteredTicket.raw_status = 'open';
                          else if (newStatus === 'Закрыта') filteredTicket.raw_status = 'closed';
                          else if (newStatus === 'Ожидает оператора') filteredTicket.raw_status = 'active';
                          else if (newStatus === 'Решено') filteredTicket.raw_status = 'resolved';
                          else filteredTicket.raw_status = 'pending';
                          if (newStatus === 'Ожидает клиента') {
                            filteredTicket.last_sender = 'support';
                            filteredTicket.has_support_reply = true;
                          } else if (newStatus === 'Ожидает реакции') {
                            filteredTicket.last_sender = 'user';
                          } else if (newStatus === 'Новая') {
                            filteredTicket.has_support_reply = false;
                            filteredTicket.last_sender = 'user';
                          }
                        const statusLower = String(newStatus || '').toLowerCase();
                        const isResolvedLike = statusLower.includes('решен') || statusLower.includes('закры');
                        filteredTicket.resolved_by = isResolvedLike ? filteredTicket.resolved_by : null;
                        console.log('✅ Статус обновлен в filteredTickets');
		  }
		}
		// === СИНХРОНИЗАЦИЯ С ALLTICKETS ===
		try {
		  const fullTicket = allTickets?.find(t => String(t.ticket_id) === String(ticketId));
		  if (fullTicket) {
                        fullTicket.status = newStatus;
                        // подстраховка: корректируем raw_status под конкретное значение
                          if (newStatus === 'Ожидает клиента') fullTicket.raw_status = 'pending';
                          else if (newStatus === 'Открыта') fullTicket.raw_status = 'open';
                          else if (newStatus === 'Закрыта') fullTicket.raw_status = 'closed';
                          else if (newStatus === 'Ожидает оператора') fullTicket.raw_status = 'active';
                          else if (newStatus === 'Решено') fullTicket.raw_status = 'resolved';
                          else fullTicket.raw_status = 'pending';
                          if (newStatus === 'Ожидает клиента') {
                            fullTicket.last_sender = 'support';
                            fullTicket.has_support_reply = true;
                          } else if (newStatus === 'Ожидает реакции') {
                            fullTicket.last_sender = 'user';
                          } else if (newStatus === 'Новая') {
                            fullTicket.has_support_reply = false;
                            fullTicket.last_sender = 'user';
                          }
                        const statusLower = String(newStatus || '').toLowerCase();
                        const isResolvedLike = statusLower.includes('решен') || statusLower.includes('закры');
                        fullTicket.resolved_by = isResolvedLike ? fullTicket.resolved_by : null;
                        console.log(`✅ Статус обновлен в allTickets: ${newStatus}`);
		  }
		} catch (e) {
		  console.warn('⚠️ Не удалось обновить статус в allTickets:', e);
		}
	  }
	  
	  // Всегда обновляем DOM
	  updateTicketStatusInTable(ticketId, newStatus);
	  
	  return true;
	}

	// Функция для принудительной проверки и обновления статуса
	function forceUpdateTicketStatus(ticketId, expectedNewStatus = 'Ожидает клиента') {
	  console.log('=== ПРИНУДИТЕЛЬНОЕ ОБНОВЛЕНИЕ СТАТУСА ===');
	  console.log('ticketId:', ticketId);
	  console.log('expectedNewStatus:', expectedNewStatus);
	  
	  // Обновляем в allTickets
            if (Array.isArray(window.allTickets)) {
                  const ticketIndex = window.allTickets.findIndex(t => String(t.ticket_id) === String(ticketId));
                  if (ticketIndex >= 0) {
                    console.log('Старый статус:', window.allTickets[ticketIndex].status);
                    const targetTicket = window.allTickets[ticketIndex];
                    targetTicket.status = expectedNewStatus;
                    targetTicket.raw_status = (expectedNewStatus === 'Решено') ? 'resolved' : 'pending';
                    if (expectedNewStatus === 'Ожидает клиента') {
                      targetTicket.last_sender = 'support';
                      targetTicket.has_support_reply = true;
                    } else if (expectedNewStatus === 'Ожидает реакции') {
                      targetTicket.last_sender = 'user';
                    }
                    console.log('Новый статус в allTickets:', window.allTickets[ticketIndex].status);
                  }
            }

            if (Array.isArray(window.filteredTickets)) {
                  const filteredIdx = window.filteredTickets.findIndex(t => String(t.ticket_id) === String(ticketId));
                  if (filteredIdx >= 0) {
                    const filteredTicket = window.filteredTickets[filteredIdx];
                    filteredTicket.status = expectedNewStatus;
                    filteredTicket.raw_status = (expectedNewStatus === 'Решено') ? 'resolved' : 'pending';
                    if (expectedNewStatus === 'Ожидает клиента') {
                      filteredTicket.last_sender = 'support';
                      filteredTicket.has_support_reply = true;
                    } else if (expectedNewStatus === 'Ожидает реакции') {
                      filteredTicket.last_sender = 'user';
                    }
                  }
            }
	  
	  // Немедленно обновляем отображение
	  updateTicketStatusInTable(ticketId, expectedNewStatus);
	  
	  // Принудительно перерисовываем таблицу
	  setTimeout(() => {
		if (window.filteredTickets && typeof displayTicketsForCurrentPageFiltered === 'function') {
		  displayTicketsForCurrentPageFiltered();
		} else if (typeof displayTicketsForCurrentPage === 'function') {
		  displayTicketsForCurrentPage();
		}
	  }, 100);
	}

// Функция для поиска заявки во всех источниках данных для отладочной информации
function findTicketEverywhere(ticketId) {
  console.log('🔍 Поиск заявки', ticketId, 'во всех источниках...');
  
  // Ищем в allTickets
  let ticket = window.allTickets?.find(t => String(t.ticket_id) === String(ticketId));
  if (ticket) {
    console.log('✅ Найдена в allTickets');
    return { source: 'allTickets', ticket };
  }
  
  // Ищем в filteredTickets
  ticket = window.filteredTickets?.find(t => String(t.ticket_id) === String(ticketId));
  if (ticket) {
    console.log('✅ Найдена в filteredTickets');
    return { source: 'filteredTickets', ticket };
  }
  
  // Ищем в DOM таблицы
  const rows = document.querySelectorAll('#ticketsBody tr');
  for (const row of rows) {
    const ticketIdCell = row.querySelector('code');
    if (ticketIdCell && ticketIdCell.textContent === String(ticketId)) {
      console.log('✅ Найдена в DOM таблицы');
      
      // Собираем данные из DOM
      const ticketData = {
        ticket_id: ticketId,
        status: row.querySelector('.badge')?.textContent?.trim() || 'Неизвестно',
        user_id: row.querySelector('.clickable-client')?.dataset?.userId || 'Неизвестно'
      };
      return { source: 'DOM', ticket: ticketData };
    }
  }
  
  console.log('❌ Заявка не найдена ни в одном источнике');
  return null;
}

	// Функция для обновления статуса в таблице
	function updateTicketStatusInTable(ticketId, newStatus) {
	  console.log('🔍 Поиск заявки в таблице DOM:', ticketId);
	  
	  const rows = document.querySelectorAll('#ticketsBody tr');
	  let found = false;
	  
	  rows.forEach(row => {
		const ticketIdCell = row.querySelector('code');
		if (ticketIdCell && ticketIdCell.textContent === String(ticketId)) {
		  found = true;
		  const statusCell = row.querySelector('td:nth-child(9)'); // 9-я колонка - статус
		  
		  if (statusCell) {
                        // Создаем новый бейдж статуса
                        let statusBadge = '';
                        if (newStatus === 'Ожидает клиента') {
                          statusBadge = '<span class="badge bg-info text-dark">⏳ Ожидает клиента</span>';
                        } else if (newStatus === 'Ожидает реакции') {
                          statusBadge = '<span class="badge bg-danger">⏳ Ожидает реакции</span>';
                        } else if (newStatus === 'Новая') {
                          statusBadge = '<span class="badge bg-secondary">🆕 Новая</span>';
                        } else if (newStatus === 'Решено') {
                          statusBadge = '<span class="badge bg-success">✅ Решено</span>';
                        } else {
                          statusBadge = `<span class="badge bg-warning">${newStatus}</span>`;
                        }

                        let unreadBadge = statusCell.querySelector('.unread-badge');
                        if (!unreadBadge) {
                          unreadBadge = document.createElement('span');
                          unreadBadge.className = 'badge bg-danger me-1 unread-badge';
                          unreadBadge.dataset.ticket = String(ticketId);
                          unreadBadge.style.display = 'none';
                          unreadBadge.textContent = '0';
                        }

                        const unreadValue = parseInt(unreadBadge.textContent, 10) || 0;
                        const ticketData = getTicketById(ticketId);
                        const canShowUnread = shouldDisplayUnreadBadge(ticketData, newStatus);

                        statusCell.innerHTML = '';
                        statusCell.insertAdjacentElement('afterbegin', unreadBadge);
                        statusCell.insertAdjacentHTML('beforeend', statusBadge);

                        unreadBadge.style.display = (unreadValue > 0 && canShowUnread) ? 'inline-flex' : 'none';
                        console.log('✅ Статус обновлен в DOM:', newStatus);
                  }
                }
          });

	  if (!found) {
		console.log('❌ Заявка не найдена в DOM таблицы');
		
		// Пытаемся обновить через перерисовку таблицы
		setTimeout(() => {
		  console.log('🔄 Попытка перерисовки таблицы...');
		  if (window.filteredTickets && typeof displayTicketsForCurrentPageFiltered === 'function') {
			displayTicketsForCurrentPageFiltered();
		  } else if (typeof displayTicketsForCurrentPage === 'function') {
			displayTicketsForCurrentPage();
		  }
		}, 500);
	  }
	}
	// === Отправка файлов из истории ===
	document.getElementById('replyFiles')?.addEventListener('change', async (e) => {
	  const files = Array.from(e.target.files || []);
	  if (!files.length) return;

	  // === ДИАГНОСТИКА ПЕРЕД ОТПРАВКОЙ ФАЙЛА ===
	  console.log('=== ДИАГНОСТИКА ПЕРЕД ОТПРАВКОЙ ФАЙЛА ===');
	  console.log('Текущий ticket_id:', currentTicketId);
	  
	  const currentTicket = window.allTickets?.find(t => String(t.ticket_id) === String(currentTicketId));
	  if (currentTicket) {
		console.log('Текущий статус заявки:', currentTicket.status);
		console.log('Raw статус:', currentTicket.raw_status);
	  }
	  console.log('==============================');
	  for (const file of files) {
		const fd = new FormData();
		fd.append('user_id', currentUserId);
		fd.append('ticket_id', currentTicketId);
		fd.append('admin', getOperatorName());
		fd.append('file', file);

		try {
		  if (window.currentReplyToTgId) {
			fd.append('reply_to_tg_id', String(window.currentReplyToTgId));
		  }
		  
		  const resp = await fetch('/reply_file', { method: 'POST', body: fd });
		  const j = await resp.json();
		  
		  if (!j.success) {
			alert('❌ Ошибка загрузки файла: ' + (j.error || ''));
			continue;
		  }

		  // Обновляем статус заявки после отправки файла оператором
		  if (j.success) {
			updateTicketStatus(currentTicketId, 'Ожидает клиента');
			try { 
			  await autoRefreshTickets(); 
			} catch(e) { 
			  console.debug('Auto-refresh failed:', e);
			}
		  }

		  // Обновляем историю
		  lastRenderedAt = null;
		  await updateHistory();
		  
		  // автоскролл
		  const container = document.getElementById('historyContent');
		  scrollToBottom(container);

		  lastReadAtByTicket[currentTicketId] = Date.now();
		  setUnread(0);
		  
		} catch (err) {
		  console.error('upload error', err);
		  alert('❌ Ошибка загрузки файла');
		}
	  }

	  // сбросить выбор
	  e.target.value = '';
	});

	// === Сохранить имя клиента ===
		async function saveClientName() {
			const newName = document.getElementById('clientNameInput').value.trim();
			const newUsername = document.getElementById('clientUsernameInput').value.trim();
			
			// Загружаем данные клиента заново
			try {
				const response = await fetch('/tickets_list');
				const allTickets = await response.json();
				const clientData = allTickets.find(t => t.user_id == currentUserId && t.ticket_id == currentTicketId);

				if (!newName && !newUsername) {
					alert('Введите хотя бы одно значение');
					return;
				}

				try {
					const response = await fetch('/update_client', {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify({
							user_id: currentUserId,
							client_name: newName,
							username: newUsername
						})
					});

					const data = await response.json();
					if (data.success) {
						alert('✅ Данные клиента обновлены');
						
						// Обновляем отображение имени в модальном окне истории
						const displayName = newName || newUsername || 'Клиент';
						document.getElementById('clientDisplayName').textContent = displayName;
						
						// Закрываем модальное окно редактирования
						bootstrap.Modal.getInstance(document.getElementById('editClientNameModal')).hide();
						
						// Обновляем данные в таблице (если она видима)
						if (window.refreshTicketsTable) {
							window.refreshTicketsTable();
						}
					} else {
						alert('❌ Ошибка при обновлении: ' + (data.error || 'Неизвестная ошибка'));
					}
				} catch (error) {
					console.error('Ошибка при сохранении имени:', error);
					alert('❌ Ошибка сети при сохранении имени');
				}
			} catch (error) {
				console.error('Ошибка при загрузке данных клиента:', error);
				alert('❌ Ошибка при загрузке данных клиента');
			}
		}

	// === Закрыть заявку (через отдельное окно) ===
	function getHistorySelectedCategories() {
                return Array.from(document.querySelectorAll('.category-checkbox:checked')).map(cb => cb.value);
        }

	async function performTicketClose(selectedCategories, triggerButton) {
                if (!Array.isArray(selectedCategories) || selectedCategories.length === 0) {
                        alert('❌ Выберите хотя бы одну категорию');
                        return;
                }

		const admin = getOperatorName();
                try {
                        triggerButton?.setAttribute('disabled', 'disabled');

                        const response = await fetch('/close_ticket', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                        user_id: currentUserId,
                                        admin,
                                        category: selectedCategories.join(', '),
                                        ticket_id: currentTicketId
                                })
                        });

                        const data = await response.json();
                        if (!data.success) {
                                alert('❌ Ошибка: ' + (data.error || 'Не удалось закрыть заявку'));
                                return;
                        }

                        const closeModalEl = document.getElementById('closeTicketModal');
                        if (closeModalEl) {
                                const instance = bootstrap.Modal.getInstance(closeModalEl);
                                instance?.hide();
                        }

                        const successModalEl = document.getElementById('ticketClosedModal');
                        if (successModalEl) {
                                bootstrap.Modal.getOrCreateInstance(successModalEl).show();
                        } else {
                                alert('✅ Заявка закрыта');
                                location.reload();
                        }
                } catch (error) {
                        console.error('Ошибка закрытия заявки:', error);
                        alert('❌ Ошибка: ' + (error?.message || error));
                } finally {
                        triggerButton?.removeAttribute('disabled');
                }
        }

		document.getElementById('closeTicketBtn').onclick = function () {
                const historySelected = getHistorySelectedCategories();
                if (historySelected.length > 0) {
                        performTicketClose(historySelected, this);
                        return;
                }

                syncCloseCategoriesFromHistory();
                const modal = new bootstrap.Modal(document.getElementById('closeTicketModal'));
                modal.show();
        };

        // === Подтвердить закрытие ===
        document.getElementById('confirmCloseTicketBtn').onclick = async function() {
                const selectedCategories = syncCloseCategorySelection();
                await performTicketClose(selectedCategories, this);
        };

                // === Подтвердить закрытие (из основного окна) ===
                function confirmClose(user_id, ticket_id) {
                        if (confirm("Завершить заявку?")) {
                                loadHistory(user_id, ticket_id);
                        }
		}
		// Обработчик ошибок загрузки изображений
		document.addEventListener('DOMContentLoaded', function() {
			document.body.addEventListener('error', function(e) {
				if (e.target.tagName === 'IMG' && e.target.classList.contains('img-thumbnail')) {
					const img = e.target;
					const fallback = img.nextElementSibling;
					if (fallback && fallback.classList.contains('text-muted')) {
						img.style.display = 'none';
						fallback.style.display = 'block';
					}
				}
			}, true);
		});
		
	// список базовых таймзон (можно расширить)
  const DEFAULT_TZ = localStorage.getItem('its_operator_tz') || Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC';

	function fmtTsISO(iso, tz = getOperatorTZ()) {
	  const d = new Date(iso);
	  if (isNaN(d.getTime())) return iso;
	  return new Intl.DateTimeFormat('ru-RU', {
		timeZone: tz,
		year: 'numeric', month: '2-digit', day: '2-digit',
		hour: '2-digit', minute: '2-digit', second: '2-digit'
	  }).format(d);
	}

	function getOperatorTZ() {
	  const saved = localStorage.getItem('its_operator_tz') || 'UTC';
	  return saved === 'browser' ? 'UTC' : saved;
	}

	function setOperatorTZ(value) {
	  localStorage.setItem('its_operator_tz', value);
	  const tz = value === 'browser' ? 'UTC' : value;
	  // Перерисовать все временные метки
	  document.querySelectorAll('.msg-time[data-iso]').forEach(el => {
		el.textContent = fmtTsISO(el.dataset.iso, tz);
	  });
	  // Обновить таблицу
	  if (window.filteredTickets && typeof displayTicketsForCurrentPageFiltered === 'function') {
		displayTicketsForCurrentPageFiltered();
		if (typeof updatePaginationFiltered === 'function') updatePaginationFiltered();
	  } else if (typeof displayTicketsForCurrentPage === 'function') {
		displayTicketsForCurrentPage();
		if (typeof updatePagination === 'function') updatePagination();
	  }
	}

  (function(){
    const sel = document.getElementById('tzSelect');
    if (!sel) return;
    // инициализация значением из localStorage (или 'browser')
    const stored = localStorage.getItem('its_operator_tz') || 'browser';
    // если такого option нет — не страшно
    if ([...sel.options].some(o => o.value === stored)) sel.value = stored;
    // обработчик изменения
    sel.addEventListener('change', (e) => setOperatorTZ(e.target.value));
  })();
</script>
<div class="modal fade" id="mediaViewerModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered modal-lg">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="mediaViewerTitle">Просмотр медиа</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Закрыть"></button>
      </div>
      <div class="modal-body" id="mediaViewerBody"></div>
      <div class="modal-footer">
        <a id="mediaViewerDownload" class="btn btn-outline-secondary" href="#" download>Скачать</a>
        <button type="button" class="btn btn-primary" data-bs-dismiss="modal">Закрыть</button>
      </div>
    </div>
  </div>
</div>
<div class="modal fade" id="imageModal" tabindex="-1">
  <div class="modal-dialog modal-dialog-centered modal-xl">
    <div class="modal-content bg-dark">
      <div class="modal-body p-0">
        <img id="imageModalImg" class="w-100" alt="Просмотр изображения">
      </div>
    </div>
  </div>
</div>
<div class="modal fade" id="imageViewerModal" tabindex="-1">
  <div class="modal-dialog modal-dialog-centered modal-xl">
    <div class="modal-content bg-dark">
      <div class="modal-body p-0 text-center">
        <img id="imageViewerImg" src="" alt="media" style="max-width:100%; max-height:85vh;">
      </div>
    </div>
  </div>
</div>
<!-- Модалка превью изображения -->
<div class="modal fade" id="imagePreviewModal" tabindex="-1">
  <div class="modal-dialog modal-dialog-centered modal-lg">
    <div class="modal-content">
      <div class="modal-body p-0">
        <img id="imagePreviewFull" src="" alt="preview" style="width:100%; height:auto; display:block;">
      </div>
      <div class="modal-footer py-2">
        <button type="button" class="btn btn-secondary btn-sm" data-bs-dismiss="modal">Закрыть</button>
        <a id="imageDownloadLink" class="btn btn-primary btn-sm" href="#" download>Скачать</a>
      </div>
    </div>
  </div>
</div>
<div class="modal fade" id="inviteUserModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Пригласить коллегу</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Закрыть"></button>
      </div>
      <div class="modal-body">
        <div class="mb-3">
          <label for="inviteUserSelect" class="form-label">Выберите пользователя</label>
          <select id="inviteUserSelect" class="form-select">
            <option value="">—</option>
          </select>
        </div>
        <p class="text-muted small mb-0">Выбранный пользователь получит уведомление со ссылкой на текущий диалог.</p>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Отмена</button>
        <button type="button" class="btn btn-primary" id="sendInviteBtn" disabled>Отправить приглашение</button>
      </div>
    </div>
  </div>
</div>
<!-- Twemoji -->
<script src="{{ url_for('static', filename='vendor/twemoji/twemoji.min.js') }}"></script>
<script>
  function parseEmojis(root) {
    if (!window.twemoji) return;
    twemoji.parse(root || document.body, {
      folder: 'svg',
      ext: '.svg',
      base: "{{ url_for('static', filename='vendor/twemoji/') }}",
      className: 'emoji',
      // ← критично: инлайновые размеры/выравнивание, чтобы Firefox не «сжимал»
      attributes: function () {
        return {
          draggable: 'false',
          style: [
            'display:inline-block',
            'width:1em',
            'height:1em',
            'max-width:none',
            'max-height:none',
            'vertical-align:-0.12em',
            'border:0',
            'padding:0',
            'background:transparent'
          ].join(';')
        };
      }
    });
  }
</script>

<script>
  // Парсим эмодзи в указанном контейнере (или во всём документе)
  function parseEmojis(root) {
    try {
      twemoji.parse(root || document.body, { folder: 'svg', ext: '.svg', className: 'emoji' });
    } catch (e) { /* no-op */ }
  }
  // Первичный проход после загрузки DOM
  document.addEventListener('DOMContentLoaded', function () { parseEmojis(document.body); });
</script>
<script>
(function () {
  function showAvatar(src) {
    const fallbackSrc = '/static/default-avatar.png';
    let prepared = ensureFullAvatarUrl(src);
    if (!prepared) {
      const normalized = normalizeAvatarUrl(src);
      prepared = normalized || fallbackSrc;
    }

    // ИСПРАВЛЕНИЕ: используем правильную модалку для аватара
    const modalEl = document.getElementById('avatarModal');
    const modalImg = document.getElementById('avatarModalImg');
    const downloadLink = document.getElementById('avatarDownloadLink');
    const modalDialog = modalEl ? modalEl.querySelector('.modal-dialog') : null;

    if (!modalEl || !modalImg) {
      console.error('Modal elements not found');
      return;
    }

    if (modalEl._avatarResizeHandler) {
      window.removeEventListener('resize', modalEl._avatarResizeHandler);
    }
    if (modalEl._avatarCleanupHandler) {
      modalEl.removeEventListener('hidden.bs.modal', modalEl._avatarCleanupHandler);
    }
    if (modalEl._avatarShownHandler) {
      modalEl.removeEventListener('shown.bs.modal', modalEl._avatarShownHandler);
    }

    if (!modalImg.dataset.defaultMaxHeight) {
      modalImg.dataset.defaultMaxHeight = modalImg.style.maxHeight || '';
    }

    const adjustAvatarModalSize = () => {
      if (!modalDialog) {
        return;
      }

      const naturalWidth = modalImg.naturalWidth;
      const naturalHeight = modalImg.naturalHeight;

      if (!naturalWidth || !naturalHeight) {
        modalDialog.style.removeProperty('max-width');
        modalDialog.style.removeProperty('width');
        modalImg.style.maxHeight = modalImg.dataset.defaultMaxHeight || '';
        return;
      }

      const viewportWidth = window.innerWidth * 0.95;
      const viewportHeight = window.innerHeight * 0.9;
      const dialogWidth = Math.min(naturalWidth, viewportWidth);
      const imageMaxHeight = Math.min(naturalHeight, viewportHeight);

      modalDialog.style.maxWidth = dialogWidth + 'px';
      modalDialog.style.width = 'auto';
      modalImg.style.maxHeight = imageMaxHeight + 'px';
    };

    const updateDownloadLink = (nextSrc) => {
      if (!downloadLink) return;
      downloadLink.href = nextSrc;
      downloadLink.download = 'avatar.jpg';
    };

    const currentSrc = modalImg.getAttribute('src') || '';
    const isSameSrc = currentSrc === prepared;

    if (!isSameSrc) {
      modalImg.style.opacity = '0';
    }

    modalImg.alt = 'Фото клиента';

    modalImg.onload = () => {
      modalImg.style.opacity = '1';
      adjustAvatarModalSize();
      modalImg.onload = null;
      modalImg.onerror = null;
    };

    modalImg.onerror = () => {
      if (!modalImg.src.includes(fallbackSrc)) {
        modalImg.src = fallbackSrc;
        updateDownloadLink(fallbackSrc);
        return;
      }

      modalImg.style.opacity = '1';
      modalImg.onerror = null;
    };

    if (isSameSrc) {
      if (modalImg.complete && modalImg.naturalWidth > 0) {
        modalImg.style.opacity = '1';
        modalImg.onload = null;
        modalImg.onerror = null;
      } else {
        modalImg.src = '';
        modalImg.src = prepared;
      }
    } else {
      modalImg.src = prepared;
    }

    updateDownloadLink(prepared);

    if (modalImg.complete && modalImg.naturalWidth > 0) {
      modalImg.style.opacity = '1';
      modalImg.onload = null;
      modalImg.onerror = null;
      adjustAvatarModalSize();
    }

    modalImg.dataset.currentSrc = prepared;

    const modalInstance = bootstrap.Modal.getOrCreateInstance(modalEl);
    modalInstance.show();

    window.addEventListener('resize', adjustAvatarModalSize);
    modalEl._avatarResizeHandler = adjustAvatarModalSize;

    const cleanupModal = () => {
      window.removeEventListener('resize', adjustAvatarModalSize);
      if (modalDialog) {
        modalDialog.style.removeProperty('max-width');
        modalDialog.style.removeProperty('width');
      }
      modalImg.style.maxHeight = modalImg.dataset.defaultMaxHeight || '';
      modalEl._avatarResizeHandler = null;
      modalEl._avatarCleanupHandler = null;
      modalEl._avatarShownHandler = null;
    };

    modalEl.addEventListener('hidden.bs.modal', cleanupModal, { once: true });
    modalEl._avatarCleanupHandler = cleanupModal;

    const handleModalShown = () => {
      adjustAvatarModalSize();
    };

    modalEl.addEventListener('shown.bs.modal', handleModalShown, { once: true });
    modalEl._avatarShownHandler = handleModalShown;
  }

  const avaInHistory = document.getElementById('clientAvatarInHistory');
  if (avaInHistory) {
    avaInHistory.style.cursor = 'zoom-in';
    avaInHistory.addEventListener('click', function () {
      const fullSrc = this.dataset.fullsrc || this.src;
      showAvatar(fullSrc);
    });
  }
})();

document.addEventListener('click', async (e)=>{
  const locationLink = e.target.closest('#historyLocationLink');
  if (locationLink) {
    e.preventDefault();
    if (!locationLink.classList.contains('disabled')) {
      const locationName = (locationLink.dataset.location || locationLink.textContent || '').trim();
      if (locationName) {
        await openPassportForLocation(locationName);
      }
    }
    return;
  }

  // открыть задачу по кнопке №DL_id
  const btnOpen = e.target.closest('.open-task-btn');
  if (btnOpen) {
    const taskId = btnOpen.dataset.taskId;
    window.location.href = `/tasks#task=${taskId}`;
    return;
  }

  // создать задачу из диалога
  const btn = e.target.closest('.create-task-btn');
  if (!btn) return;
  const payload = {
    problem: btn.dataset.problem || '',
    location: btn.dataset.location || '',
    ticket_id: btn.dataset.ticket || ''
  };
  try {
    const r = await fetch('/api/tasks/from_dialog', {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      credentials:'same-origin',
      body: JSON.stringify(payload)
    });
    if (r.status === 401) { alert('Сессия истекла. Войдите заново.'); window.location.href='/login'; return; }
    const data = await r.json();
    if (data && data.ok) {
      // меняем кнопку на номер задачи
      btn.outerHTML = `<button class="btn btn-sm btn-outline-primary open-task-btn" data-task-id="${data.id}">№DL_${data.id}</button>`;
      // помечаем тикет активным за текущим юзером
      try { await fetch(`/api/tickets/${payload.ticket_id}/active`, {method:'POST', credentials:'same-origin'}); } catch(_){}
    } else {
      alert(data && data.error ? data.error : 'Не удалось создать задачу');
    }
  } catch (error) {
      console.error('Не удалось открыть задачу по номеру:', error);
      alert('Сеть недоступна. Попробуйте ещё раз.');
  }
});

const clientTicketsList = document.getElementById('clientTicketsList');
if (clientTicketsList) {
  clientTicketsList.addEventListener('click', (event) => {
    const target = event.target.closest('[data-ticket-id]');
    if (!target) return;
    const ticketId = target.dataset.ticketId;
    const userId = target.dataset.userId || currentUserId;
    if (!ticketId || String(ticketId) === String(currentTicketId)) {
      return;
    }
    loadHistory(userId, ticketId);
  });
}

const assignResponsibleBtn = document.getElementById('assignResponsibleBtn');
if (assignResponsibleBtn) {
  assignResponsibleBtn.addEventListener('click', (event) => {
    event.preventDefault();
    assignResponsibleFromControl();
  });
}

  (function(){
    function openFromHash(){
      const h = location.hash || '';
      // формат: #open=ticket:<id>
      const m = h.match(/#open=ticket:([^&]+)/);
      if (m) {
        const ticketId = decodeURIComponent(m[1]);
        // user_id не знаем — у тебя loadHistory(user_id, ticket_id) принимает user_id,
        // подставим 0: сервер всё равно грузит по ticket_id.
        loadHistory(0, ticketId);
      }
    }
    window.addEventListener('hashchange', openFromHash);
    openFromHash();
  })();

  document.addEventListener('DOMContentLoaded', function () {
    const sel = document.getElementById('tzSelect');
    if (!sel) return; // ← защита: если селекта нет, ничего не делаем

    // восстановление сохранённого значения
    const stored = localStorage.getItem('its_operator_tz') || 'browser';
    if ([...sel.options].some(o => o.value === stored)) {
      sel.value = stored;
    }

    // реагируем на смену TZ
    sel.addEventListener('change', (e) => {
      const tz = e.target.value;
      // если в проекте есть твоя функция — используем её,
      // иначе просто сохраняем в localStorage и перезагружаем.
      if (typeof setOperatorTZ === 'function') {
        setOperatorTZ(tz);
      } else {
        localStorage.setItem('its_operator_tz', tz);
        location.reload();
      }
    });
  });

	// Функции для работы с модальными фильтрами
        function applyFiltersModal() {
                  const mapping = [
                        ['filterStatusModal', 'filterStatus'],
                        ['filterUserModal', 'filterUser'],
                        ['filterTicketIdModal', 'filterTicketId'],
                        ['filterBusinessModal', 'filterBusiness'],
                        ['filterLocationModal', 'filterLocation'],
                        ['filterClientStatusModal', 'filterClientStatus'],
                        ['filterResponsibleModal', 'filterResponsible'],
                        ['filterDateFromModal', 'filterDateFrom'],
                        ['filterDateToModal', 'filterDateTo']
                  ];

                  mapping.forEach(([modalId, inlineId]) => {
                        const modalEl = document.getElementById(modalId);
                        const inlineEl = document.getElementById(inlineId);
                        if (modalEl && inlineEl) {
                          inlineEl.value = modalEl.value || '';
                        }
                  });

                  applyFilters();
                  showActiveFiltersModal();

                  const modalInstance = bootstrap.Modal.getInstance(document.getElementById('filtersModal'));
                  if (modalInstance) {
                        modalInstance.hide();
                  }
        }

	function resetFiltersModal() {
	  // Сбрасываем значения в модальном окне
	  const modalFilterIds = [
		'filterStatusModal', 'filterUserModal', 'filterTicketIdModal', 
		'filterBusinessModal', 'filterLocationModal', 'filterClientStatusModal', 
		'filterResponsibleModal', 'filterDateFromModal', 'filterDateToModal'
	  ];
	  
	  modalFilterIds.forEach(id => {
		const element = document.getElementById(id);
		if (element) {
		  element.value = '';
		}
	  });
	  
	  // Сбрасываем основные фильтры
	  resetFilters();
	  // Сбрасываем активные фильтры в модальном окне
	  showActiveFiltersModal();
	  // Скрываем активные фильтры
	  const activeContainer = document.getElementById('activeFiltersModal');
	  if (activeContainer) {
		activeContainer.style.display = 'none';
	  }
	}

	function showActiveFiltersModal() {
	  const badgesContainer = document.getElementById('filterBadgesModal');
	  const activeContainer = document.getElementById('activeFiltersModal');
	  
	  if (!badgesContainer || !activeContainer) return;
	  
	  badgesContainer.innerHTML = '';
	  let hasActiveFilters = false;
	  
	  // Проверяем каждый фильтр и добавляем бейдж, если есть значение
	  const filters = [
		{ id: 'filterStatusModal', label: 'Статус' },
		{ id: 'filterUserModal', label: 'ID клиента' },
		{ id: 'filterTicketIdModal', label: 'ID заявки' },
		{ id: 'filterBusinessModal', label: 'Бизнес' },
		{ id: 'filterLocationModal', label: 'Локация' },
		{ id: 'filterClientStatusModal', label: 'Статус клиента' },
		{ id: 'filterResponsibleModal', label: 'Ответственный' },
		{ id: 'filterDateFromModal', label: 'Дата от' },
		{ id: 'filterDateToModal', label: 'Дата до' }
	  ];
	  
	  filters.forEach(filter => {
		const element = document.getElementById(filter.id);
		if (element && element.value) {
		  hasActiveFilters = true;
		  const badge = document.createElement('span');
		  badge.className = 'badge bg-primary filter-badge';
		  badge.innerHTML = `${filter.label}: ${element.value} 
			<span style="cursor:pointer; margin-left:5px;" onclick="removeFilterModal('${filter.id}')">×</span>`;
		  badgesContainer.appendChild(badge);
		}
	  });
	  
	  activeContainer.style.display = hasActiveFilters ? 'block' : 'none';
	}

        function removeFilterModal(filterId) {
  // Сбрасываем конкретный фильтр в модальном окне
          const modalElement = document.getElementById(filterId);
          if (modalElement) {
                modalElement.value = '';
          }
	  
	  // Если модальное окно открыто, обновляем отображение
	  if (document.getElementById('filtersModal').classList.contains('show')) {
		showActiveFiltersModal();
	  } else {
		// Если модальное окно закрыто, применяем изменения
                applyFiltersModal();
          }
        }

        // Инициализация при загрузке страницы
		document.addEventListener('DOMContentLoaded', function() {
		  // Показываем активные фильтры при открытии модального окна
		  document.getElementById('filtersModal').addEventListener('show.bs.modal', function() {
			// Синхронизируем значения из основных фильтров в модальные
			const mainFilters = [
			  'filterStatus', 'filterUser', 'filterTicketId', 'filterBusiness', 
			  'filterLocation', 'filterClientStatus', 'filterResponsible', 
			  'filterDateFrom', 'filterDateTo'
			];
			
			mainFilters.forEach(filterId => {
			  const mainEl = document.getElementById(filterId);
			  const modalEl = document.getElementById(filterId + 'Modal');
			  
			  if (mainEl && modalEl) {
				modalEl.value = mainEl.value;
			  }
			});
			
			showActiveFiltersModal();
		  });
		});


// === Ресайзер и состояние левой панели истории ===
function rememberSidebarWidth(width) {
  const sidebar = document.getElementById('historySidebar');
  if (!sidebar || !Number.isFinite(width)) return;
  const clamped = Math.max(300, Math.min(width, window.innerWidth * 0.7));
  sidebar.style.width = clamped + 'px';
  sidebar.style.flex = '0 0 auto';
  sidebar.dataset.expandedWidth = String(clamped);
  sidebar.style.setProperty('--sidebar-expanded-width', clamped + 'px');
  sidebar.style.setProperty('--sidebar-hover-width', clamped + 'px');
  localStorage.setItem('historySidebarWidth', clamped);
}

function setSidebarCollapsed(collapsed) {
  const sidebar = document.getElementById('historySidebar');
  const toggle = document.getElementById('sidebarCollapseToggle');
  const resizer = document.getElementById('historyPaneResizer');
  if (!sidebar || !toggle) return;

  const storedWidth = parseFloat(
    sidebar.dataset.expandedWidth ||
    localStorage.getItem('historySidebarWidth') ||
    sidebar.getBoundingClientRect().width ||
    400
  );

  if (Number.isFinite(storedWidth)) {
    sidebar.style.setProperty('--sidebar-hover-width', storedWidth + 'px');
  }

  if (collapsed) {
    sidebar.classList.add('collapsed');
    toggle.setAttribute('aria-expanded', 'false');
    toggle.title = 'Развернуть панель';
    if (!sidebar.dataset.expandedWidth && Number.isFinite(storedWidth)) {
      sidebar.dataset.expandedWidth = String(storedWidth);
    }
    if (resizer) resizer.classList.add('invisible');
  } else {
    sidebar.classList.remove('collapsed');
    toggle.setAttribute('aria-expanded', 'true');
    toggle.title = 'Свернуть панель';
    if (Number.isFinite(storedWidth)) {
      sidebar.style.width = storedWidth + 'px';
      sidebar.style.flex = '0 0 auto';
      sidebar.style.setProperty('--sidebar-expanded-width', storedWidth + 'px');
    }
    if (resizer) resizer.classList.remove('invisible');
  }

  localStorage.setItem('historySidebarCollapsed', collapsed ? '1' : '0');
  updateHistoryModalSidebarOffset();
}

function initHistoryPaneResizer() {
  const resizer = document.getElementById('historyPaneResizer');
  const sidebarPane = document.getElementById('historySidebar');
  const historyPane = document.querySelector('.history-pane');

  if (!resizer || !sidebarPane || !historyPane) return;

  let isResizing = false;
  let startX, startWidth;

  resizer.addEventListener('mousedown', function(e) {
    if (sidebarPane.classList.contains('collapsed')) {
      setSidebarCollapsed(false);
    }
    isResizing = true;
    startX = e.clientX;
    startWidth = sidebarPane.getBoundingClientRect().width;

    document.documentElement.classList.add('resizing');
    resizer.classList.add('resizing');

    const overlay = document.createElement('div');
    overlay.style.cssText = `position:fixed;top:0;left:0;width:100%;height:100%;background:transparent;z-index:9999;cursor:col-resize;`;
    overlay.id = 'resizeOverlay';
    document.body.appendChild(overlay);

    e.preventDefault();
  });

  function onMouseMove(e) {
    if (!isResizing) return;

    const width = startWidth + (e.clientX - startX);
    const minWidth = 300;
    const maxWidth = window.innerWidth * 0.7;
    const clamped = Math.min(Math.max(width, minWidth), maxWidth);

    sidebarPane.style.width = clamped + 'px';
    sidebarPane.style.flex = '0 0 auto';
    sidebarPane.style.setProperty('--sidebar-expanded-width', clamped + 'px');
    sidebarPane.style.setProperty('--sidebar-hover-width', clamped + 'px');
    sidebarPane.offsetHeight;
  }

  function onMouseUp() {
    if (!isResizing) return;

    isResizing = false;
    document.documentElement.classList.remove('resizing');
    resizer.classList.remove('resizing');

    const overlay = document.getElementById('resizeOverlay');
    if (overlay) overlay.remove();

    document.removeEventListener('mousemove', onMouseMove);
    document.removeEventListener('mouseup', onMouseUp);

    const finalWidth = sidebarPane.getBoundingClientRect().width;
    rememberSidebarWidth(finalWidth);
  }

  document.addEventListener('mousemove', onMouseMove);
  document.addEventListener('mouseup', onMouseUp);
}

function restoreSidebarWidth() {
  const sidebarPane = document.getElementById('historySidebar');
  if (!sidebarPane) return;

  const savedWidth = parseFloat(localStorage.getItem('historySidebarWidth') || '');
  if (Number.isFinite(savedWidth)) {
    rememberSidebarWidth(savedWidth);
  } else {
    const currentWidth = sidebarPane.getBoundingClientRect().width;
    sidebarPane.dataset.expandedWidth = String(currentWidth);
    sidebarPane.style.setProperty('--sidebar-expanded-width', currentWidth + 'px');
    sidebarPane.style.setProperty('--sidebar-hover-width', currentWidth + 'px');
  }

  const shouldCollapse = localStorage.getItem('historySidebarCollapsed') === '1';
  setSidebarCollapsed(shouldCollapse);
}

// Инициализация при загрузке модального окна
	document.getElementById('historyModal').addEventListener('shown.bs.modal', function() {
		historyModalIsOpen = true;
		  restoreSidebarWidth();
		  initHistoryPaneResizer();
	});

const ticketClosedModalEl = document.getElementById('ticketClosedModal');
if (ticketClosedModalEl) {
  ticketClosedModalEl.addEventListener('hidden.bs.modal', () => {
    location.reload();
  });
}

// Обработчик изменения размера окна
window.addEventListener('resize', function() {
  const sidebarPane = document.getElementById('historySidebar');
  if (!sidebarPane || sidebarPane.classList.contains('collapsed')) return;
  const currentWidth = sidebarPane.getBoundingClientRect().width;
  const maxWidth = window.innerWidth * 0.7;

  if (currentWidth > maxWidth) {
    rememberSidebarWidth(maxWidth);
  }
});

function applyHistoryFontSize(size) {
  const historyContent = document.getElementById('historyContent');
  if (!historyContent) {
    return;
  }

  const allowedSizes = ['small', 'medium', 'large'];
  const normalizedSize = allowedSizes.includes(size) ? size : 'medium';

  allowedSizes.forEach((item) => {
    historyContent.classList.remove(`font-size-${item}`);
  });

  historyContent.classList.add(`font-size-${normalizedSize}`);

  const fontSelect = document.getElementById('historyFontSizeControl');
  if (fontSelect && fontSelect.value !== normalizedSize) {
    fontSelect.value = normalizedSize;
  }
}

// Инициализация при загрузке страницы
document.addEventListener('DOMContentLoaded', function() {
  const savedUnread = localStorage.getItem('unreadCountByTicket');
  if (savedUnread) {
    unreadCountByTicket = JSON.parse(savedUnread);
  }

  const savedFont = localStorage.getItem('historyFontSize') || 'medium';
  applyHistoryFontSize(savedFont);

  const fontSelect = document.getElementById('historyFontSizeControl');
  if (fontSelect) {
    if (['small','medium','large'].includes(savedFont)) {
      fontSelect.value = savedFont;
    }
    fontSelect.addEventListener('change', (event) => {
      const value = event.target.value;
      applyHistoryFontSize(value);
      localStorage.setItem('historyFontSize', value);
    });
  }

  if (typeof restoreActiveDialogs === 'function') {
    restoreActiveDialogs();
  }

  const historyModalEl = document.getElementById('historyModal');
  const fullscreenToggleBtn = document.getElementById('toggleHistoryFullscreenBtn');
  if (fullscreenToggleBtn && historyModalEl) {
    fullscreenToggleBtn.addEventListener('click', () => {
      const shouldExpand = !historyModalEl.classList.contains('fullscreen');
      setHistoryModalFullscreen(shouldExpand);
      if (shouldExpand) {
        updateHistoryModalSidebarOffset();
      }
    });

    historyModalEl.addEventListener('hidden.bs.modal', () => {
      setHistoryModalFullscreen(false);
    });

    historyModalEl.addEventListener('shown.bs.modal', () => {
      if (historyModalEl.classList.contains('fullscreen')) {
        updateHistoryModalSidebarOffset();
      }
    });
  }

  const appSidebar = document.getElementById('app-sidebar');
  if (appSidebar) {
    const scheduleSidebarOffsetUpdate = () => {
      if (historyModalEl?.classList.contains('fullscreen')) {
        requestAnimationFrame(updateHistoryModalSidebarOffset);
      }
    };
    appSidebar.addEventListener('transitionend', (event) => {
      if (event.propertyName === 'width') {
        scheduleSidebarOffsetUpdate();
      }
    });
    const sidebarObserver = new MutationObserver(scheduleSidebarOffsetUpdate);
    sidebarObserver.observe(appSidebar, { attributes: true, attributeFilter: ['class'] });
  }

  window.addEventListener('resize', () => {
    if (historyModalEl?.classList.contains('fullscreen')) {
      updateHistoryModalSidebarOffset();
    }
  }, { passive: true });

  const mediaViewerModal = document.getElementById('mediaViewerModal');
  if (mediaViewerModal) {
    mediaViewerModal.addEventListener('hidden.bs.modal', () => {
      mediaViewerModal.style.removeProperty('--media-viewer-width');
      mediaViewerModal.style.removeProperty('--media-viewer-height');
      const bodyEl = document.getElementById('mediaViewerBody');
      if (bodyEl) {
        bodyEl.querySelectorAll('video').forEach(videoEl => {
          try { videoEl.pause(); } catch (error) { /* noop */ }
        });
        bodyEl.innerHTML = '';
      }
      const titleEl = document.getElementById('mediaViewerTitle');
      if (titleEl) {
        titleEl.textContent = 'Просмотр медиа';
      }
      const downloadEl = document.getElementById('mediaViewerDownload');
      if (downloadEl) {
        downloadEl.removeAttribute('download');
      }
    });
  }

  const listEl = document.getElementById('activeDialogList');
  if (listEl) {
    listEl.addEventListener('click', (event) => {
      const removeBtn = event.target.closest('.dialog-remove-btn');
      if (removeBtn) {
        const ticketId = removeBtn.dataset.ticketId;
        removeActiveDialog(ticketId);
        event.preventDefault();
        event.stopPropagation();
        return;
      }

      const item = event.target.closest('.list-group-item');
      if (!item) return;
      const ticketId = item.dataset.ticketId;
      const userId = item.dataset.userId;
      if (!ticketId || !userId) return;
      if (String(currentTicketId) === ticketId) return;
      loadHistory(userId, ticketId);
    });
  }

  const clearBtn = document.getElementById('clearActiveDialogsBtn');
  if (clearBtn) {
    clearBtn.addEventListener('click', () => {
      activeDialogs.clear();
      persistActiveDialogs();
      renderActiveDialogs();
    });
  }

  const toggleBtn = document.getElementById('sidebarCollapseToggle');
  if (toggleBtn) {
    toggleBtn.addEventListener('click', () => {
      const sidebar = document.getElementById('historySidebar');
      if (!sidebar) return;
      const collapsed = sidebar.classList.contains('collapsed');
      setSidebarCollapsed(!collapsed);
      if (collapsed) {
        const storedWidth = parseFloat(sidebar.dataset.expandedWidth || sidebar.getBoundingClientRect().width || 400);
        if (Number.isFinite(storedWidth)) {
          rememberSidebarWidth(storedWidth);
        }
      }
    });
  }

  const inviteBtn = document.getElementById('inviteToDialogBtn');
  const inviteModal = document.getElementById('inviteUserModal');
  const inviteSelect = document.getElementById('inviteUserSelect');
  const sendInviteBtn = document.getElementById('sendInviteBtn');

  if (inviteModal && inviteSelect && sendInviteBtn) {
    inviteModal.addEventListener('show.bs.modal', async () => {
      sendInviteBtn.disabled = true;
      inviteSelect.innerHTML = '<option value="">—</option>';
      try {
        const users = await fetchAdminUsersList();
        const currentName = (typeof CURRENT_OPERATOR === 'string' ? CURRENT_OPERATOR : '').trim();
        users.filter(user => user && user !== currentName).forEach(user => {
          const option = document.createElement('option');
          option.value = user;
          option.textContent = user;
          inviteSelect.appendChild(option);
        });
      } catch (error) {
        console.error('Не удалось загрузить пользователей', error);
        const option = document.createElement('option');
        option.value = '';
        option.textContent = 'Ошибка загрузки пользователей';
        inviteSelect.appendChild(option);
      }
    });

    inviteModal.addEventListener('hidden.bs.modal', () => {
      inviteSelect.value = '';
      sendInviteBtn.disabled = true;
    });

    inviteSelect.addEventListener('change', () => {
      sendInviteBtn.disabled = !inviteSelect.value;
    });

    sendInviteBtn.addEventListener('click', async () => {
      const ticketId = inviteBtn?.dataset.ticketId;
      const invitee = inviteSelect.value;
      if (!ticketId || !invitee) return;

      sendInviteBtn.disabled = true;
      try {
        await inviteUserToDialog(ticketId, invitee);
        bootstrap.Modal.getInstance(inviteModal)?.hide();
        alert(`Приглашение отправлено пользователю ${invitee}.`);
      } catch (error) {
        console.error(error);
        alert(error.message || 'Не удалось отправить приглашение');
      } finally {
        sendInviteBtn.disabled = false;
      }
    });
  }

  if (inviteBtn && inviteModal) {
    inviteBtn.addEventListener('click', () => {
      if (inviteBtn.disabled) return;
      bootstrap.Modal.getOrCreateInstance(inviteModal).show();
    });
  }

  setTimeout(() => {
    refreshUnreadIndicators();
  }, 1000);
});
window.currentUser = CURRENT_OPERATOR;
</script>

<!-- Модальное окно для просмотра аватара -->
<div class="modal fade" id="avatarModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered modal-lg">
    <div class="modal-content bg-dark">
      <div class="modal-header border-0">
        <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Закрыть"></button>
      </div>
      <div class="modal-body p-0 text-center">
        <img id="avatarModalImg" src="" alt="Аватар клиента" style="max-width: 100%; max-height: 80vh; object-fit: contain;">
      </div>
      <div class="modal-footer border-0 justify-content-center">
        <a id="avatarDownloadLink" class="btn btn-primary" href="#" download="avatar.jpg">
          <i class="bi bi-download"></i> Скачать
        </a>
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Закрыть</button>
      </div>
    </div>
  </div>
</div>
  </main>
  <script src="{{ url_for('static', filename='sidebar.js') }}"></script>
</body>
</html>
