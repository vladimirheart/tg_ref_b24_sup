<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Панель поддержки</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" />
  <link href="https://cdn.jsdelivr.net/npm/bootstrap-table@1.22.1/dist/bootstrap-table.min.css" rel="stylesheet">
  <link href="{{ url_for('static', filename='style.css') }}" rel="stylesheet" />
  <link href="{{ url_for('static', filename='sidebar.css') }}" rel="stylesheet" />
  <style>
  /* Предотвращаем первый «прыжок» при ресайзе столбцов */
#ticketsTable {
  table-layout: fixed;   /* фиксированная раскладка предотвращает перерасчёт ширин */
  width: 100%;
}
#ticketsTable th, 
#ticketsTable td {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
/* Фикс рывка в момент старта ресайза */
#ticketsTable th, #ticketsTable td { box-sizing: border-box; }
#ticketsTable th { will-change: width; }

/* отключим нежелательные переходы на ширину */
#ticketsTable th, #ticketsTable td { transition: none !important; }

/* Фикс для контейнера, чтобы не тянул всю ширину экрана во время перетаскивания */
.table-responsive {
  overflow: auto;
  contain: content;      /* изоляция контента от внешних перерисовок */
}

  /* Адаптивные стили для всех страниц */
  @media (max-width: 1024px) {
    .container {
      padding-left: 10px;
      padding-right: 10px;
    }

    .navbar-nav {
      flex-direction: row;
      flex-wrap: wrap;
      justify-content: center;
    }

    .navbar-nav .nav-link {
      padding: 0.5rem;
      font-size: 0.9rem;
    }

    .table-responsive {
      font-size: 0.85rem;
    }

    .chat-bubble {
      max-width: 90%;
    }

    .input-group-send {
      flex-direction: column;
    }

    .input-group-send textarea {
      min-height: 80px;
    }
	/* Маркёр активного пункта в меню настроек отправки */
	.dropdown-menu .dropdown-item .check {
	  display: inline-block;
	  width: 1.2em;
	}
	.dropdown-menu .dropdown-item.active .check::before {
	  content: "✔";
	}

    .modal-dialog {
      margin: 10px;
    }

    .btn-sm {
      font-size: 0.75rem;
      padding: 0.25rem 0.5rem;
    }
  }

  @media (max-width: 576px) {
    h2 {
      font-size: 1.5rem;
    }

    .badge {
      font-size: 0.7rem;
      margin-bottom: 5px;
    }

    .form-select, .form-control {
      font-size: 0.9rem;
    }

    .pagination {
      flex-wrap: wrap;
    }

    .page-link { padding: 0.3rem 0.6rem; font-size: 0.85rem; }
  }

  .category-selector {
    background-color: #f8f9fa;
    border-left: 4px solid #6f42c1;
    padding: 10px;
    margin-bottom: 15px;
    border-radius: 4px;
  }

  .chat-bubble {
    padding: 8px 12px;
    border-radius: 8px;
    margin-bottom: 6px;
    max-width: 80%;
    word-wrap: break-word;
    transition: opacity 0.3s ease;
  }
  /* Имя отправителя - делаем немного крупнее */
  .chat-bubble strong {
    font-size: 1.1em;      /* размер для имени */
    font-weight: 600;
  }

  /* Сообщение - стандартный размер */
  .chat-bubble p {
    font-size: 1em;        /* размер для текста сообщения */
    margin-bottom: 4px;
    line-height: 1.4;
  }

  /* Время - делаем мельче */
  .chat-bubble small {
    font-size: 0.85em;     /* размер для времени */
    color: #666 !important;
    opacity: 0.8;
  }
  /* ↑ Увеличение текста и эмодзи в сообщениях истории ~в 1.5 раза */
  .chat-bubble {
	  font-size: 1.5em;      /* было 1em → стало ~1.5x */
	  line-height: 1.35;
	}
	.chat-bubble img.emoji {
	  height: 1em;
	  width: 1em;
	  vertical-align: -0.1em;
	}
  @media (max-width: 768px) {
    .chat-bubble strong {
        font-size: 1.1em;
    }
    
    .chat-bubble p {
        font-size: 0.95em;
    }
    
    .chat-bubble small {
        font-size: 0.75em;
    }
  }
  .from-user {
    background: #e3f2fd;
    align-self: flex-start;
	margin-right: auto;
  }

  .from-support {
    background: #d1f7d1;
    align-self: flex-end;
	margin-left: auto;
  }

  .chat-container {
  flex: 1;
  min-height: 0;
  overflow-y: auto;
}

#historyModal .input-group-send {
  flex: 0 0 auto;
  margin-top: 0;
  border-top: 1px solid #dee2e6;
}

/* фиксируем ширину полосы — контент больше не «сжимается» при ховере контейнера */
#historyContent::-webkit-scrollbar {
  width: 12px;
}
#historyContent { scrollbar-width: thin; scrollbar-color: rgba(0,0,0,.55) transparent; }

/* желоб (трек) */
#historyContent::-webkit-scrollbar-track {
  background: transparent;
}
#historyContent::-webkit-scrollbar-track:hover {
  background: rgba(0,0,0,.04); /* опционально */
}

/* ползунок */
#historyContent::-webkit-scrollbar-thumb {
  background-color: rgba(0,0,0,.40);
  border-radius: 8px;
  border: 2px solid transparent;     /* визуально тоньше */
  background-clip: content-box;
  transition: background-color .15s ease;
}
#historyContent::-webkit-scrollbar-thumb:hover {
  background-color: rgba(0,0,0,.85);  /* меняем «прозрачность» только на самом ползунке */
}

/* оставляем, чтобы ширина под полосу была стабильной и не дёргалась верстка */
#historyContent { scrollbar-gutter: stable both-edges; }

#historyContent {
  scrollbar-gutter: stable both-edges;
}

/* Firefox: цвет и толщина (тонкий по умолчанию, «авто» при ховере) */
#historyContent { scrollbar-width: thin; scrollbar-color: rgba(0,0,0,.4) transparent; }
#historyContent.hovering { scrollbar-width: auto; scrollbar-color: rgba(0,0,0,.95) transparent; }
  
.history-viewport { position: relative; }
  
.history-scroll-btn {
  position: absolute;
  right: 6px;                /* рядом со скролл-баром */
  width: 34px;
  height: 34px;
  border-radius: 50%;
  border: 1px solid rgba(0,0,0,.15);
  background: var(--bs-body-bg);
  box-shadow: 0 2px 6px rgba(0,0,0,.15);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  opacity: .2;               /* ≈80% прозрачности */
  z-index: 3;
  user-select: none;
}

/* конкретные позиции */
.history-scroll-btn:hover { opacity: .9; }
.history-scroll-btn.top    { top: 6px; }
.history-scroll-btn.bottom { bottom: 6px; }

  .chat-bubble p, .chat-bubble small, .chat-bubble strong {
    color: #000 !important;
  }

  .input-group-send {
    display: flex;
    align-items: stretch;
    gap: 8px;
  }

  .input-group-send textarea {
    flex: 1;
    resize: vertical;
    min-height: 60px;
    max-height: 200px;
  }

  .input-group-send .btn {
    white-space: nowrap;
  }

  /* Стили для бизнесов */
  .business-sushi {
    background-color: #F25F79 !important;
    color: white !important;
  }

  .business-blin {
    background-color: #FFD504 !important;
    color: black !important;
  }

  /* Стили для resize столбцов */
  .table th {
    position: relative;
    user-select: none;
  }

  .resize-handle {
    position: absolute;
    top: 0;
    right: 0;
    width: 5px;
    height: 100%;
    background-color: #ddd;
    cursor: col-resize;
    user-select: none;
  }

  .clickable-client {
    cursor: pointer;
    color: #0d6efd;
    text-decoration: underline;
  }

  .clickable-client:hover {
    color: #0a58ca;
  }

  .column-toggle {
    max-height: 300px;
    overflow-y: auto;
  }

  .problem-info {
    background-color: #f8f9fa;
    border-left: 4px solid #0d6efd;
    padding: 10px;
    margin-bottom: 15px;
    border-radius: 4px;
  }

  .resizing {
    cursor: col-resize;
    user-select: none;
  }

  .table-column-hidden {
    display: none;
  }

  /* Адаптивность для таблицы */
  .table th, .table td {
    word-break: break-word;
  }

  /* Стили для выпадающего меню категорий */
  .category-selector .dropdown-menu {
    margin-left: 10px !important;
    min-width: 1000px !important;
    padding: 0.5rem;
  }

  .category-selector .form-check {
    margin: 0;
    padding: 0.25rem 1.5rem;
    white-space: nowrap;
  }

  .category-selector .form-check-input {
    margin-right: 0.5rem;
  }

  .category-selector .form-check-label {
    cursor: pointer;
    user-select: none;
    display: inline-block;
    width: calc(100% - 1.5rem);
  }

  .selected-categories {
    display: flex;
    flex-wrap: wrap;
    gap: 0.35rem;
    align-items: center;
  }

  .selected-categories .selected-label {
    font-size: 0.75rem;
    font-weight: 600;
    letter-spacing: 0.04em;
    text-transform: uppercase;
    margin-right: 0.25rem;
  }

  .category-chip {
    display: inline-flex;
    align-items: center;
    padding: 0.25rem 0.65rem;
    border-radius: 999px;
    font-weight: 600;
    font-size: 0.85rem;
    line-height: 1;
    color: #fff;
    background: var(--chip-color, #0d6efd);
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.16);
  }
.min-height-0 {
  min-height: 0 !important;
}
/* === История переписки: высота и раскладка === */
#historyModal .modal-dialog {
  width: 80vw !important;
  height: 90vh !important;
  max-width: 90vw;
  max-height: 90vh;
  margin: 5vh auto;
  display: flex;
}

#historyModal .modal-content {
  height: 100%;
  display: flex !important;
  flex-direction: column;
  flex: 1 1 auto;
  gap: 0;
}

#historyModal .modal-body {
  display: flex;
  flex-direction: column;
  flex: 1 1 auto;
  min-height: 0;
  gap: 0;
}

.resizable-modal .modal-dialog {
  resize: both;
  overflow: auto;
  min-width: 400px;
  min-height: 300px;
}

#historyModal .modal-header{ flex: 0 0 auto; }

/* Тело модалки — вертикальный flex-контейнер, занимают 1fr строки грида */
#historyModal .modal-body {
  padding: 0 !important;
  flex: 1;
  min-height: 0;
}

#historyModal .modal-footer{ flex: 0 0 auto; }

/* Контейнер с двумя колонками */
#historyModal .container-fluid {
  height: 100%;
  min-height: 0;
}

#historyModal .row {
  height: 100%;
  min-height: 0;
  margin: 0 !important;
  --bs-gutter-x: 0;
}

//* Внутри тела всё тянем по flex-цепочке без процентов */
#historyModal .modal-body > .container-fluid{
  display: flex;
  flex: 1 1 auto;
  min-height: 0;
  padding: 0 !important;
}

#historyModal .modal-body > .container-fluid > .row{
  display: flex;
  flex: 1 1 auto;
  min-height: 0;
  align-items: stretch;
  margin: 0 !important;
  --bs-gutter-x: 0;
  --bs-gutter-y: 0;
}

/* Убираем padding у колонок в модалке истории */
#historyModal .modal-body .col-md-4,
#historyModal .modal-body .col-md-8 {
  padding-left: 0 !important;
  padding-right: 0 !important;
}

/* Левая колонка */
#historyModal .sidebar-pane {
  position: relative;
  display: flex;
  flex-direction: column;
  min-height: 0;
  min-width: 300px;
  max-width: 70%;
  width: 400px; /* начальная ширина */
  background: #f8f9fa;
  border-right: 1px solid #dee2e6;
  overflow-y: auto;
}

#historyModal .history-avatar-wrapper {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.5rem;
}

#historyModal .history-avatar {
  width: 100%;
  max-width: 192px;
  aspect-ratio: 1 / 1;
  object-fit: cover;
  border: 1px solid rgba(0, 0, 0, .1);
  cursor: zoom-in;
  margin-inline: auto;
  transition: transform .2s ease;
}

#historyModal .history-avatar:hover {
  transform: scale(1.03);
}

/* Правая колонка (история) */
#historyModal .history-pane {
  position: relative;
  z-index: 1;
  display: flex;
  flex-direction: column;
  flex: 1 1 auto;
  min-height: 0;
  height: 100%;
}

/* Убираем возможность сжатия правой колонки */
#historyModal .col-md-8 {
  flex: 1 1 0%;
  min-width: 400px;
}

#historyModal .history-pane > .d-flex.flex-column {
  display: flex !important;
  flex: 1 1 auto !important;
  min-height: 0 !important;
  gap: 0;
  height: 100%;
}

/* Сама лента сообщений */
#historyModal .chat-container {
  flex: 1 1 auto;
  min-height: 0;
  overflow-y: auto;
  padding: 16px 16px 0px;
  display: flex;
  flex-direction: column;
   gap: 12px;
  justify-content: flex-start;
  margin-bottom: 0;
  background-color: #f8f9fa !important;
}

/* Обеспечиваем правильное отображение пузырей на фоне */
#historyModal .chat-bubble.from-user {
  background: #e3f2fd;
  border: 1px solid #bbdefb;
}

#historyModal .chat-bubble.from-support {
  background: #d1f7d1;
  border: 1px solid #a5d6a7;
}

#historyModal .input-group-send {
  margin-top: 0 !important;
  flex: 0 0 auto;
}

#historyModal .input-group-send {
  margin-top: 0 !important;
}

/* === История: разные шрифты для времени, автора и текста === */
#historyModal .chat-bubble .msg-time {
  /* моноширинный — лучше читаются цифры времени */
  font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
  font-size: 0.80rem;          /* фиксированный размер, не зависит от .chat-bubble {font-size} */
  line-height: 1.2;
  color: #6c757d !important;
  letter-spacing: .01em;
  display: inline-block;
  margin-bottom: .15rem;
}

#historyModal .chat-bubble .msg-author {
  /* плотный санс-сериф для имени */
  font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, "Noto Sans", sans-serif;
  font-weight: 700;
  font-size: 0.95rem;
  line-height: 1.25;
  display: inline-block;
  margin-bottom: .15rem;
}

#historyModal .chat-bubble .msg-text {
  /* нейтральный читабельный санс-сериф для тела сообщения */
  font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, "Noto Sans", sans-serif;
  font-size: 1.50rem;
  line-height: 1.45;
  color: #000 !important;
}

/* На очень узких экранах — чутка ужмём */
@media (max-width: 768px) {
  #historyModal .chat-bubble .msg-time   { font-size: .75rem; }
  #historyModal .chat-bubble .msg-author { font-size: .90rem; }
  #historyModal .chat-bubble .msg-text   { font-size: .95rem; }
}
/* Стек: время сверху, ниже — имя с зазором 3px */
#historyModal .chat-bubble .msg-time {
  display: block;
  margin: 0;                 /* без лишних отступов */
}
#historyModal .chat-bubble .msg-author {
  display: block;
  margin: 3px 0 6px 0;       /* 3px между временем и именем */
}

/* Обёртка каждого превью для позиционирования иконки */
#historyModal .chat-bubble .media-wrap {
  position: relative;
}

/* Кнопка-иконка скачивания в правом верхнем углу превью */
#historyModal .chat-bubble .media-download {
  position: absolute;
  top: 6px;
  right: 6px;
  width: 28px;
  height: 28px;
  border-radius: 50%;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  background: rgba(255,255,255,.9);
  border: 1px solid rgba(13,110,253,.25);
  text-decoration: none;
  font-size: 1rem;
  line-height: 1;
  color: #0d6efd !important;
  box-shadow: 0 2px 6px rgba(0,0,0,.15);
  opacity: .85;
  transition: transform .15s ease, opacity .15s ease;
}
#historyModal .chat-bubble .media-download:hover {
  opacity: 1;
  transform: translateY(-1px);
}

/* Подпись типа медиа: моноширинный, мелкий, «системный» */
#historyModal .chat-bubble .media-type {
  font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
  font-size: .78rem;
  line-height: 1.2;
  letter-spacing: .03em;
  text-transform: uppercase;
  color: #495057;
}

/* Подпись к медиа (если была) — обычный текст */
#historyModal .chat-bubble .media-caption {
  font-size: .95rem;
  line-height: 1.35;
}
/* === Twemoji: нормальный размер и выравнивание === */
#historyModal img.emoji,
#historyModal .msg-text img.emoji,
#historyModal .msg-author img.emoji {
  width: 1.1em !important;
  height: 1.1em !important;
  max-width: none !important;
  max-height: none !important;
  vertical-align: -0.12em;         /* чуть опускаем, чтобы сидели на базовой линии текста */
  margin: 0 .06em;
  border: 0 !important;
  padding: 0 !important;
  background: transparent !important;
  box-shadow: none !important;
}

/* На мелких экранах чуть компактнее */
@media (max-width: 768px) {
  #historyModal img.emoji,
  #historyModal .msg-text img.emoji,
  #historyModal .msg-author img.emoji {
    width: 1.0em !important;
    height: 1.0em !important;
    vertical-align: -0.1em;
  }
}
/* правая колонка с кнопками */
.send-actions .btn { white-space: nowrap; }
#replyTextInHistory { padding-bottom: 48px; } /* место под «док» внутри поля */
#composerDock .btn { line-height: 1; }

/* на узких экранах всё как раньше — под полем */
@media (max-width: 1024px) {
  .send-actions { width: 100% !important; }
}
/* Кнопка пикера — полупрозрачная, пока не активна */
.dock-btn { opacity:.45; transition:opacity .15s ease; }
.dock-btn:hover, .dock-btn.active { opacity:1; }

/* История: компактнее зазор между текстом и кнопками действий */
#historyModal .chat-bubble .msg-text { margin-bottom: 2px !important; }
#historyModal .chat-bubble p { margin-bottom: 2px !important; }

/* подсветка целевого сообщения при переходе из «чипа» */
.reply-preview {
  border-left: 3px solid #007bff;
  background: #f0f8ff;
  padding: 6px 8px;
  border-radius: 6px;
  margin-bottom: 6px;
}
/* Цвет текста в превью ответа */
.reply-preview .rp-box {
  color: #2c3e50; /* Темно-синий текст */
  font-style: italic;
}

/* При наведении на превью ответа */
.reply-preview:hover {
  background: #e3f2fd; /* Более яркий голубой при наведении */
  border-left-color: #0056b3; /* Темнее синий при наведении */
}
.chat-bubble.reply-target {
  outline: 2px solid #9ad;
  outline-offset: 2px;
  transition: outline-color .8s ease;
}

/* Экшен-бар внутри пузыря */
#historyModal .chat-bubble {
  position: relative;
  padding: 12px 14px 10px;
  overflow: visible;
}

#historyModal .bubble-meta {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 0.5rem;
  margin-bottom: 0.35rem;
}

#historyModal .bubble-meta .msg-time {
  margin-bottom: 0 !important;
}

#historyModal .chat-bubble .bubble-actions {
  position: static;
  display: flex;
  align-items: center;
  margin: 0 !important;
  opacity: .95;
  transition: opacity .15s ease;
}

#historyModal .chat-bubble .bubble-actions .btn {
  font-size: .85rem;
  line-height: 1;
  padding: 0 4px;
}

#historyModal .chat-bubble:hover .bubble-actions {
  opacity: 1;
}

/* Текст и отступы — чтобы ничего не перекрывалось */
#historyModal .chat-bubble .msg-time   { margin-bottom: .15rem; }
#historyModal .chat-bubble .msg-author { margin: 3px 0 6px 0; }
#historyModal .chat-bubble .msg-text   { margin-bottom: 0 !important; }

/* Мобильный фоллбек */
@media (max-width: 768px){
  #historyModal .bubble-meta {
    flex-wrap: wrap;
    row-gap: 0.25rem;
  }
  #historyModal .chat-bubble {
    padding: 12px;
  }
  #historyModal .chat-bubble .bubble-actions{
    width: 100%;
    justify-content: flex-end;
  }
}

.reply-preview .reply-text {
  font-size: 0.9em;
  color: #6c757d;
}

.reply-preview .btn-close {
  position: absolute;
  top: 5px;
  right: 5px;
  padding: 4px;
}
* === Редактирование / удаление === *
.chat-bubble.is-editing { outline: 2px dashed #6c757d; outline-offset: 2px; }
.chat-bubble.deleted    { opacity: .55; }
.badge-meta { font-weight: 500; border: 1px solid rgba(0,0,0,.08); }


.reply-target {
  outline: 2px dashed #0d6efd;
  outline-offset: 3px;
  animation: rt-blink 1.2s ease-in-out 1;
}

.chat-bubble.editing {
  box-shadow: 0 0 0 2px rgba(13,110,253,.35) inset;
}

@keyframes rt-blink {
  0% { background-color: rgba(13,110,253,.08); }
  100% { background-color: transparent; }
}
/* Стили для счётчика непрочитанных в таблице заявок */
#ticketsTable .unread-badge {
  font-size: 0.75rem;
  min-width: 20px;
  height: 20px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border: 2px solid #fff;
  box-shadow: 0 0 0 1px #dc3545;
}
.filter-badge {
  margin-right: 5px;
  margin-bottom: 5px;
  display: inline-block;
  font-size: 0.8em;
  padding: 4px 8px;
}

/* === Ресайзер для левой панели истории === */
.history-pane-resizer {
  position: absolute;
  top: 0;
  right: -4px;
  width: 8px;
  height: 100%;
  background: transparent;
  cursor: col-resize;
  z-index: 10;
}

.history-pane-resizer:hover,
.history-pane-resizer.resizing {
  background: rgba(0, 123, 255, 0.3);
}

.history-pane-resizer::after {
  content: '';
  position: absolute;
  top: 50%;
  left: 2px;
  width: 4px;
  height: 40px;
  background: #6c757d;
  border-radius: 2px;
  transform: translateY(-50%);
  opacity: 0;
  transition: opacity 0.2s;
}

.history-pane-resizer:hover::after {
  opacity: 0.7;
}

.history-pane-resizer.resizing::after {
  opacity: 1;
}

/* Обновляем стили для колонок с поддержкой ресайза */
.sidebar-pane {
  position: relative;
  min-width: 300px; /* минимальная ширина */
  max-width: 70%; /* максимальная ширина */
  resize: horizontal;
  overflow: auto;
}

.history-pane {
  position: relative;
  flex: 1;
  min-width: 400px; /* минимальная ширина правой части */
}

/* Исправление для модального окна аватара */
#avatarModal {
  z-index: 99999 !important;
}

#avatarModal .modal-dialog {
  max-width: 90vw;
  width: auto;
  z-index: 99999;
}

#avatarModal .modal-content {
  z-index: 99999;
  display: flex;
  flex-direction: column;
}

#avatarModal .modal-footer {
  background: transparent;
}

/* Гарантия, что модалка будет поверх всего */
.modal-backdrop {
  z-index: 99998;
}

/* Для случая, когда модалка открыта внутри другой модалки */
.modal {
  z-index: 99999;
}

.modal.small-modal {
    align-items: center;
    justify-content: center;
  }

/* Центрирование маленького модального окна закрытия */
.modal.small-modal.show {
    display: flex !important;
  }

  .modal.small-modal .modal-dialog {
    margin: 0;
    position: relative;
    top: 0;
    transform: none;
  }

/* Центрирование окна закрытия заявки */
#closeTicketModal .modal-dialog {
  margin: 0;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  position: fixed;
}

/* Центрирование окна "Заявка закрыта" */
#ticketClosedModal .modal-dialog {
  margin: 0;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  position: fixed;
}

/* Стили для плавного появления аватара в модалке */
#avatarModalImg {
  transition: opacity 0.3s ease;
  opacity: 0;
}

#avatarModalImg.loaded {
  opacity: 1;
}

  /* === DEBUG: цветные контуры в модалке истории === */
#historyModal.debug { --dbg-alpha: .12; }
#historyModal.debug * { box-sizing: border-box; }

/* каркас модалки */
#historyModal.debug .modal-content   { outline: 3px solid #ff1744;    background-image: none; }
#historyModal.debug .modal-header    { outline: 2px dashed #ff9100; }
#historyModal.debug .modal-body      { outline: 2px solid #ffea00;   }

/* сетка внутри */
#historyModal.debug .container-fluid { outline: 3px solid #aa00ff; }
#historyModal.debug .row             { outline: 3px solid #00b0ff; }

/* колонки */
#historyModal.debug .sidebar-pane    { outline: 3px solid #e91e63; }
#historyModal.debug .history-pane    { outline: 3px solid #4caf50; }

/* внутренняя обёртка справа (grid: 1fr auto) */
#historyModal.debug .history-pane > .d-flex.flex-column { outline: 3px solid #1de9b6; }

/* контент истории и зона ввода */
#historyModal.debug #historyContent  { outline: 3px solid #3f51b5;
  background-image: repeating-linear-gradient(45deg, rgba(63,81,181,var(--dbg-alpha)) 0 8px, transparent 8px 16px);
}
#historyModal.debug .input-group-send{ outline: 3px solid #ff9800; }

/* блоки слева */
#historyModal.debug .problem-info    { outline: 3px solid #9e9e9e; }
#historyModal.debug .category-selector { outline: 3px solid #607d8b; }
#historyModal.debug .time-counter    { outline: 3px solid #9c27b0; }

/* Twemoji: делаем эмодзи размером с текст */
img.emoji {
  height: 1em;
  width: 1em;
  margin: 0 .05em 0 .1em;
  vertical-align: -0.1em;
}

</style>
<script>
const CURRENT_OPERATOR = {{ (session.get('user_email') or session.get('username') or session.get('user') or '') | tojson }};

function getOperatorName() {
  const name = (typeof CURRENT_OPERATOR === 'string' ? CURRENT_OPERATOR : '').trim();
  return name || 'Поддержка';
}

function markTicketReopenedLocally() {
  // 1) Включаем кнопку «Закрыть заявку»
  const btn = document.getElementById('closeTicketBtn');
  if (btn) btn.removeAttribute('disabled');

  // 2) Чиним локальный статус, чтобы другой код не «переотключил» кнопку
  window.currentTicketStatus = 'open';

  // 3) Если у нас есть кэш списка тикетов — обновим там статус
  if (Array.isArray(window.allTickets)) {
    const i = window.allTickets.findIndex(t => String(t.ticket_id) === String(window.currentTicketId));
    if (i >= 0) window.allTickets[i].status = 'open';
  }

  // 4) (необязательно) визуально обновим бейдж статуса, если он есть
  const st = document.getElementById('ticketStatusBadge');
  if (st) { st.textContent = 'Открыта'; st.classList.remove('bg-secondary'); st.classList.add('bg-success'); }

  // 5) (необязательно) показать тост
  if (typeof showToast === 'function') showToast('Заявка переоткрыта');
}
</script>

</head>
<body class="with-sidebar sidebar-pinned">
  {% include "_sidebar.html" %}
  <main class="main-content container-fluid">

  <div class="container-fluid mt-4">
    <!-- Добавляем кнопку Фильтры и перемещаем Поиск -->
	<div class="d-flex justify-content-between align-items-center mb-3">
	  <h2>Список заявок</h2>
	  <div class="d-flex align-items-center">
		<!-- Поиск - теперь слева от кнопки Фильтры -->
		<div class="input-group me-2" style="width: 250px;">
		  <span class="input-group-text">🔍</span>
		  <input type="text" id="searchInput" class="form-control" placeholder="Поиск...">
		</div>

		<!-- Кнопка Фильтры -->
		<button class="btn btn-primary me-2" data-bs-toggle="modal" data-bs-target="#filtersModal">
		  <i class="bi bi-funnel"></i> Фильтры
		</button>

		<!-- Кнопка сброса фильтров -->
		<button class="btn btn-outline-secondary me-2" onclick="resetFilters()" title="Сбросить все фильтры">
		  🗑️ Сбросить
		</button>

		<!-- Остальные кнопки -->
		<button class="btn btn-outline-secondary me-2" onclick="toggleColumnSettings()">
		  ⚙️ Столбцы
		</button>

		<select id="tzSelect" class="form-select ms-2" style="width: 220px; display: inline-block;">
		  <option value="browser">Часовой пояс браузера</option>
		  <option value="Europe/Moscow">Europe/Moscow (GMT+3)</option>
		  <option value="Asia/Almaty">Asia/Almaty (GMT+6)</option>
		  <option value="Asia/Novosibirsk">Asia/Novosibirsk (GMT+7)</option>
		  <option value="Asia/Yekaterinburg">Asia/Yekaterinburg (GMT+5)</option>
		  <option value="Europe/Samara">Europe/Samara (GMT+4)</option>
		</select>

		<select id="pageSize" class="form-select ms-2" style="width: 120px; display: inline-block;">
		  <option value="5">5 заявок</option>
		  <option value="20" selected>20 заявок</option>
		  <option value="50">50 заявок</option>
		  <option value="100">100 заявок</option>
		  <option value="500">500 заявок</option>
		</select>
	  </div>
	</div>

	<!-- Убираем старый блок фильтров и заменяем его на более компактный -->
	<div class="filter-grid mb-3" style="display: none;" id="compactFilters">
	  <!-- Этот блок можно скрыть, так как фильтры теперь в модальном окне -->
	</div>

	<!-- Модальное окно фильтров для заявок -->
	<div class="modal fade" id="filtersModal" tabindex="-1">
	  <div class="modal-dialog modal-lg">
		<div class="modal-content">
		  <div class="modal-header">
			<h5 class="modal-title">Фильтры заявок</h5>
			<button type="button" class="btn-close" data-bs-dismiss="modal"></button>
		  </div>
		  <div class="modal-body">
			<div class="row filter-row">
			  <div class="col-md-6 mb-3">
				<label>Статус заявки</label>
				<select class="form-select" id="filterStatusModal">
				  <option value="">Все статусы</option>
				  <option value="pending">В обработке</option>
				  <option value="resolved">Решено</option>
				  <option value="Новая">Новая</option>
				  <option value="Ожидает реакции">Ожидает реакции</option>
				  <option value="Ожидает клиента">Ожидает клиента</option>
				</select>
			  </div>
			  <div class="col-md-6 mb-3">
				<label>ID клиента</label>
				<input type="text" class="form-control" id="filterUserModal" placeholder="Введите ID">
			  </div>
			  <div class="col-md-6 mb-3">
				<label>ID заявки</label>
				<input type="text" class="form-control" id="filterTicketIdModal" placeholder="Введите ID заявки">
			  </div>
			  <div class="col-md-6 mb-3">
				<label>Бизнес</label>
				<input type="text" class="form-control" id="filterBusinessModal" placeholder="Введите бизнес">
			  </div>
			  <div class="col-md-6 mb-3">
				<label>Локация</label>
				<input type="text" class="form-control" id="filterLocationModal" placeholder="Введите локацию">
			  </div>
			  <div class="col-md-6 mb-3">
				<label>Статус клиента</label>
				<input type="text" class="form-control" id="filterClientStatusModal" placeholder="Введите статус клиента">
			  </div>
			  <div class="col-md-6 mb-3">
				<label>Ответственный</label>
				<input type="text" class="form-control" id="filterResponsibleModal" placeholder="Введите ответственного">
			  </div>
			  <div class="col-md-6 mb-3">
				<label>Дата от</label>
				<input type="date" class="form-control" id="filterDateFromModal">
			  </div>
			  <div class="col-md-6 mb-3">
				<label>Дата до</label>
				<input type="date" class="form-control" id="filterDateToModal">
			  </div>
			</div>
			
			<!-- Активные фильтры -->
			<div class="mt-3" id="activeFiltersModal" style="display: none;">
			  <h6>Активные фильтры:</h6>
			  <div id="filterBadgesModal"></div>
			</div>
		  </div>
		  <div class="modal-footer">
			<button type="button" class="btn btn-secondary" onclick="resetFiltersModal()">Сбросить</button>
			<button type="button" class="btn btn-primary" onclick="applyFiltersModal()">Применить</button>
		  </div>
		</div>
	  </div>
	</div>

<!-- Модальное окно настроек столбцов -->
<div class="modal fade" id="columnSettingsModal" tabindex="-1">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Настройки столбцов</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
      </div>
      <div class="modal-body">
        <div class="column-toggle">
          <div class="form-check">
            <input class="form-check-input" type="checkbox" id="toggleClient" checked>
            <label class="form-check-label" for="toggleClient">Клиент</label>
          </div>
          <div class="form-check">
            <input class="form-check-input" type="checkbox" id="toggleClientStatus" checked>
            <label class="form-check-label" for="toggleClientStatus">Статус клиента</label>
          </div>
          <div class="form-check">
            <input class="form-check-input" type="checkbox" id="toggleChannel" checked>
            <label class="form-check-label" for="toggleChannel">Имя канала</label>
          </div>
          <div class="form-check">
            <input class="form-check-input" type="checkbox" id="toggleTicketId" checked>
            <label class="form-check-label" for="toggleTicketId">ID заявки</label>
          </div>
          <div class="form-check">
            <input class="form-check-input" type="checkbox" id="toggleBusiness" checked>
            <label class="form-check-label" for="toggleBusiness">Бизнес</label>
          </div>
          <div class="form-check">
            <input class="form-check-input" type="checkbox" id="toggleLocation" checked>
            <label class="form-check-label" for="toggleLocation">Локация</label>
          </div>
          <div class="form-check">
            <input class="form-check-input" type="checkbox" id="toggleProblem" checked>
            <label class="form-check-label" for="toggleProblem">Проблема</label>
          </div>
          <div class="form-check">
            <input class="form-check-input" type="checkbox" id="toggleResponsible" checked>
            <label class="form-check-label" for="toggleResponsible">Ответственный</label>
          </div>
          <div class="form-check">
            <input class="form-check-input" type="checkbox" id="toggleStatus" checked>
            <label class="form-check-label" for="toggleStatus">Статус</label>
          </div>
          <div class="form-check">
            <input class="form-check-input" type="checkbox" id="toggleDate" checked>
            <label class="form-check-label" for="toggleDate">Дата</label>
          </div>
          <div class="form-check">
            <input class="form-check-input" type="checkbox" id="toggleTime" checked>
            <label class="form-check-label" for="toggleTime">Время</label>
          </div>
          <div class="form-check">
            <input class="form-check-input" type="checkbox" id="toggleActions" checked>
            <label class="form-check-label" for="toggleActions">Действия</label>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Отмена</button>
        <button type="button" class="btn btn-primary" onclick="applyColumnSettings()">Применить</button>
      </div>
    </div>
  </div>
</div>

    <div class="table-responsive">
      <table class="table table-striped" id="ticketsTable">
        <thead>
          <tr>
            <th data-column="client" data-field="client" data-resizable="true">Клиент</th>
            <th data-column="clientStatus" data-field="clientStatus" data-resizable="true">Статус клиента</th>
			<th data-column="channel" data-field="channel" data-resizable="true">Имя канала</th>
            <th data-column="ticketId" data-field="ticketId" data-resizable="true">ID заявки</th>
            <th data-column="business" data-field="business" data-resizable="true">Бизнес</th>
            <th data-column="location" data-field="location" data-resizable="true">Локация</th>
            <th data-column="problem" data-field="problem" data-resizable="true">Проблема</th>
            <th data-column="responsible" data-field="responsible" data-resizable="true">Ответственный</th>
            <th data-column="status" data-field="status" data-resizable="true">
			  <span class="me-1">Статус</span>
			</th>
            <th data-column="date" data-field="date" data-resizable="true">Дата</th>
            <th data-column="time" data-field="time" data-resizable="true">Время</th>
            <th data-column="actions" data-field="actions" data-resizable="true">Действия</th>
          </tr>
        </thead>
        <tbody id="ticketsBody">
        </tbody>
      </table>
    </div>

    <nav aria-label="Page navigation">
      <ul class="pagination justify-content-center" id="pagination">
      </ul>
    </nav>
  </div>

<!-- Модальное окно: история -->
<div class="modal fade resizable-modal" id="historyModal" tabindex="-1">
  <div class="modal-dialog modal-xl" style="max-width: 60vw; height: 95vh; resize: both;">
    <div class="modal-content">
		<div class="modal-header flex-wrap">
		  <h5 class="modal-title d-flex align-items-center flex-wrap" id="historyModalTitle">
			💬 История переписки — ID заявки: &nbsp;<span id="ticketIdDisplay"></span>&nbsp;&nbsp;
			<span id="clientDisplayName">—</span>
			<span class="badge bg-info ms-2" id="clientStatusDisplay"></span>
			<span id="unreadBadge" class="badge bg-danger ms-2 d-none">0</span>
			<button type="button" class="btn btn-sm btn-outline-primary ms-2" id="editClientBtn" title="Редактировать имя">✏️</button>
		  </h5>
		  <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
		</div>
      <div class="modal-body p-0 flex-grow-1">
        <div class="container-fluid p-0 d-flex flex-column flex-fill min-height-0">
          <div class="row g-0 flex-fill min-height-0">
            <!-- Левая часть - информация о проблеме и категории -->
            <div class="col-md-4 sidebar-pane border-end">
              <div class="d-flex flex-column flex-fill min-height-0">
                <!-- Проблема -->
                <div class="problem-info p-3 sidebar-info">
                  <strong>Проблема:</strong>
                  <span id="problemText" class="ellipsis-100ch" title=""></span>
                </div>
                
                <!-- Категория обращения -->
                <div class="category-selector p-3 sidebar-info">
                  <label for="ticketCategorySelect" class="form-label">Категория обращения:</label>
                  <div class="selected-categories mt-2 ellipsis-100ch" id="selectedCategories" style="font-size: 0.9rem;" title=""></div>
                  <select id="ticketCategorySelect" class="form-select" multiple style="display: none;">
                    {% for cat in settings.categories %}
                      <option value="{{ cat }}">{{ cat }}</option>
                    {% endfor %}
                  </select>
                  <div class="dropdown" data-bs-auto-close="outside">
                    <button class="btn btn-outline-secondary dropdown-toggle w-100" type="button" id="categoryDropdown" data-bs-toggle="dropdown" aria-expanded="false">
                      Выберите категории...
                    </button>
                    <ul class="dropdown-menu" aria-labelledby="categoryDropdown" style="max-height: 300px; overflow-y: auto;">
                      {% for cat in settings.categories %}
                        <li>
                          <div class="form-check dropdown-item">
                            <input class="form-check-input category-checkbox" type="checkbox" value="{{ cat }}" id="cat{{ loop.index }}">
                            <label class="form-check-label w-100" for="cat{{ loop.index }}">{{ cat }}</label>
                          </div>
                        </li>
                      {% endfor %}
                    </ul>
                  </div>
                  <div class="form-text">Можно выбрать несколько категорий</div>
                  <button type="button" class="btn btn-outline-primary mt-2 w-100" onclick="saveTicketCategory()">
                    💾 Сохранить категорию
                  </button>
                </div>
				
                <!-- Фото клиента -->
                <div class="p-3 text-center history-avatar-wrapper">
                  <img id="clientAvatarInHistory" src="" alt="Аватар" class="rounded-circle history-avatar">
                  <div class="small text-muted mt-2">Фото клиента</div>
                </div>

                <!-- Таймер/счётчик времени -->
                <div class="time-counter p-3 sidebar-info mt-auto">
                  <label class="form-label">Время обращения:</label>
                  <div class="time-info bg-light p-3 rounded" id="timeInfo" title="">
                    <div id="timeCounter">Загрузка...</div>
                    <div id="timeDetails" class="small text-muted mt-1"></div>
                  </div>
					<button type="button" id="closeTicketBtn" class="btn btn-danger w-100 mt-3">
						Закрыть заявку
					</button>
                </div>
              </div>
            </div>
			<div class="history-pane-resizer" id="historyPaneResizer"></div>

            <!-- Правая часть - история переписки -->
            <div class="col-md-8 history-pane">
              <div class="d-flex flex-column flex-fill min-height-0">
                <!-- Блок переписки -->
                <div class="chat-container flex-grow-1 min-height-0" id="historyContent"></div>

                <!-- Поле ввода сообщения и кнопка отправки -->
                <div class="input-group-send border-top bg-light w-100 px-3 pt-3 pb-0">
                  <!-- Левая часть: textarea + «док» с эмодзи/стикерами/GIF ВНУТРИ поля -->
                  <div class="flex-grow-1 position-relative">
                    <div class="w-100">
                      <div class="d-flex gap-2 mb-1 flex-wrap">
                        <button type="button" class="btn btn-light btn-sm fmt" data-tag="b" title="Жирный">B</button>
                        <button type="button" class="btn btn-light btn-sm fmt" data-tag="i" title="Курсив"><em>I</em></button>
                        <button type="button" class="btn btn-light btn-sm fmt" data-tag="u" title="Подчёркнутый"><u>U</u></button>
                        <button type="button" class="btn btn-light btn-sm fmt" data-tag="s" title="Зачёркнутый"><s>S</s></button>
                        <button type="button" class="btn btn-light btn-sm fmt" data-tag="code" title="Моноширинный">code</button>
                        <button type="button" class="btn btn-light btn-sm fmt" data-tag="blockquote" title="Цитата">❝ ❞</button>
                        <button type="button" class="btn btn-light btn-sm" id="fmtLink" title="Ссылка">🔗</button>
                      </div>
                      <textarea id="replyTextInHistory" class="form-control" placeholder="Введите ответ." rows="2"></textarea>
                    </div>

                    <!-- ЕДИНАЯ кнопка выбора (эмодзи/стикеры/GIF) -->
                    <div id="composerDock" class="position-absolute" style="right:10px; bottom:15px;">
                      <button type="button"
                              id="btnPicker"
                              class="btn btn-sm btn-light px-3 dock-btn"
                              title="Эмодзи/Стикеры/GIF"
                              aria-expanded="false">😀</button>
                    </div>

                    <!-- Панель пикера (одно окно с вкладками) -->
                    <div id="pickerPanel" class="card shadow-sm"
                         style="position:absolute; right:10px; bottom:56px; width:360px; max-height:380px; display:none; z-index:5;">
                      <div class="card-header py-1 px-2">
                        <ul class="nav nav-tabs card-header-tabs" id="pickerTabs" role="tablist">
                          <li class="nav-item"><button class="nav-link active" id="tab-emoji" data-bs-toggle="tab" data-bs-target="#pane-emoji" type="button" role="tab">Эмодзи</button></li>
                          <li class="nav-item"><button class="nav-link" id="tab-sticker" data-bs-toggle="tab" data-bs-target="#pane-sticker" type="button" role="tab">Стикеры</button></li>
                          <li class="nav-item"><button class="nav-link" id="tab-gif" data-bs-toggle="tab" data-bs-target="#pane-gif" type="button" role="tab">GIF</button></li>
                        </ul>
                      </div>
                      <div class="card-body p-2 tab-content" style="overflow:auto;">
                        <!-- Эмодзи -->
                        <div class="tab-pane fade show active" id="pane-emoji" role="tabpanel">
                          <input id="emojiSearch" class="form-control form-control-sm mb-2" placeholder="Поиск эмодзи">
                          <div class="small text-muted" id="emojiRecentWrap" style="display:none;">Недавние:</div>
                          <div id="emojiRecent" class="d-flex flex-wrap gap-1 mb-2"></div>
                          <div id="emojiGrid" class="d-flex flex-wrap gap-1"></div>
                        </div>
                        <!-- Стикеры -->
                        <div class="tab-pane fade" id="pane-sticker" role="tabpanel">
                          <div class="small text-muted mb-2">Недавние</div>
                          <div id="stickerRecent" class="d-flex flex-wrap gap-2 mb-2"></div>
                          <label class="btn btn-sm btn-outline-secondary">
                            Загрузить стикер
                            <input id="fileSticker" type="file" class="d-none" accept=".webp,.webm,.tgs">
                          </label>
                        </div>
                        <!-- GIF -->
                        <div class="tab-pane fade" id="pane-gif" role="tabpanel">
                          <div class="small text-muted mb-2">Загрузить GIF</div>
                          <input id="fileGif" type="file" accept=".gif" class="form-control form-control-sm" />
                          <div id="gifPreview" class="mt-2 d-flex flex-wrap gap-2"></div>
                        </div>
                      </div>
                    </div>
                  </div>

                  <!-- ПРАВАЯ колонка: «Прикрепить» + «Отправить» -->
                  <div class="send-actions d-flex flex-column ms-2" style="width:160px;">
                    <input type="file" id="replyFiles" class="d-none" multiple>
                    <label for="replyFiles" id="replyFilesBtn" class="btn btn-outline-secondary w-100 mb-2">
                      📎
                    </label>
                    <button type="button" id="sendReplyInHistory" class="btn btn-primary w-100">📤 Отправить</button>
                  </div>
                </div>

              </div>
            </div>
          </div>
        </div>
      </div>
  </div>
</div>

     </div>
  </div>
</div>

  <!-- Модальное окно: ответ -->
  <div class="modal fade" id="replyModal" tabindex="-1">
    <div class="modal-dialog">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title">Ответить</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
        </div>
        <div class="modal-body">
          <textarea id="replyText" class="form-control" rows="4" placeholder="Введите ответ..."></textarea>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Отмена</button>
          <button type="button" class="btn btn-success" onclick="sendReply()">Отправить</button>
        </div>
      </div>
    </div>
  </div>
	
  <!-- Модальное окно: закрытие с категорией -->
<div class="modal fade" id="closeTicketModal" tabindex="-1">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Закрыть заявку</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
      </div>
      <div class="modal-body">
        <div class="category-selector mb-3">
          <label class="form-label">Категория обращения:</label>
          <select id="closeCategorySelect" class="form-select" multiple style="display: none;">
            {% for cat in settings.categories %}
            <option value="{{ cat }}">{{ cat }}</option>
            {% endfor %}
          </select>
          <div class="dropdown" data-bs-auto-close="outside">
            <button class="btn btn-outline-secondary dropdown-toggle w-100" type="button" id="closeCategoryDropdown" data-bs-toggle="dropdown" aria-expanded="false">
              Выберите категории...
            </button>
            <ul class="dropdown-menu" aria-labelledby="closeCategoryDropdown" style="max-height: 300px; overflow-y: auto;">
              {% for cat in settings.categories %}
              <li>
                <div class="form-check dropdown-item">
                  <input class="form-check-input close-category-checkbox" type="checkbox" value="{{ cat }}" id="closeCat{{ loop.index }}">
                  <label class="form-check-label w-100" for="closeCat{{ loop.index }}">{{ cat }}</label>
                </div>
              </li>
              {% endfor %}
            </ul>
          </div>
          <div class="selected-categories mt-2" id="closeSelectedCategories" style="font-size: 0.9rem;"></div>
          <div class="form-text">Можно выбрать несколько категорий</div>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Отмена</button>
        <button type="button" id="confirmCloseTicketBtn" class="btn btn-danger">Закрыть</button>
      </div>
    </div>
  </div>
</div>

<!-- Модальное окно: подтверждение успешного закрытия -->
<div class="modal fade small-modal" id="ticketClosedModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content text-center p-4">
      <div class="modal-body">
        <h5 class="mb-2">Заявка закрыта</h5>
        <p class="text-muted mb-0">Обращение успешно переведено в завершённое состояние.</p>
      </div>
      <div class="modal-footer justify-content-center border-0">
        <button type="button" class="btn btn-primary" data-bs-dismiss="modal">Ок</button>
      </div>
    </div>
  </div>
</div>

  <!-- Модальное окно: редактирование имени клиента -->
  <div class="modal fade" id="editClientNameModal" tabindex="-1">
    <div class="modal-dialog">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title">Редактирование имени клиента</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
        </div>
        <div class="modal-body">
          <div class="mb-3">
            <label for="clientNameInput" class="form-label">Имя клиента</label>
            <input type="text" class="form-control" id="clientNameInput" placeholder="Введите имя клиента">
          </div>
          <div class="mb-3">
            <label for="clientUsernameInput" class="form-label">Username</label>
            <input type="text" class="form-control" id="clientUsernameInput" placeholder="Введите username">
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Отмена</button>
          <button type="button" class="btn btn-primary" onclick="saveClientName()">Сохранить</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Подключение JS -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  <script>
    window.settings = {
  "categories": {{ settings.categories | tojson if settings and settings.categories else '["Консультация"]' | safe }}
};
  </script>

  <script>
	const savedPage = parseInt(localStorage.getItem('ticketsCurrentPage') || '1', 10);
	let currentPage = Number.isFinite(savedPage) && savedPage > 0 ? savedPage : 1;
	let totalPages = 1;
	let allTickets = [];
    let currentUserId = null;
    let currentTicketId = null;
    let historyPolling = null;
	window.lastReadAtByTicket = JSON.parse(localStorage.getItem('lastReadAtByTicket') || '{}');
    let currentPageSize = 20;
	        function persistCurrentPageIfUnfiltered() {
          if (!window.filteredTickets) {
                localStorage.setItem('ticketsCurrentPage', String(currentPage));
          }
        }

        function ensureCurrentPageBounds(totalItems) {
          const maxPage = Math.max(1, Math.ceil(totalItems / currentPageSize) || 1);
          if (currentPage > maxPage) currentPage = maxPage;
          if (currentPage < 1) currentPage = 1;
          return maxPage;
        }
	let unreadCount = 0;
		function setUnread(n) {
		  unreadCount = Math.max(0, n|0);
		  const b = document.getElementById('unreadBadge');
		  if (!b) return;
		  if (unreadCount > 0) {
			b.textContent = String(unreadCount);
			b.classList.remove('d-none');
		  } else {
			b.textContent = '0';
			b.classList.add('d-none');
		  }
		}
	let renderedMsgIds = new Set();

	function safeId(msg) {
	  // Берём любой доступный «телеграмный»/сквозной идентификатор
	  return (msg.tg_message_id ?? msg.message_id ?? msg.tg_id ?? msg.id ?? null);
	}

	function msgKey(msg) {
	  const sid = safeId(msg);
	  if (sid != null && sid !== '') return 'tg:' + String(sid);

	  const ts = Date.parse(msg.timestamp ?? msg.date ?? msg.created_at ?? '') || 0;
	  const s  = (msg.sender || '').toLowerCase();

	  // ВАЖНО: учитывать альтернативные поля текста, иначе разные ответы оператора
	  // будут иметь одинаковый ключ и «теряться»
	  const h  = (msg.message ?? msg.text ?? msg.body ?? '').toString().slice(0, 160);

	  return `${s}|${ts}|${h}`;
	}
	
	function telegramMid(msg) {
	  // Берём ТОЛЬКО реальные ID телеграм-сообщений
	  return (msg.tg_message_id ?? msg.message_id ?? null);
	}

        // Флаг «это сообщение оператора?»
        function isSupportMsg(msg) {
          const raw = String(msg.sender || '').toLowerCase().trim();
          return (
                ['support','operator','admin','поддержка','оператор','staff','agent'].includes(raw) ||
                msg.is_support === true ||
                msg.from_support === true ||
                msg.is_outgoing === true ||
                msg.sender_type === 'support' ||
                msg.direction === 'out' ||
                msg.sender === 'support'
          );
        }

        function isSupportSenderLabel(label) {
          const raw = String(label || '').toLowerCase().trim();
          if (!raw) return false;
          return (
            raw.includes('support') ||
            ['support','operator','admin','поддержка','оператор','staff','agent','system','bot','manager'].includes(raw)
          );
        }

        function isUserSenderLabel(label) {
          const raw = String(label || '').toLowerCase().trim();
          if (!raw) return false;
          return ['user','client','customer','клиент','пользователь','telegram_user','customer'].includes(raw);
        }

	// Единый UTC-timestamp (ms) для сортировки
	function sortTsMs(msg) {
	  const tsRaw = (msg.timestamp ?? msg.date ?? msg.created_at ?? msg.createdAt ?? msg.tg_date ?? null);
	  const iso   = normalizeToISO(tsRaw);      // уже возвращает корректный ISO в UTC
	  return Date.parse(iso) || 0;
	}

        function wrapSelection(tag, before='', after=''){
          const ta = document.getElementById('replyTextInHistory');
          const [start, end] = [ta.selectionStart, ta.selectionEnd];
          const sel = ta.value.substring(start, end) || 'текст';
          const open = `<${tag}${before}>`;
          const close = `</${tag.split(' ')[0]}>${after}`;
          ta.setRangeText(open + sel + close, start, end, 'end');
          ta.focus();
        }

        function normalizeAvatarUrl(src) {
          if (!src) return '';
          let value = String(src).trim();
          if (!value) return '';
          if (value.toLowerCase() === 'null' || value.toLowerCase() === 'undefined') return '';
          if (value.startsWith('data:')) return value;
          if (value.startsWith('http://') || value.startsWith('https://')) return value;
          if (value.startsWith('//')) return window.location.protocol + value;
          if (!value.startsWith('/')) value = '/' + value.replace(/^\/+/, '');
          return value;
        }

        function ensureFullAvatarUrl(src) {
          const normalized = normalizeAvatarUrl(src);
          if (!normalized) return '';
          if (!normalized.startsWith('/')) return normalized;
          if (normalized.includes('?full=1')) return normalized;
          return normalized.includes('?') ? `${normalized}&full=1` : `${normalized}?full=1`;
        }
	document.querySelectorAll('.fmt').forEach(btn=>{
	  btn.addEventListener('click', ()=>{
		const tag = btn.dataset.tag;
		if (tag === 'blockquote') wrapSelection('blockquote');
		else wrapSelection(tag);
	  });
	});
	document.getElementById('fmtLink')?.addEventListener('click', ()=>{
	  const url = prompt('Вставьте ссылку (https://)…','https://');
	  if (!url) return;
	  wrapSelection(`a href="${escapeHtml(url)}"`);
	});

	// Мини набор эмодзи (можно расширять)
	const EMOJI_LIST = window.EMOJI_LIST || Array.from("😀😁😂🤣😅😊🙂😉😍😘😋😎🤩🤔😴😷🤒🤕🤑🤯🤗🤝👍👎👏🙏💪🔥✨💥🎉❤️🧡💛💚💙💜🤍🤎🖤👌🙌🤌🤞✌️🤟👋🤙🤘🫶");
	const RECENT_KEY = "its_recent_emoji_v1";

	(function initEmojiUI(){
	  const ta         = document.getElementById('replyTextInHistory');
	  const panel      = document.getElementById('pickerPanel');
	  const grid       = document.getElementById('emojiGrid');
	  const recentWrap = document.getElementById('emojiRecentWrap');
	  const recentBox  = document.getElementById('emojiRecent');
	  const search     = document.getElementById('emojiSearch');

	  if (!ta || !panel || !grid) return; // тихо выходим, если секции нет

	  function renderEmoji(list){
		grid.innerHTML = "";
		list.forEach(ch => {
		  const b = document.createElement('button');
		  b.type = "button";
		  b.className = "btn btn-sm btn-light";
		  b.textContent = ch;
		  b.dataset.emoji = ch;          // для делегации кликов
		  grid.appendChild(b);
		});
	  }

	  function getRecent(){
		try { return JSON.parse(localStorage.getItem(RECENT_KEY) || "[]"); }
          catch (error) { return []; }
	  }
	  function pushRecent(ch){
		const arr = getRecent().filter(x => x !== ch);
		arr.unshift(ch);
		localStorage.setItem(RECENT_KEY, JSON.stringify(arr.slice(0, 16)));
	  }
	  function updateRecent(){
		const arr = getRecent();
		recentBox.innerHTML = "";
		recentWrap && (recentWrap.style.display = arr.length ? "" : "none");
		arr.forEach(ch => {
		  const b = document.createElement('button');
		  b.type = "button";
		  b.className = "btn btn-sm btn-outline-secondary";
		  b.textContent = ch;
		  b.addEventListener('click', () => {
			insertAtCaret(ta, ch + " ");
			pushRecent(ch);
			updateRecent();
		  });
		  recentBox.appendChild(b);
		});
	  }
	  function insertAtCaret(el, text){
		const start = el.selectionStart ?? el.value.length;
		const end   = el.selectionEnd ?? el.value.length;
		el.value = el.value.slice(0, start) + text + el.value.slice(end);
		el.focus();
		el.selectionStart = el.selectionEnd = start + text.length;
	  }

	  // Делегация кликов по основной сетке эмодзи
	  grid.addEventListener('click', (e)=>{
		const btn = e.target.closest('button[data-emoji]');
		if (!btn) return;
		const ch = btn.dataset.emoji;
		insertAtCaret(ta, ch + " ");
		pushRecent(ch);
		updateRecent();
	  });

	  // Поиск по эмодзи
	  search?.addEventListener('input', () => {
		const q = (search.value || "").trim();
		renderEmoji(q ? EMOJI_LIST.filter(ch => ch.includes(q)) : EMOJI_LIST);
	  });

	  // Первый рендер
	  renderEmoji(EMOJI_LIST);
	  updateRecent();
	})();

	/* ЕДИНАЯ кнопка (😀) → показать/спрятать панель с вкладками Эмодзи/Стикеры/GIF */
	(function initUnifiedPicker(){
	  const dock   = document.getElementById('composerDock');
	  const btn    = document.getElementById('btnPicker');
	  const panel  = document.getElementById('pickerPanel');

	  const tabEmoji   = document.getElementById('tab-emoji');
	  const tabSticker = document.getElementById('tab-sticker');
	  const tabGif     = document.getElementById('tab-gif');

	  if (!dock || !btn || !panel) return;

	  let lastTab = localStorage.getItem('pickerLastTab') || 'emoji';

	  function open(tab = lastTab){
		panel.style.display = 'block';
		btn.classList.add('active');
		(tab === 'sticker' ? tabSticker :
		 tab === 'gif'     ? tabGif     : tabEmoji)?.click();
	  }
	  function close(){
		panel.style.display = 'none';
		btn.classList.remove('active');
	  }

	  btn.addEventListener('click', () => {
		(panel.style.display === 'block') ? close() : open();
	  });

	  // запоминаем последнюю активную вкладку (через bootstrap tab)
	  [['emoji', tabEmoji], ['sticker', tabSticker], ['gif', tabGif]].forEach(([name, el])=>{
		el?.addEventListener('shown.bs.tab', () => {
		  lastTab = name;
		  localStorage.setItem('pickerLastTab', name);
		});
	  });

	  // клик вне панели/кнопки — закрываем; ESC — тоже
	  document.addEventListener('click', (e)=>{
		if (!panel.contains(e.target) && !dock.contains(e.target)) close();
	  }, true);
	  document.addEventListener('keydown', (e)=>{
		if (e.key === 'Escape') close();
	  });
	})();

	async function uploadOneFile(file) {
	  const fd = new FormData();
	  fd.append('user_id', String(currentUserId));
	  fd.append('ticket_id', String(currentTicketId));
	  fd.append('admin', getOperatorName());
	  fd.append('file', file);

	  const tmp = document.createElement('div');
	  tmp.className = 'chat-bubble from-support opacity-75';
	  tmp.dataset.temp = '1';
	  tmp.innerHTML = '<small>Отправка…</small><br><strong>🛠 Поддержка</strong>';
	  historyContent.appendChild(tmp);
	  scrollToBottom(historyContent);
	  const resp = await fetch('/reply_file', { method: 'POST', body: fd });
	  const data = await resp.json();
	if (!data.success) throw new Error(data.error || 'upload failed');

	if (data.reopened) {
	  markTicketReopenedLocally();
	  try { await autoRefreshTickets(); } catch (e) {}
	}

	// ⬇️ вместо оптимистичного рендера — принудительно обновляем историю из API
	if (typeof updateHistory === 'function') {
	  await updateHistory();
	  const c = document.getElementById('historyContent');
	  if (c) c.scrollTop = c.scrollHeight;
	}
	document.querySelectorAll('#historyContent .chat-bubble[data-temp="1"]').forEach(n => n.remove());
	}

// Стикеры
document.getElementById('fileSticker')?.addEventListener('change', async (e)=>{
  const f = e.target.files?.[0]; if (!f) return;
  try { await uploadOneFile(f); } catch(err){ alert('❌ ' + err.message); } finally { e.target.value=''; }
});

// GIF
document.getElementById('fileGif')?.addEventListener('change', async (e)=>{
  const f = e.target.files?.[0]; if (!f) return;
  try { await uploadOneFile(f); } catch(err){ alert('❌ ' + err.message); } finally { e.target.value=''; }
});

		// На переходный период (чтобы не вылавливать все вызовы сразу)
		function updateUnreadBadge(n) { setUnread(n ?? unreadCount); }
	let lastSeenAt = null;
    let columnSettings = {
		client: true,
		clientStatus: true,
		channel: true,
		ticketId: true,
		business: true,
		location: true,
		problem: true,
		responsible: true,
		status: true,
		date: true,
		time: true,
		actions: true
    };
	let lastRenderedAt = null;     // ISO-время последнего отрисованного сообщения
	let unreadCountValue = 0;           // счётчик непрочитанных во время открытой модалки
	let historyModalIsOpen = false;
	    let historyHasFocus = true;    // фокус внутри модалки
        let unreadCountByTicket = JSON.parse(localStorage.getItem('unreadCountByTicket') || '{}');     // { [ticketId]: number }
        function getTicketById(ticketId) {
          const id = String(ticketId);
          return window.allTickets?.find(t => String(t.ticket_id) === id)
                || window.filteredTickets?.find(t => String(t.ticket_id) === id)
                || null;
        }
		        function shouldDisplayUnreadBadge(ticket, overrideStatus) {
          if (!ticket) return true;
          const resolvedBy = String(ticket.resolved_by || '').toLowerCase();
          const autoClosed = resolvedBy.includes('авто') || resolvedBy.includes('auto');
          if (autoClosed) return true;

          const rawStatus = String(ticket.raw_status || '').toLowerCase();
          const humanStatus = String(overrideStatus || ticket.status || '').toLowerCase();
          const resolvedStatuses = ['resolved', 'closed'];
          const isResolvedRaw = resolvedStatuses.includes(rawStatus);
          const isResolvedHuman = humanStatus.includes('решено') || humanStatus.includes('закрыт') || humanStatus.includes('resolved') || humanStatus.includes('closed');
          return !(isResolvedRaw || isResolvedHuman);
        }
        const unreadFetchQueue = [];
        const unreadFetchInFlight = new Map();
        const unreadFetchTimestamps = new Map();
        const MAX_CONCURRENT_UNREAD_FETCHES = 2;
                function setTicketUnread(ticketId, n) {
          const key = String(ticketId);
          // Обновляем в таблице заявок
          const badgeInTable = document.querySelector(`.unread-badge[data-ticket="${key}"]`);
          if (badgeInTable) {
                n = Math.max(0, n | 0);
                badgeInTable.textContent = String(n);
                const ticketData = getTicketById(ticketId);
                const canShowUnread = shouldDisplayUnreadBadge(ticketData);
                badgeInTable.style.display = (n > 0 && canShowUnread) ? 'inline-flex' : 'none';
          }

          // Обновляем в модальном окне истории (если открыто)
          const badgeInHistory = document.getElementById('unreadBadge');
          if (badgeInHistory && String(currentTicketId) === key) {
                badgeInHistory.textContent = String(n);
                badgeInHistory.classList.toggle('d-none', n === 0);
          }

          unreadCountByTicket[key] = Math.max(0, n | 0);
          // 💾 Сохраняем в localStorage
                localStorage.setItem('unreadCountByTicket', JSON.stringify(unreadCountByTicket));
        }
        function recalcTicketUnreadFromDOM(ticketId) {
          const lastRead = lastReadAtByTicket[ticketId] || 0;
          let count = 0;

          // Если история открыта — считаем по DOM
	  if (currentTicketId == ticketId) {
		const content = document.getElementById('historyContent');
		if (content) {
		  content.querySelectorAll('.chat-bubble.from-user').forEach(b => {
			const ts = Number(b.dataset.ts) || 0;
			if (ts > lastRead) count++;
		  });
		}
	  } else {
		// Если история не открыта — используем сохранённое значение
		count = unreadCountByTicket[ticketId] || 0;
	  }

	  setTicketUnread(ticketId, count);
	  
          // Сохраняем в localStorage для отображения в таблице
          localStorage.setItem('unreadCountByTicket', JSON.stringify(unreadCountByTicket));
        }

        function refreshUnreadIndicators(scheduleFetch = true) {
          allTickets.forEach(ticket => {
                if (!ticket || ticket.ticket_id == null) return;
                const ticketId = String(ticket.ticket_id);

                if (String(currentTicketId) === ticketId) {
                  recalcTicketUnreadFromDOM(ticketId);
                } else {
                  const saved = unreadCountByTicket[ticketId];
                  setTicketUnread(ticketId, saved == null ? 0 : saved);
                }

                if (scheduleFetch) {
                  scheduleUnreadUpdate(ticket);
                }
          });
        }

	// Сохранение ширины столбцов
function saveColumnWidths() {
  const widths = {};
  document.querySelectorAll('th[data-column]').forEach(th => {
    const column = th.getAttribute('data-column');
    widths[column] = th.style.width || getComputedStyle(th).width;
  });
  localStorage.setItem('columnWidths', JSON.stringify(widths));
}

function isAtBottom(el) {
  return (el.scrollHeight - el.scrollTop - el.clientHeight) < 4;
}

function scrollToBottom(el) {
  el.scrollTop = el.scrollHeight;
}

// === Плавающие кнопки скролла в истории ===
function ensureHistoryScrollButtons() {
  const content = document.getElementById('historyContent');
  if (!content) return;

  // Родитель — хост для оверлея (не скроллится)
  const host = content.closest('.history-pane') || content.parentElement;
  if (!host) return;

  // Делаем его якорем позиционирования
  host.classList.add('history-viewport');
  if (getComputedStyle(host).position === 'static') {
    host.style.position = 'relative';
  }

  // Если кнопок ещё нет — создаём их в host (а не в content!)
  if (!host.querySelector('.history-scroll-btn.top')) {
    const topBtn = document.createElement('button');
    topBtn.type = 'button';
    topBtn.className = 'history-scroll-btn top';
    topBtn.title = 'Вверх списка сообщений';
    topBtn.innerText = '⬆️';
    topBtn.addEventListener('click', () => {
      content.scrollTo({ top: 0, behavior: 'smooth' });
    });
    host.appendChild(topBtn);
  }

  if (!host.querySelector('.history-scroll-btn.bottom')) {
    const bottomBtn = document.createElement('button');
    bottomBtn.type = 'button';
    bottomBtn.className = 'history-scroll-btn bottom';
    bottomBtn.title = 'Вниз списка сообщений';
    bottomBtn.innerText = '⬇️';
    bottomBtn.addEventListener('click', () => {
	  content.scrollTo({ top: content.scrollHeight, behavior: 'smooth' });
	  // фиксируем «прочитано»
	  lastSeenAt = new Date();
	  lastReadAtByTicket[currentTicketId] = Date.now();
	  localStorage.setItem('lastReadAtByTicket', JSON.stringify(lastReadAtByTicket));
	  setUnread(0);
	  setTicketUnread(currentTicketId, 0);
	});
    host.appendChild(bottomBtn);
  }

  // Обновлять видимость кнопок в зависимости от положения скролла
	const updateBtns = () => {
		const topBtn = host.querySelector('.history-scroll-btn.top');
		const bottomBtn = host.querySelector('.history-scroll-btn.bottom');
		if (!topBtn || !bottomBtn) return;

		const atTop = content.scrollTop <= 0;
		const atBottom = content.scrollHeight - content.clientHeight - content.scrollTop <= 10;

		topBtn.style.visibility = atTop ? 'hidden' : 'visible';
		bottomBtn.style.visibility = atBottom ? 'hidden' : 'visible';
		// Динамический зазор от зоны ввода
		const sendArea = host.querySelector('.input-group-send');
		// --- Сообщаем CSS фактическую высоту панели ввода (для padding-bottom истории)
			if (sendArea) {
			  const updateSendH = () => host.style.setProperty('--send-h', sendArea.offsetHeight + 'px');
			  updateSendH();

			  // Следим за изменениями высоты (переразмер textarea, адаптив и т.п.)
			  try {
				const ro = new ResizeObserver(updateSendH);
				ro.observe(sendArea);
			  } catch (e) {
				// Fallback для старых браузеров
				window.addEventListener('resize', updateSendH);
			  }
			}
		const pad = (sendArea?.offsetHeight || 0) + 9; // 6px как и раньше
		bottomBtn.style.bottom = pad + 'px';
	};

	  // навешиваем один раз
	  if (!content._scrollBtnsBound) {
		content.addEventListener('scroll', updateBtns, { passive: true });
		content._scrollBtnsBound = true;
	  }
	  updateBtns();
	}

	// Наблюдатель чтения
	let io;                          // IntersectionObserver
	const observedBubbles = new WeakSet();

	function setupReadObserver() {
	  const chatEl = document.getElementById('historyContent');
	  if (!chatEl) return;
	  if (io) io.disconnect();

	  io = new IntersectionObserver((entries) => {
		let maxTs = lastReadAtByTicket[currentTicketId] || 0;
		let changed = false;

		entries.forEach(e => {
		  if (!e.isIntersecting) return;
		  const el = e.target;
		  // Нас интересуют только клиентские пузыри
		  if (!el.classList.contains('from-user')) return;

		  const ts = Number(el.dataset.ts) || 0;
		  if (ts > maxTs) { maxTs = ts; changed = true; }
		});

		if (changed) {
		  // Обновляем «прочитано до» по тикету
		  lastReadAtByTicket[currentTicketId] = maxTs;
		  localStorage.setItem('lastReadAtByTicket', JSON.stringify(lastReadAtByTicket));

		  // Пересчитываем непрочитанные: все клиентские с ts > maxTs
		  const chatEl = document.getElementById('historyContent');
		  let count = 0;
		  chatEl.querySelectorAll('.chat-bubble.from-user').forEach(b => {
			const ts = Number(b.dataset.ts) || 0;
			if (ts > maxTs) count++;
		  });
		  setUnread(count);
		}
	  }, { root: document.getElementById('historyContent'), threshold: 0.7 });
	}

	function watchUserBubbles() {
	  const chatEl = document.getElementById('historyContent');
	  if (!chatEl || !io) return;
	  chatEl.querySelectorAll('.chat-bubble.from-user').forEach(b => {
		if (!observedBubbles.has(b)) {
		  io.observe(b);
		  observedBubbles.add(b);
		}
	  });
	}

	function tzOffsetMinutes(tz, at = new Date()) {
	  try {
		const parts = new Intl.DateTimeFormat('en-US', {
		  timeZone: tz, year:'numeric', month:'2-digit', day:'2-digit',
		  hour:'2-digit', minute:'2-digit', second:'2-digit', hour12:false
		}).formatToParts(at).reduce((o,p)=>{o[p.type]=p.value; return o;}, {});
		const asUTC = Date.UTC(+parts.year, +parts.month - 1, +parts.day, +parts.hour, +parts.minute, +parts.second);
		return Math.round((asUTC - at.getTime()) / 60000);
    } catch (error) { return 0; }
	}

		
	function normalizeToISO(x) {
	  if (x == null) return new Date().toISOString();
	  if (typeof x === 'number') {
		const ms = x < 1e12 ? x * 1000 : x;
		return new Date(ms).toISOString();
	  }
	  if (typeof x === 'string') {
		const s = x.trim();
		// Уже ISO с Z или смещением — используем как есть
		if (/[zZ]$/.test(s) || /[+-]\d{2}:\d{2}$/.test(s)) {
		  const d = new Date(s);
		  return isNaN(d) ? new Date().toISOString() : d.toISOString();
		}
		// Без таймзоны — считаем UTC (все времена в БД хранятся как UTC)
		if (/^\d{4}-\d{2}-\d{2}[ T]\d{2}:\d{2}:\d{2}$/.test(s)) {
		  const norm = s.replace(' ', 'T') + 'Z';
		  const d = new Date(norm);
		  return isNaN(d) ? new Date().toISOString() : d.toISOString();
		}
		// Иное — даём JS распарсить
		const d = new Date(s);
		return isNaN(d) ? new Date().toISOString() : d.toISOString();
	  }
	  return new Date().toISOString();
	}

        function sortMessagesStable(arr) {
          return arr.sort((a, b) => {
                const ta = sortTsMs(a), tb = sortTsMs(b);
                if (ta !== tb) return ta - tb;

                // дальше — детерминированные догоняющие ключи
                const ma = Number(telegramMid(a) ?? 0);
                const mb = Number(telegramMid(b) ?? 0);
                if (ma && mb && ma !== mb) return ma - mb;

                const ka = msgKey(a);
                const kb = msgKey(b);
                return ka.localeCompare(kb);
          });
        }

        function scheduleUnreadUpdate(ticket) {
          if (!ticket || ticket.ticket_id == null) return;

          const ticketId = String(ticket.ticket_id);
          if (historyModalIsOpen && String(currentTicketId) === ticketId) return;

          const lastSenderRaw = ticket.last_sender ?? ticket.last_sender_type ?? ticket.last_message_sender ?? ticket.last_message_from ?? ticket.last_author ?? '';
          const lastSender = String(lastSenderRaw || '').toLowerCase().trim();
          const direction = String(ticket.last_message_direction || ticket.direction || ticket.last_direction || ticket.last_message_side || '').toLowerCase().trim();

          const fromSupport = isSupportSenderLabel(lastSenderRaw) || ['out','outgoing','support','operator'].includes(direction);
          if (fromSupport) return;

          const fromUser = isUserSenderLabel(lastSenderRaw) || ['in','incoming','user','client','customer'].includes(direction);
          if (!fromUser && !lastSender && !direction) {
            // не удалось определить отправителя — всё равно делаем один запрос
          }

          const now = Date.now();
          if (unreadFetchInFlight.has(ticketId)) return;
          if (unreadFetchQueue.some(item => String(item.ticket.ticket_id) === ticketId)) return;

          const lastFetch = unreadFetchTimestamps.get(ticketId) || 0;
          if (now - lastFetch < 5000) return;

          unreadFetchQueue.push({ ticket });
          processUnreadFetchQueue();
        }

        function processUnreadFetchQueue() {
          if (unreadFetchInFlight.size >= MAX_CONCURRENT_UNREAD_FETCHES) return;

          const next = unreadFetchQueue.shift();
          if (!next) return;

          const ticketId = String(next.ticket.ticket_id);
          const promise = requestUnreadCountForTicket(next.ticket)
            .catch(err => {
              console.error('Не удалось обновить счётчик непрочитанных для заявки', ticketId, err);
            })
            .finally(() => {
              unreadFetchInFlight.delete(ticketId);
              unreadFetchTimestamps.set(ticketId, Date.now());
              processUnreadFetchQueue();
            });

          unreadFetchInFlight.set(ticketId, promise);
        }

        async function requestUnreadCountForTicket(ticket) {
          const ticketId = String(ticket.ticket_id);
          const params = new URLSearchParams({
            ticket_id: ticketId,
            _: String(Date.now())
          });

          if (ticket.channel_id != null && ticket.channel_id !== '' && ticket.channel_id !== 'null') {
            params.set('channel_id', String(ticket.channel_id));
          }

          const resp = await fetch(`/history?${params.toString()}`, { cache: 'no-store' });
          if (!resp.ok) {
            throw new Error(`HTTP ${resp.status}`);
          }

          const data = await resp.json();
          if (data && data.success === false) {
            throw new Error(data.error || 'history response error');
          }
          const messages = Array.isArray(data.messages) ? data.messages : [];
          const lastRead = lastReadAtByTicket[ticketId] || 0;

          let count = 0;

          for (const msg of messages) {
            const sender = String(msg.sender || '').toLowerCase();
            if (sender !== 'user') continue;

            const ts = Date.parse(normalizeToISO(msg.timestamp));
            if (!Number.isFinite(ts)) continue;

            if (ts > lastRead) count += 1;
          }

          setTicketUnread(ticketId, count);
        }

        function scheduleUnreadUpdate(ticket) {
          if (!ticket || ticket.ticket_id == null) return;

          const ticketId = String(ticket.ticket_id);
          if (historyModalIsOpen && String(currentTicketId) === ticketId) return;

          const lastSender = String(ticket.last_sender || '').toLowerCase();
          if (lastSender !== 'user') return;

          const now = Date.now();
          if (unreadFetchInFlight.has(ticketId)) return;
          if (unreadFetchQueue.some(item => String(item.ticket.ticket_id) === ticketId)) return;

          const lastFetch = unreadFetchTimestamps.get(ticketId) || 0;
          if (now - lastFetch < 5000) return;

          unreadFetchQueue.push({ ticket });
          processUnreadFetchQueue();
        }

        function processUnreadFetchQueue() {
          if (unreadFetchInFlight.size >= MAX_CONCURRENT_UNREAD_FETCHES) return;

          const next = unreadFetchQueue.shift();
          if (!next) return;

          const ticketId = String(next.ticket.ticket_id);
          const promise = requestUnreadCountForTicket(next.ticket)
            .catch(err => {
              console.error('Не удалось обновить счётчик непрочитанных для заявки', ticketId, err);
            })
            .finally(() => {
              unreadFetchInFlight.delete(ticketId);
              unreadFetchTimestamps.set(ticketId, Date.now());
              processUnreadFetchQueue();
            });

          unreadFetchInFlight.set(ticketId, promise);
        }

        async function requestUnreadCountForTicket(ticket) {
          const ticketId = String(ticket.ticket_id);
          const params = new URLSearchParams({
            ticket_id: ticketId,
            _: String(Date.now())
          });

          if (ticket.channel_id != null && ticket.channel_id !== '' && ticket.channel_id !== 'null') {
            params.set('channel_id', String(ticket.channel_id));
          }

          const resp = await fetch(`/history?${params.toString()}`, { cache: 'no-store' });
          if (!resp.ok) {
            throw new Error(`HTTP ${resp.status}`);
          }

          const data = await resp.json();
          if (data && data.success === false) {
            throw new Error(data.error || 'history response error');
          }
          const messages = Array.isArray(data.messages) ? data.messages : [];
          const lastRead = lastReadAtByTicket[ticketId] || 0;

          let count = 0;

          for (const msg of messages) {
            const sender = String(msg.sender || '').toLowerCase();
            if (sender !== 'user') continue;

            const ts = Date.parse(normalizeToISO(msg.timestamp));
            if (!Number.isFinite(ts)) continue;

            if (ts > lastRead) count += 1;
          }

          setTicketUnread(ticketId, count);
        }

function displayTicketDateTime(t) {
  // берём пару полей, как сейчас рисуешь таблицу; если есть альтернативы — тоже пробуем
  const base = (t.created_date && t.created_time)
    ? `${t.created_date} ${t.created_time}`
    : (t.created_at || t.updated_at || t.last_message_at || null);

  if (!base) return { date: '—', time: '—' };

  const iso = normalizeToISO(base);   // учтёт локаль сервера и вернёт UTC ISO
  const formatted = fmtTsISO(iso);    // форматирует под выбранную TZ оператора, напр. "26.09.2025, 13:45:12"
  const [date, time] = formatted.split(',').map(s => s.trim());
  return { date: date || '—', time: time || '—' };
}

// Универсальный рендерер сообщений
function renderMessagesHTML(ticket_id, messages, clientData) {
  return (messages || []).map(msg => {
    const rawSender = String(msg.sender || '').toLowerCase().trim();
    const isSupport =
      ['support','operator','admin','поддержка','оператор','staff','agent'].includes(rawSender) ||
      msg.is_support === true ||
      msg.from_support === true ||
      msg.is_outgoing === true ||
      msg.sender_type === 'support' ||
      msg.direction === 'out' ||
      msg.sender === 'support';

    const cls  = isSupport ? 'from-support' : 'from-user';
    let name   = isSupport ? '🛠 Поддержка' : '👤 Клиент';

	const tsRaw = (msg.timestamp ?? msg.date ?? msg.created_at ?? msg.createdAt ?? null);
	const isMedia = !!(msg.message_type && msg.message_type !== 'text' && msg.attachment);
	const iso   = normalizeToISO(tsRaw, isMedia);
	const time  = fmtTsISO(iso);                 // применит текущую TZ оператора
	const tsMs  = Date.parse(iso);               // для data-ts

    const bodyText = (msg.message ?? msg.text ?? msg.body ?? '').toString();

    // Имя отправителя
    if (!isSupport) {
      const clientName = clientData?.client_name;
      const username   = clientData?.username;
      if (clientName && clientName !== 'не задано') name = '👤 ' + clientName;
      else if (username) name = '👤 @' + username;
      else name = '👤 Клиент';
    } else {
      name = msg.sender_name || '🛠 Поддержка';
    }

    let mediaHtml = '';
    if (msg.message_type && msg.message_type !== 'text' && msg.attachment) {
      mediaHtml = createMediaHtml(ticket_id, {
        message_type: msg.message_type,
        attachment: msg.attachment,
        text: bodyText
      });
    }

    return `
      <div class="chat-bubble ${cls} ${msg.deleted_at ? 'opacity-50' : ''}"
         data-sender="${isSupport ? 'support' : 'user'}"
         data-ts="${tsMs}"
         data-tg-id="${safeId(msg) ?? ''}"
         data-mid="${telegramMid(msg) ?? ''}">
        <div class="bubble-meta">
          <small class="msg-time" data-iso="${iso}">${fmtTsISO(iso)}</small>
          <div class="bubble-actions dropdown">
            <button class="btn btn-sm btn-light p-1 px-2" data-bs-toggle="dropdown" aria-expanded="false"
                    title="Действия" style="line-height:1">⋯</button>
            <ul class="dropdown-menu dropdown-menu-end">
              <li><button class="dropdown-item action-reply">↩ Ответить</button></li>
              ${isSupport ? `
                <li><button class="dropdown-item action-edit">✏️ Редактировать</button></li>
                <li><button class="dropdown-item text-danger action-delete">🗑 Удалить</button></li>
                <li><hr class="dropdown-divider"></li>
                <li><button class="dropdown-item action-download">⤓ Скачать вложение</button></li>
              ` : `
                <li><button class="dropdown-item action-download">⤓ Скачать вложение</button></li>
              `}
            </ul>
          </div>
        </div>
        <strong class="msg-author">${name}</strong>
                ${msg.edited_at ? `<span class="badge-meta">изменено</span>` : ``}
                ${msg.deleted_at ? `<span class="badge-meta">удалено у клиента</span>` : ``}

        ${(msg.reply_preview || msg.reply_to_tg_id) ? `
		  <div
			class="reply-preview rp-jump"
			data-target="${msg.reply_to_tg_id || ''}"
			title="Показать исходное сообщение"
			style="cursor:pointer"
		  >
			<div class="rp-box">${escapeHtml(msg.reply_preview || '').replace(/\n/g,'<br>')}</div>
		  </div>
		` : ''}
	
        ${bodyText && (!msg.message_type || msg.message_type === 'text')
          ? `<p class="msg-text mb-1">${escapeHtml(bodyText).replace(/\n/g,'<br>')}</p>`
          : ''}

        ${mediaHtml}

      </div>
    `;
  }).join('');
}

function escapeHtml(s=''){return s.replace(/[&<>"']/g,m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;' }[m]));}

// Восстановление ширины столбцов
function restoreColumnWidths() {
  const savedWidths = localStorage.getItem('columnWidths');
  if (savedWidths) {
    const widths = JSON.parse(savedWidths);
    Object.keys(widths).forEach(column => {
      const th = document.querySelector(`th[data-column="${column}"]`);
      if (th && widths[column]) {
        th.style.width = widths[column];
        const index = Array.from(th.parentNode.children).indexOf(th);
        document.querySelectorAll('#ticketsBody tr').forEach(row => {
          const cell = row.children[index];
          if (cell) cell.style.width = widths[column];
        });
      }
    });
  }
}
    // Загрузка сохраненных настроек столбцов
    const savedColumnSettings = localStorage.getItem('columnSettings');
    if (savedColumnSettings) {
      columnSettings = JSON.parse(savedColumnSettings);
    }

    // Загрузка сохраненного размера страницы
    const savedPageSize = localStorage.getItem('pageSize');
    if (savedPageSize) {
      currentPageSize = parseInt(savedPageSize);
      document.getElementById('pageSize').value = currentPageSize;
    }

    // === Инициализация resize столбцов ===
function initColumnResize() {
  const headers = document.querySelectorAll('th[data-resizable="true"]');
  headers.forEach(header => {
    const oldHandle = header.querySelector('.resize-handle');
    if (oldHandle) {
      oldHandle.remove();
    }
    
    const handle = document.createElement('div');
    handle.className = 'resize-handle';
    header.appendChild(handle);
    
    let startX, startWidth;
    
    handle.addEventListener('mousedown', function(e) {
  // 1) Жёстко фиксируем текущую ширину в пикселях, чтобы не было пересчёта и «скачка»
  const computed = getComputedStyle(header).width;
  header.style.width = computed;

  // 2) Синхронно фиксируем соответствующие клетки tbody
  const index = Array.from(header.parentNode.children).indexOf(header);
  document.querySelectorAll('#ticketsBody tr').forEach(row => {
    const cell = row.children[index];
    if (cell) cell.style.width = computed;
  });

  startX = e.pageX;
  startWidth = parseFloat(computed);
  document.documentElement.classList.add('resizing');

  function onMouseMove(e) {
    const width = startWidth + (e.pageX - startX);
    if (width > 50) {
      header.style.width = width + 'px';
      const idx = Array.from(header.parentNode.children).indexOf(header);
      document.querySelectorAll('#ticketsBody tr').forEach(row => {
        const cell = row.children[idx];
        if (cell) cell.style.width = width + 'px';
      });
    }
  }

  function onMouseUp() {
    document.removeEventListener('mousemove', onMouseMove);
    document.removeEventListener('mouseup', onMouseUp);
    document.documentElement.classList.remove('resizing');
    saveColumnWidths();
  }

  document.addEventListener('mousemove', onMouseMove);
  document.addEventListener('mouseup', onMouseUp);
  e.preventDefault();
});

  });

    }

    // === Настройки столбцов ===
    function toggleColumnSettings() {
      // Устанавливаем текущие значения чекбоксов
      Object.keys(columnSettings).forEach(key => {
        const checkbox = document.getElementById(`toggle${key.charAt(0).toUpperCase() + key.slice(1)}`);
        if (checkbox) {
          checkbox.checked = columnSettings[key];
        }
      });
      new bootstrap.Modal(document.getElementById('columnSettingsModal')).show();
    }

    function applyColumnSettings() {
    // Сохраняем новые настройки
    Object.keys(columnSettings).forEach(key => {
        const checkbox = document.getElementById(`toggle${key.charAt(0).toUpperCase() + key.slice(1)}`);
        if (checkbox) {
            columnSettings[key] = checkbox.checked;
        }
    });
    
    // Сохраняем настройки в localStorage
    localStorage.setItem('columnSettings', JSON.stringify(columnSettings));
    
    // Применяем настройки к таблице
    document.querySelectorAll('th[data-column]').forEach(th => {
        const column = th.getAttribute('data-column');
        const index = Array.from(th.parentNode.children).indexOf(th);
        
        if (columnSettings[column]) {
            th.classList.remove('table-column-hidden');
            // Показываем колонку в теле таблицы
            document.querySelectorAll('#ticketsBody tr').forEach(row => {
                if (row.children[index]) {
                    row.children[index].classList.remove('table-column-hidden');
                }
            });
        } else {
            th.classList.add('table-column-hidden');
            // Скрываем колонку в теле таблицы
            document.querySelectorAll('#ticketsBody tr').forEach(row => {
                if (row.children[index]) {
                    row.children[index].classList.add('table-column-hidden');
                }
            });
        }
    });
    
    // Закрываем модальное окно только если оно существует
    const modalElement = document.getElementById('columnSettingsModal');
    if (modalElement) {
        const modal = bootstrap.Modal.getInstance(modalElement);
        if (modal) {
            modal.hide();
        }
    }
}
    function applyColumnSettingsFromState() {
  // Применяем настройки к шапке
  document.querySelectorAll('th[data-column]').forEach(th => {
    const column = th.getAttribute('data-column');
    const show = !!columnSettings[column];
    th.classList.toggle('table-column-hidden', !show);
  });

  // Применяем к телу таблицы
  const ths = Array.from(document.querySelectorAll('th[data-column]'));
  document.querySelectorAll('#ticketsBody tr').forEach(tr => {
    ths.forEach((th, idx) => {
      const column = th.getAttribute('data-column');
      const td = tr.children[idx];
      if (td) td.classList.toggle('table-column-hidden', !columnSettings[column]);
    });
  });
}

    // === Открыть окно ответа ===
    function openReplyModal(user_id) {
      currentUserId = user_id;
      document.getElementById('replyText').value = '';
      new bootstrap.Modal(document.getElementById('replyModal')).show();
    }

    // === Отправить ответ (с поддержкой reply/edit) ===
		async function sendReply() {
		  const ta    = document.getElementById('replyText');
		  const text  = (ta?.value || '').trim();
		  const admin = getOperatorName();
		  if (!text) { alert('Введите текст ответа'); return; }

		  try {
			const resp = await fetch('/reply', {
			  method: 'POST',
			  headers: { 'Content-Type':'application/json' },
			  body: JSON.stringify({
				user_id:   currentUserId,
				ticket_id: currentTicketId,
				admin,
				text,
				reply_to_tg_id: (window.currentReplyToTgId || null)
			  })
			});

			const data = await resp.json();
			if (!data.success) {
			  if (typeof data.retry_after === 'number' && data.retry_after > 0) {
				alert(`⏳ Лимит Telegram. Подождите ${data.retry_after} сек и повторите отправку.`);
				return;
			  }
			  throw new Error(data.error || 'Ошибка отправки');
			}

			if (data.reopened) {
			  markTicketReopenedLocally();
			  try { await autoRefreshTickets(); } catch(e) {}
			  document.getElementById('closeTicketBtn')?.removeAttribute('disabled');
			  if (typeof showToast === 'function') showToast('Заявка переоткрыта');
			}

			window.currentReplyToTgId = null;
			window.currentEditTgId = null;
			if (typeof updateHistory === 'function') {
			  await updateHistory();
			  const container = document.getElementById('historyContent');
			  if (container) container.scrollTop = container.scrollHeight;
			}
			if (ta) ta.value = '';
		  } catch (e) {
			alert('❌ ' + e.message);
		  }
		}

	// === Настройка отправки: хранение, отрисовка, обработчики ===
		function getSendMode() {
		  return localStorage.getItem('sendKeySetting') || 'enter';
		}
		function setSendMode(mode) {
		  localStorage.setItem('sendKeySetting', mode);
		  syncSendUI(mode);
		}

		// Обновляет бейдж на кнопке и активный пункт меню
		function syncSendUI(mode) {
		  const labelMap = {
			enter: 'Enter — отправить',
			ctrlEnter: 'Ctrl+Enter — отправить',
			enterNewline: 'Enter — новая строка'
		  };
		  const shortMap = {
			enter: 'Enter',
			ctrlEnter: 'Ctrl+Enter',
			enterNewline: 'Enter↵'
		  };
			const hint = document.getElementById('sendKeySettingCurrent');
			if (hint) hint.textContent = labelMap[mode] || '—';

		  document.querySelectorAll('#sendKeySetting .dropdown-menu .dropdown-item')
			.forEach(a => {
			  const m = a.getAttribute('data-mode');
			  a.classList.toggle('active', m === mode);
			  // Обновим подписи на случай будущих локализаций
			  if (labelMap[m]) a.lastChild.nodeValue = ' ' + labelMap[m];
			});
		}

		// Инициализация при загрузке скрипта
		(function initSendKeySettings() {
		  const mode = getSendMode();
		  syncSendUI(mode);

		  // Клик по пунктам меню
		  document.querySelectorAll('#sendKeySetting .dropdown-menu .dropdown-item')
			.forEach(a => {
			  a.addEventListener('click', (e) => {
				e.preventDefault();
				const nextMode = a.getAttribute('data-mode');
				setSendMode(nextMode);
			  });
			});

		  // При открытии дропдауна — синхронизация актуального состояния
		  const btn = document.getElementById('sendKeySettingBtn');
		  if (btn) {
			btn.addEventListener('show.bs.dropdown', () => syncSendUI(getSendMode()));
		  }

		  // Обработка клавиш в textarea истории
		  const ta = document.getElementById('replyTextInHistory');
		  const sendBtn = document.getElementById('sendReplyInHistory');
			if (ta && sendBtn) {
				ta.addEventListener('keydown', (e) => {
				  const m = getSendMode();
				  const isEnter = (e.key === 'Enter');
				  const isCtrl = (e.ctrlKey || e.metaKey); // поддержим Cmd на Mac

				  if (m === 'enter' && isEnter && !isCtrl) {
					// Enter — отправить
					e.preventDefault();
					sendBtn.click();
				  } else if (m === 'ctrlEnter' && isEnter && isCtrl) {
					// Ctrl+Enter — отправить
					e.preventDefault();
					sendBtn.click();
				  } else if (m === 'enterNewline' && isEnter && !isCtrl) {
					// Enter — новая строка (ничего не делаем, только перенос)
					// Но предотвращаем «по умолчанию» отправку форм (на всякий случай)
					// e.preventDefault();  // не трогаем, пусть вставляет перенос
				  }
				});
			}
		})();

    
    // === Обработчики выпадающего списка ===
    document.querySelectorAll('#sendKeySettingBtn + .dropdown-menu a').forEach(item => {
      item.addEventListener('click', function (e) {
        e.preventDefault();
        const mode = this.getAttribute('data-mode');
        localStorage.setItem('sendKeySetting', mode);
        setSendMode(mode);
      });
    });

	// === Автообновление таблица ===
	async function autoRefreshTickets() {
		try {
			const responseStats = await fetch('/stats_data');
			const data = await responseStats.json();

			const totalEl = document.getElementById('total');
			const pendingEl = document.getElementById('pending');
			const resolvedEl = document.getElementById('resolved');

			if (totalEl) totalEl.textContent = data.total || 0;
			if (pendingEl) pendingEl.textContent = data.pending || 0;
			if (resolvedEl) resolvedEl.textContent = data.resolved || 0;

			const responseTable = await fetch('/tickets_list');
			let tickets = await responseTable.json(); // ← переменная tickets объявлена здесь

			// подтягиваем статусы клиентов
			const statuses = await loadClientStatuses();
			tickets = tickets.map(t => ({
				...t,
				client_status: (statuses?.[t.user_id] ?? t.client_status ?? '—')
			}));

			console.log("📩 Полученные заявки:", tickets);

                        // Сохраняем все заявки для пагинации
                        allTickets = tickets;

                        // Если есть активные фильтры - применяем их ко всем данным
                        if (window.filteredTickets) {
                                applyFilters(); // Переприменяем фильтры к новым данным
                        } else {
                                // Иначе отображаем все заявки как обычно
                                totalPages = Math.ceil(allTickets.length / currentPageSize);
                                displayTicketsForCurrentPage();
                                updatePagination();
                        }

                        refreshUnreadIndicators();

                } catch (e) {
                        console.error("❌ Ошибка в autoRefreshTickets:", e);
                }
        }

// === Отображение заявок для текущей страницы ===
function displayTicketsForCurrentPage() {
  const container = document.getElementById('ticketsBody');
  if (!container) return;

  container.innerHTML = '';

  totalPages = ensureCurrentPageBounds(allTickets.length);
  persistCurrentPageIfUnfiltered();

  // Рассчитываем индексы для текущей страницы
  const startIndex = (currentPage - 1) * currentPageSize;
  const endIndex = Math.min(startIndex + currentPageSize, allTickets.length);
  
  // Получаем заявки для текучной страницы
  const pageTickets = allTickets.slice(startIndex, endIndex);
  
  if (pageTickets.length === 0) {
    container.innerHTML = '<tr><td colspan="12" class="text-center text-muted py-3">Нет заявок для отображения</td></tr>';
    return;
  }
  
  pageTickets.forEach(t => {
  const username = t.username ? `@${t.username}` : 'нет юзернейма';
  const clientName = t.client_name || 'не задано';

  // СОЗДАЁМ СТРОКУ
  const row = document.createElement('tr');

  // Индекс для фильтрации (то, по чему работает applyFilters)
  const searchIndex = [
    String(t.user_id || ''),
    String(t.ticket_id || ''),
    String(t.client_status || ''),
    String(t.channel_name || ''),
    String(t.business || ''),
    String(t.city || ''),
    String(t.location_name || ''),
    String(t.problem || ''),
    String(t.responsible || ''),
    String(t.raw_status || ''),
    String(t.status || ''),
    String(t.created_date || ''),
    String(t.created_time || ''),
    String(t.username || ''),
    String(clientName || '')
  ].join(' ').toLowerCase();
  row.dataset.search = searchIndex;

  const clientCell = `
  <div class="d-flex align-items-center gap-2">
    <img src="${t.avatar_url || '/static/default-avatar.png'}" 
         alt="" 
         width="36" 
         height="36" 
         class="rounded-circle" 
         style="object-fit:cover; border:1px solid rgba(0,0,0,.08)"
         onerror="this.src='/static/default-avatar.png'">
    <span class="clickable-client" data-user-id="${t.user_id}" onclick="window.open('/client/${t.user_id}', '_blank')">${
      (t.client_name && t.client_name !== 'не задано') ? t.client_name :
      (t.username ? '@' + t.username : 'Клиент ' + t.user_id)
    }</span>
  </div>`;

	let statusBadge;

	if (t.raw_status === 'resolved') {
	  statusBadge = `<span class="badge bg-success">✅ Решено</span>`;
	} else {
	  if (t.status === 'Новая') {
		statusBadge = `<span class="badge bg-secondary">🆕 Новая</span>`;
	  } else if (t.status === 'Ожидает реакции') {
		statusBadge = `<span class="badge bg-danger">⏳ Ожидает реакции</span>`;
	  } else {
		statusBadge = `<span class="badge bg-info text-dark">⏳ Ожидает клиента</span>`;
	  }
	}

	// Счётчик непрочитанных (слева от статуса)
		const unreadBadge = `<span class="badge bg-danger me-1 unread-badge" data-ticket="${t.ticket_id}" style="display:none;">0</span>`;
		statusBadge = unreadBadge + statusBadge;

  let businessClass = '';
  if (t.business === 'СушиВесла') businessClass = 'business-sushi';
  else if (t.business === 'БлинБери') businessClass = 'business-blin';

  // Кнопка создания задачи (безопасно прокидываем текст через JSON.stringify, чтобы не париться с кавычками)
	const createTaskBtn = (t.linked_task_id)
	  ? `<button class="btn btn-sm btn-outline-primary open-task-btn" data-task-id="${t.linked_task_id}">
		   №DL_${t.linked_task_id}
		 </button>`
	  : `<button class="btn btn-sm btn-outline-primary create-task-btn"
		   data-problem="${(t.problem||'').replace(/"/g,'&quot;')}"
		   data-location="${(t.location_name||t.city||'').replace(/"/g,'&quot;')}"
		   data-ticket="${t.ticket_id}">
		   Создать задачу
		 </button>`;

	const actionBtns = (t.raw_status !== 'resolved')
	  ? `<button class="btn btn-sm btn-outline-secondary" onclick="loadHistory(${t.user_id}, '${t.ticket_id}')">История</button>
		 ${createTaskBtn}
		 <button class="btn btn-sm btn-danger" onclick="confirmClose(${t.user_id}, '${t.ticket_id}')">Закрыть</button>`
	  : `<button class="btn btn-sm btn-outline-secondary" onclick="loadHistory(${t.user_id}, '${t.ticket_id}')">История</button>
		 ${createTaskBtn}`;

  let rowHTML = '';
	rowHTML += `<td>${clientCell}</td>`;
	rowHTML += `<td>${t.client_status || '—'}</td>`;
	rowHTML += `<td>${t.channel_name || '—'}</td>`;
	rowHTML += `<td><code>${t.ticket_id}</code></td>`;
	rowHTML += `<td class="${businessClass}">${t.business}</td>`;
	rowHTML += `<td>${t.city}<br><small>${t.location_name}</small></td>`;
	rowHTML += `<td>${t.problem}</td>`;
	rowHTML += `<td>${t.responsible}</td>`;
	rowHTML += `<td>${statusBadge}</td>`;
	const dt = displayTicketDateTime(t);
		rowHTML += `<td>${dt.date}</td>`;
		rowHTML += `<td>${dt.time}</td>`;
	rowHTML += `<td>${actionBtns}</td>`;
	row.innerHTML = rowHTML;
	container.appendChild(row);
		// --- ВОССТАНОВЛЕНИЕ СЧЁТЧИКА НЕПРОЧИТАННЫХ ПРИ ОТРИСОВКЕ ---
		let unread = 0;
		const lastRead = lastReadAtByTicket[t.ticket_id] || 0;
		if (unreadCountByTicket[t.ticket_id] !== undefined) {
		  unread = unreadCountByTicket[t.ticket_id];
		} else {
		  // Если вообще нет данных — считаем 0
		  unread = 0;
		}

                setTicketUnread(t.ticket_id, unread);
                scheduleUnreadUpdate(t);
                });
	parseEmojis(document.getElementById('ticketsBody'));
		applyColumnSettingsFromState();
		applyFilters();
		initColumnResize(); // Инициализируем resize после обновления таблицы
		}


	// === Обновление пагинации ===
	function updatePagination() {
	  const paginationContainer = document.getElementById('pagination');
	  if (!paginationContainer) return;
	  
	  paginationContainer.innerHTML = '';
	  
	  if (totalPages <= 1) return;
	  
	  // Кнопка "Назад"
	  const prevLi = document.createElement('li');
	  prevLi.className = `page-item ${currentPage === 1 ? 'disabled' : ''}`;
	  prevLi.innerHTML = `<a class="page-link" href="#" onclick="changePage(${currentPage - 1})">&laquo;</a>`;
	  paginationContainer.appendChild(prevLi);
	  
	  // Нумерация страниц
		const startPage = Math.max(1, currentPage - 2);
		const endPage = Math.min(totalPages, startPage + 4);
	  
		for (let i = startPage; i <= endPage; i++) {
			const pageLi = document.createElement('li');
			pageLi.className = `page-item ${i === currentPage ? 'active' : ''}`;
			pageLi.innerHTML = `<a class="page-link" href="#" onclick="changePage(${i})">${i}</a>`;
			paginationContainer.appendChild(pageLi);
			}
			  
			  // Кнопка "Вперед"
			  const nextLi = document.createElement('li');
			  nextLi.className = `page-item ${currentPage === totalPages ? 'disabled' : ''}`;
			  nextLi.innerHTML = `<a class="page-link" href="#" onclick="changePage(${currentPage + 1})">&raquo;</a>`;
			  paginationContainer.appendChild(nextLi);
			}

			// === Смена страницы ===
			function changePage(page) {
                          if (page < 1 || page > totalPages) return;

                          currentPage = page;
                          persistCurrentPageIfUnfiltered();
                          displayTicketsForCurrentPage();
                          updatePagination();
			  
			  // Прокручиваем к верху таблицы
			  document.querySelector('.table-responsive').scrollIntoView({ behavior: 'smooth' });
			}

			// === Обработчик изменения количества отображаемых заявок ===
                                document.getElementById('pageSize')?.addEventListener('change', function() {
                                  currentPageSize = parseInt(this.value);
                                  localStorage.setItem('pageSize', currentPageSize);
                                  currentPage = 1; // Сбрасываем на первую страницу
                                  const sourceLength = window.filteredTickets ? window.filteredTickets.length : allTickets.length;
                                  totalPages = ensureCurrentPageBounds(sourceLength);
                                  persistCurrentPageIfUnfiltered();
                                  if (window.filteredTickets) {
                                        displayTicketsForCurrentPageFiltered();
                                        updatePaginationFiltered();
                                  } else {
                                        displayTicketsForCurrentPage();
                                        updatePagination();
                                  }
                                });
					// Не закрывать дропдауны категорий при клике по лейблу/чекбоксу (история и закрытие)
						document.addEventListener('click', function(e) {
								  const menu = e.target.closest('.dropdown-menu');
								  if (!menu) return;
							
							// Делегированный клик по миниатюрам (у тебя класс .js-preview уже проставляется)
								document.addEventListener('click', (e) => {
								  const target = e.target.closest('.js-preview');
								  if (!target) return;
								  const full = target.getAttribute('data-fullsrc') || target.src;
								  const img = document.getElementById('imageViewerImg');
								  img.src = full;
								  new bootstrap.Modal(document.getElementById('imageViewerModal')).show();
								});
								document.addEventListener('click', function (e) {
								  const img = e.target.closest('.js-preview');
								  if (!img) return;	
								});
							// Клик по блоку "Ответ на" — перейти к исходному сообщению
							document.addEventListener('click', function (e) {
							  const box = e.target.closest('.reply-preview.rp-jump');
							  if (!box) return;

							  const targetTgId = box.getAttribute('data-target');
							  if (!targetTgId) return;

							  const target = document.querySelector(`.chat-bubble[data-tg-id="${targetTgId}"]`);
							  if (target) {
								target.scrollIntoView({ behavior: 'smooth', block: 'center' });
								target.classList.add('reply-target');
								setTimeout(() => target.classList.remove('reply-target'), 1200);
							  }
							});

						  // Клик был внутри меню категорий истории?
							if (menu.closest('#historyModal')) {
								const item = e.target.closest('.form-check');
								if (item) {
								  e.preventDefault();
								  e.stopPropagation();
								  const input = item.querySelector('input[type="checkbox"]');
								  if (input && e.target !== input) {
									input.checked = !input.checked;
								  }
								  if (typeof syncCategorySelection === 'function') {
									syncCategorySelection();
								  }
								}
							}

						  // Клик был внутри меню категорий модалки закрытия?
							if (menu.closest('#closeTicketModal')) {
								const item = e.target.closest('.form-check');
								if (item) {
								  e.preventDefault();
								  e.stopPropagation();
								  const input = item.querySelector('input[type="checkbox"]');
								  if (input && e.target !== input) {
									input.checked = !input.checked;
								  }
								  if (typeof syncCloseCategorySelection === 'function') {
									syncCloseCategorySelection();
								  }
								}
								if (selectedCategory) {
								  // категория выбрана → закрываем напрямую без второго окна
								  closeTicketDirectly(ticketId, selectedCategory);
								  return;
								}
							}
						}, true);

			  // === Загрузка статусов клиентов ===
						async function loadClientStatuses() {
							try {
								const response = await fetch('/client_statuses');
								if (response.ok) {
									return await response.json();
								}
							} catch (e) {
								console.error("Ошибка загрузки статусов клиентов:", e);
							}
							return {};
						}
			

					// === Фильтрация ===
					// === Фильтрация (применяется ко всем данным) ===
						function applyFilters() {
							const search = document.getElementById('searchInput')?.value.toLowerCase() || '';
							const status = document.getElementById('filterStatus')?.value || '';
							const user = document.getElementById('filterUser')?.value.toLowerCase() || '';
							const ticketId = document.getElementById('filterTicketId')?.value.toLowerCase() || '';
							const business = document.getElementById('filterBusiness')?.value.toLowerCase() || '';
							const location = document.getElementById('filterLocation')?.value.toLowerCase() || '';
							const responsible = document.getElementById('filterResponsible')?.value.toLowerCase() || '';
							const clientStatus = document.getElementById('filterClientStatus')?.value.toLowerCase() || '';
							const dateFrom = document.getElementById('filterDateFrom')?.value || '';
							const dateTo = document.getElementById('filterDateTo')?.value || '';

							// Фильтруем ВСЕ заявки
							const filteredTickets = allTickets.filter(t => {
								const searchIndex = [
									String(t.user_id || ''),
									String(t.ticket_id || ''),
									String(t.client_status || ''),
									String(t.channel_name || ''),
									String(t.business || ''),
									String(t.city || ''),
									String(t.location_name || ''),
									String(t.problem || ''),
									String(t.responsible || ''),
									String(t.raw_status || ''),
									String(t.status || ''),
									String(t.created_date || ''),
									String(t.created_time || ''),
									String(t.username || ''),
									String(t.client_name || '')
								].join(' ').toLowerCase();

								const createdDate = t.created_date || '';
								
								const matches = (!search || searchIndex.includes(search)) &&
											  (!status || searchIndex.includes(status)) &&
											  (!user || searchIndex.includes(user)) &&
											  (!ticketId || searchIndex.includes(ticketId)) &&
											  (!business || searchIndex.includes(business)) &&
											  (!location || searchIndex.includes(location)) &&
											  (!responsible || searchIndex.includes(responsible)) &&
											  (!clientStatus || searchIndex.includes(clientStatus)) &&
											  (!dateFrom || createdDate >= dateFrom) &&
											  (!dateTo || createdDate <= dateTo);

								return matches;
							});

							// Обновляем отображаемые данные
							displayFilteredTickets(filteredTickets);
						}

						// === Отображение отфильтрованных заявок ===
						function displayFilteredTickets(filteredTickets) {
							// Сбрасываем на первую страницу
                                                        currentPage = 1;

                                                        // Рассчитываем общее количество страниц для отфильтрованных данных
                                                        totalPages = ensureCurrentPageBounds(filteredTickets.length);

                                                        // Сохраняем отфильтрованные заявки для пагинации
                                                        window.filteredTickets = filteredTickets;
							
							// Отображаем заявки для текущей страницы
							displayTicketsForCurrentPageFiltered();
							
							// Обновляем пагинацию
							updatePaginationFiltered();
						}

						// === Отображение заявок текущей страницы (для отфильтрованных данных) ===
                                                function displayTicketsForCurrentPageFiltered() {
                                                        const container = document.getElementById('ticketsBody');
                                                        if (!container) return;

                                                        container.innerHTML = '';

                                                        // Используем отфильтрованные данные
                                                        const ticketsToDisplay = window.filteredTickets || allTickets;

                                                        totalPages = ensureCurrentPageBounds(ticketsToDisplay.length);

                                                        // Рассчитываем индексы для текущей страницы
                                                        const startIndex = (currentPage - 1) * currentPageSize;
                                                        const endIndex = Math.min(startIndex + currentPageSize, ticketsToDisplay.length);
							
							// Получаем заявки для текущей страницы
							const pageTickets = ticketsToDisplay.slice(startIndex, endIndex);
							
							if (pageTickets.length === 0) {
								container.innerHTML = '<tr><td colspan="12" class="text-center text-muted py-3">Нет заявок для отображения</td></tr>';
								return;
							}
							
							// Отрисовываем заявки (используем существующую логику отрисовки)
							pageTickets.forEach(t => {
								const username = t.username ? `@${t.username}` : 'нет юзернейма';
								const clientName = t.client_name || 'не задано';

								const row = document.createElement('tr');
								
								// Индекс для поиска (если понадобится)
								const searchIndex = [
									String(t.user_id || ''),
									String(t.ticket_id || ''),
									String(t.client_status || ''),
									String(t.channel_name || ''),
									String(t.business || ''),
									String(t.city || ''),
									String(t.location_name || ''),
									String(t.problem || ''),
									String(t.responsible || ''),
									String(t.raw_status || ''),
									String(t.status || ''),
									String(t.created_date || ''),
									String(t.created_time || ''),
									String(t.username || ''),
									String(clientName || '')
								].join(' ').toLowerCase();
								row.dataset.search = searchIndex;

								// Остальная логика отрисовки остается такой же, как в displayTicketsForCurrentPage()
								const clientCell = `
								<div class="d-flex align-items-center gap-2">
									<img src="${t.avatar_url || '/static/default-avatar.png'}" 
										 alt="" 
										 width="36" 
										 height="36" 
										 class="rounded-circle" 
										 style="object-fit:cover; border:1px solid rgba(0,0,0,.08)"
										 onerror="this.src='/static/default-avatar.png'">
									<span class="clickable-client" data-user-id="${t.user_id}" onclick="window.open('/client/${t.user_id}', '_blank')">${
									(t.client_name && t.client_name !== 'не задано') ? t.client_name :
									(t.username ? '@' + t.username : 'Клиент ' + t.user_id)
									}</span>
								</div>`;

								let statusBadge;
								if (t.raw_status === 'resolved') {
									statusBadge = `<span class="badge bg-success">✅ Решено</span>`;
								} else {
									if (t.status === 'Новая') {
										statusBadge = `<span class="badge bg-secondary">🆕 Новая</span>`;
									} else if (t.status === 'Ожидает реакции') {
										statusBadge = `<span class="badge bg-danger">⏳ Ожидает реакции</span>`;
									} else {
										statusBadge = `<span class="badge bg-info text-dark">⏳ Ожидает клиента</span>`;
									}
								}

								const unreadBadge = `<span class="badge bg-danger me-1 unread-badge" data-ticket="${t.ticket_id}" style="display:none;">0</span>`;
								statusBadge = unreadBadge + statusBadge;

								let businessClass = '';
								if (t.business === 'СушиВесла') businessClass = 'business-sushi';
								else if (t.business === 'БлинБери') businessClass = 'business-blin';

								const createTaskBtn = (t.linked_task_id)
									? `<button class="btn btn-sm btn-outline-primary open-task-btn" data-task-id="${t.linked_task_id}">
									   №DL_${t.linked_task_id}
									 </button>`
									: `<button class="btn btn-sm btn-outline-primary create-task-btn"
									   data-problem="${(t.problem||'').replace(/"/g,'&quot;')}"
									   data-location="${(t.location_name||t.city||'').replace(/"/g,'&quot;')}"
									   data-ticket="${t.ticket_id}">
									   Создать задачу
									 </button>`;

								const actionBtns = (t.raw_status !== 'resolved')
									? `<button class="btn btn-sm btn-outline-secondary" onclick="loadHistory(${t.user_id}, '${t.ticket_id}')">История</button>
									 ${createTaskBtn}
									 <button class="btn btn-sm btn-danger" onclick="confirmClose(${t.user_id}, '${t.ticket_id}')">Закрыть</button>`
									: `<button class="btn btn-sm btn-outline-secondary" onclick="loadHistory(${t.user_id}, '${t.ticket_id}')">История</button>
									 ${createTaskBtn}`;

								let rowHTML = '';
								rowHTML += `<td>${clientCell}</td>`;
								rowHTML += `<td>${t.client_status || '—'}</td>`;
								rowHTML += `<td>${t.channel_name || '—'}</td>`;
								rowHTML += `<td><code>${t.ticket_id}</code></td>`;
								rowHTML += `<td class="${businessClass}">${t.business}</td>`;
								rowHTML += `<td>${t.city}<br><small>${t.location_name}</small></td>`;
								rowHTML += `<td>${t.problem}</td>`;
								rowHTML += `<td>${t.responsible}</td>`;
								rowHTML += `<td>${statusBadge}</td>`;
								const dt = displayTicketDateTime(t);
									rowHTML += `<td>${dt.date}</td>`;
									rowHTML += `<td>${dt.time}</td>`;
								rowHTML += `<td>${actionBtns}</td>`;
								row.innerHTML = rowHTML;
								container.appendChild(row);

								// Восстановление счетчика непрочитанных
								let unread = 0;
								const lastRead = lastReadAtByTicket[t.ticket_id] || 0;
								if (unreadCountByTicket[t.ticket_id] !== undefined) {
									unread = unreadCountByTicket[t.ticket_id];
								} else {
									unread = 0;
								}
								setTicketUnread(t.ticket_id, unread);
							});
							
							parseEmojis(document.getElementById('ticketsBody'));
							applyColumnSettingsFromState();
							initColumnResize();
						}

						// === Обновление пагинации для отфильтрованных данных ===
						function updatePaginationFiltered() {
							const paginationContainer = document.getElementById('pagination');
							if (!paginationContainer) return;
							
							paginationContainer.innerHTML = '';
							
                                                        const ticketsToDisplay = window.filteredTickets || allTickets;
                                                        totalPages = ensureCurrentPageBounds(ticketsToDisplay.length);
							
							if (totalPages <= 1) return;
							
							// Кнопка "Назад"
							const prevLi = document.createElement('li');
							prevLi.className = `page-item ${currentPage === 1 ? 'disabled' : ''}`;
							prevLi.innerHTML = `<a class="page-link" href="#" onclick="changePageFiltered(${currentPage - 1})">&laquo;</a>`;
							paginationContainer.appendChild(prevLi);
							
							// Нумерация страниц
							const startPage = Math.max(1, currentPage - 2);
							const endPage = Math.min(totalPages, startPage + 4);
							
							for (let i = startPage; i <= endPage; i++) {
								const pageLi = document.createElement('li');
								pageLi.className = `page-item ${i === currentPage ? 'active' : ''}`;
								pageLi.innerHTML = `<a class="page-link" href="#" onclick="changePageFiltered(${i})">${i}</a>`;
								paginationContainer.appendChild(pageLi);
							}
							
							// Кнопка "Вперед"
							const nextLi = document.createElement('li');
							nextLi.className = `page-item ${currentPage === totalPages ? 'disabled' : ''}`;
							nextLi.innerHTML = `<a class="page-link" href="#" onclick="changePageFiltered(${currentPage + 1})">&raquo;</a>`;
							paginationContainer.appendChild(nextLi);
						}

						// === Смена страницы для отфильтрованных данных ===
						function changePageFiltered(page) {
							if (page < 1 || page > totalPages) return;
							
							currentPage = page;
							displayTicketsForCurrentPageFiltered();
							updatePaginationFiltered();
							
							// Прокручиваем к верху таблицы
							document.querySelector('.table-responsive').scrollIntoView({ behavior: 'smooth' });
						}

						// === Сброс фильтров ===
						function resetFilters() {
							  // Сбрасываем значения фильтров (только существующие элементы)
							  const filterIds = [
								'searchInput', 'filterStatus', 'filterUser', 'filterTicketId', 
								'filterBusiness', 'filterLocation', 'filterClientStatus', 
								'filterResponsible', 'filterDateFrom', 'filterDateTo'
							  ];
							  
							  filterIds.forEach(id => {
								const element = document.getElementById(id);
								if (element) {
								  element.value = '';
								}
							  });
							  
							  // Возвращаемся к отображению всех заявок
                                                          currentPage = 1;
                                                          window.filteredTickets = null;
                                                          totalPages = ensureCurrentPageBounds(allTickets.length);
                                                          persistCurrentPageIfUnfiltered();
                                                          displayTicketsForCurrentPage();
                                                          updatePagination();
                                                }

   // === Обновляем обработчики событий ===
		document.addEventListener('DOMContentLoaded', function() {
		  // Обработчики для основных фильтров (теперь применяются ко всем данным)
		  const searchInput = document.getElementById('searchInput');
		  if (searchInput) searchInput.addEventListener('input', applyFilters);
		  
		  // Добавьте обработчики для остальных фильтров аналогично
		  const filterStatus = document.getElementById('filterStatus');
		  if (filterStatus) filterStatus.addEventListener('change', applyFilters);
		  
		  const filterUser = document.getElementById('filterUser');
		  if (filterUser) filterUser.addEventListener('input', applyFilters);
		  
		  const filterTicketId = document.getElementById('filterTicketId');
		  if (filterTicketId) filterTicketId.addEventListener('input', applyFilters);
		  
		  const filterBusiness = document.getElementById('filterBusiness');
		  if (filterBusiness) filterBusiness.addEventListener('input', applyFilters);
		  
		  const filterLocation = document.getElementById('filterLocation');
		  if (filterLocation) filterLocation.addEventListener('input', applyFilters);
		  
		  const filterClientStatus = document.getElementById('filterClientStatus');
		  if (filterClientStatus) filterClientStatus.addEventListener('input', applyFilters);
		  
		  const filterDateFrom = document.getElementById('filterDateFrom');
		  if (filterDateFrom) filterDateFrom.addEventListener('input', applyFilters);
		  
		  const filterDateTo = document.getElementById('filterDateTo');
		  if (filterDateTo) filterDateTo.addEventListener('input', applyFilters);
		  
		  const filterResponsible = document.getElementById('filterResponsible');
		  if (filterResponsible) filterResponsible.addEventListener('input', applyFilters);
		});

    // Обработчик изменения количества отображаемых заявок
		document.addEventListener('DOMContentLoaded', () => {
		  // initSendKeySettings уже выполнился через IIFE, повторный вызов не нужен
		  autoRefreshTickets();
		  setInterval(autoRefreshTickets, 5000);

		const chat = document.getElementById('historyContent');
		chat.addEventListener('click', async (e) => {
		  const bubble = e.target.closest('.chat-bubble');
		  
		  if (!bubble) return;
		  const tgId = bubble.getAttribute('data-tg-id');
		  const isSupport = bubble.getAttribute('data-sender') === 'support';

		  // Переход к родительскому сообщению (из превью)
			// Клик по блоку превью ответа — плавный скролл к оригиналу
				const rpEl = e.target.closest('.reply-preview.rp-jump');
				if (rpEl) {
				  e.preventDefault();
				  const targetId = rpEl.getAttribute('data-target');
				  if (targetId) {
					const target = document.querySelector(`.chat-bubble[data-tg-id="${CSS.escape(targetId)}"]`);
					if (target) {
					  target.scrollIntoView({ behavior: 'smooth', block: 'center' });
					  target.classList.add('reply-target');
					  setTimeout(() => target.classList.remove('reply-target'), 1500);
					} else {
					  alert('Оригинальное сообщение не найдено в текущей странице истории');
					}
				  }
				  return;
				}

		   // Ответить (жёстко привязываемся к Telegram message_id)
			if (e.target.classList.contains('action-reply')) {
					   const midAttr = bubble.getAttribute('data-mid');   // <= ТОЛЬКО это поле
					   const mid = midAttr ? parseInt(midAttr, 10) : NaN;
					   window.currentReplyToTgId = Number.isFinite(mid) ? mid : null;
					   const ta = document.getElementById('replyTextInHistory');
					   ta.focus();
					   showReplyChip(
						 bubble.querySelector('.msg-text')?.innerText || 'сообщение',
						 window.currentReplyToTgId
					   );
						showReplyPreview(bubble.querySelector('.msg-text')?.textContent || '', window.currentReplyToTgId);
					 }

				  // Редактировать
				  if (e.target.classList.contains('action-edit') && isSupport && tgId) {
					window.currentEditTgId = parseInt(tgId, 10);
					// Подсветим редактируемый пузырь
					document.querySelector('.chat-bubble.editing')?.classList.remove('editing');
					bubble.classList.add('editing');
					window.currentReplyToTgId = null;
					const ta = document.getElementById('replyTextInHistory');
					ta.value = bubble.querySelector('.msg-text')?.innerText || '';
					ta.focus();
					showEditChip();
				  }
					  // Скачать вложение (если есть)
					  if (e.target.classList.contains('action-download')) {
						const link = bubble.querySelector('.media-download');
						if (link) link.click();
					  }

				  // Удалить
				  if (e.target.classList.contains('action-delete') && isSupport && tgId) {
					if (!confirm('Удалить сообщение?')) return;
					const fd = new FormData();
						fd.append('user_id',       String(currentUserId));
						fd.append('ticket_id',     String(currentTicketId));
						fd.append('tg_message_id', String(parseInt(tgId, 10)));

						const resp = await fetch('/message_delete', {
						  method: 'POST',
						  body: fd
						});
					const data = await resp.json();
					if (!data.success) return alert('❌ Не удалось удалить: '+(data.error||''));
					if (data.deleted_on_client) {
					  bubble.insertAdjacentHTML('beforeend', `<div class="badge-meta">удалено у клиента</div>`);
					}
					bubble.classList.add('opacity-50');
					bubble.querySelector('.bubble-actions')?.remove();
				  }
				});

				// «чипы» над textarea
				window.showReplyChip = function showReplyChip(title, targetTgId){
				  setChip(`↩ Ответ на: <a href="#" id="chipJump">«${title.slice(0,60)}…»</a>`, true, targetTgId);
			}
		window.showEditChip = function showEditChip(){
		  setChip(`✏️ Редактирование сообщения`, false, null);
		}
		window.clearChip = function clearChip(){
		  const chip = document.getElementById('composeChip');
		  if (chip) chip.remove();
		  // Снять спец-подсветку с редактируемого пузыря (если осталась)
		  document.querySelector('.chat-bubble.editing')?.classList.remove('editing');
		};
		window.setChip = function setChip(html, isReply, targetTgId){
		  clearChip();
		  const wrap = document.querySelector('.input-group-send');
		  const chip = document.createElement('div');
		  chip.id = 'composeChip';
		  chip.className = 'small text-muted px-2';
		  chip.innerHTML = `${html} <button class="btn btn-link btn-sm p-0">✖</button>`;
		  chip.querySelector('button').onclick = ()=>{
			window.currentReplyToTgId = null;
			window.currentEditTgId = null;
			clearChip();
		  };

		  // клик по ссылке в чипе — перейти к сообщению
		  const jump = chip.querySelector('#chipJump');
		  if (jump && targetTgId) {
			jump.addEventListener('click', (ev)=>{
			  ev.preventDefault();
			  const target = document.querySelector(`.chat-bubble[data-tg-id="${targetTgId}"]`);
			  if (target) {
				target.scrollIntoView({behavior:'smooth', block:'center'});
				target.classList.add('reply-target');
				setTimeout(()=>target.classList.remove('reply-target'), 1200);
			  }
			});
		  }
		  wrap.prepend(chip);
		}
		  
		// Восстанавливаем настройки столбцов
		setTimeout(() => {
		  applyColumnSettingsFromState(); // просто применяем из columnSettings
		  restoreColumnWidths();
		}, 100);
  
		window.addEventListener('beforeunload', saveColumnWidths);
  
		let resizeTimer;
		window.addEventListener('resize', () => {
			clearTimeout(resizeTimer);
			resizeTimer = setTimeout(() => {
				applyColumnSettings();
				initColumnResize();
			}, 250);
		});
	});

	// === Функция принудительного обновления истории ===	
	async function updateHistory() {
		try {
			const qs = new URLSearchParams({
				user_id: String(currentUserId),
				ticket_id: String(currentTicketId),
				_: String(Date.now())
			});
			
			if (window.currentChannelId != null && window.currentChannelId !== '' && window.currentChannelId !== 'null') {
				qs.set('channel_id', String(window.currentChannelId));
			}

			const resp = await fetch(`/history?${qs.toString()}`, { cache: 'no-store' });
			const data = await resp.json();

			const container = document.getElementById('historyContent');
			const clientData = window.currentClientData || allTickets.find(
				t => t.user_id == currentUserId && t.ticket_id == currentTicketId
			);

			// 1) берем массив из ответа
			const msgs = (data.messages || []).slice();

			// 2) стабильная сортировка с тем же алгоритмом, что и в loadHistory
			msgs.sort((a, b) => {
				const ta = sortTsMs(a);
				const tb = sortTsMs(b);
				
				if (ta !== tb) return ta - tb;

				const am = Number(telegramMid(a) || 0);
				const bm = Number(telegramMid(b) || 0);
				if (am !== bm) return am - bm;

				const as = isSupportMsg(a) ? 1 : 0;
				const bs = isSupportMsg(b) ? 1 : 0;
				return as - bs;
			});

			// 3) ВАЖНО: полностью очищаем и перезаполняем renderedMsgIds
			renderedMsgIds.clear();
			msgs.forEach(m => renderedMsgIds.add(msgKey(m)));

			// 4) рендер строго отсортированного массива
			container.innerHTML = renderMessagesHTML(currentTicketId, msgs, clientData);
			parseEmojis(container);

			// 5) обновляем метки и наблюдатели
			if (msgs.length > 0) {
				lastRenderedAt = msgs[msgs.length - 1].timestamp;
			} else {
				lastRenderedAt = null;
			}
			
			setupReadObserver();
			watchUserBubbles();
			recalcTicketUnreadFromDOM(currentTicketId);

		} catch (error) {
			console.error('Ошибка при обновлении истории:', error);
		}
	}

	
	// Делаем доступной глобально
	window.updateHistory = updateHistory;

	// === Загрузить историю ===
		async function loadHistory(user_id, ticket_id) {
			try { 
				await fetch(`/api/tickets/${ticket_id}/active`, {method:'POST', credentials:'same-origin'}); 
			} catch(e){}

			try {
				// Загружаем данные КОНКРЕТНОЙ заявки
				const [ticketsResp, ticketResp] = await Promise.all([
					fetch('/tickets_list'),
					fetch(`/tickets/${ticket_id}`)
				]);

				const [allTickets, ticketFull] = await Promise.all([
					ticketsResp.json(),
					ticketResp.json()
				]);

				const qs = new URLSearchParams({
					user_id: String(user_id),
					ticket_id: String(ticket_id),
					_: String(Date.now())
				});
				
				if (window.currentChannelId && Number(window.currentChannelId) > 0) {
					qs.set('channel_id', Number(window.currentChannelId));
				}

				const historyResp = await fetch(`/history?${qs.toString()}`, { cache: 'no-store' });
				const historyData = await historyResp.json();

				currentUserId = user_id;
				currentTicketId = ticket_id;

				// Ищем данные клиента в полученных тикетах
				const clientData = allTickets.find(t => t.user_id == user_id && t.ticket_id == ticket_id);
				if (clientData && ticketFull) {
						if (!clientData.client_name && ticketFull.client_name) clientData.client_name = ticketFull.client_name;
						if (!clientData.username && ticketFull.username) clientData.username = ticketFull.username;
				}
				window.currentClientData = clientData || {};
				window.currentChannelId = clientData?.channel_id ?? null;

				const avaEl = document.getElementById('clientAvatarInHistory');
				if (avaEl) {
						const fallbackAvatar = '/static/default-avatar.png';
						const avatarCandidates = [
								clientData?.avatar_full_url,
								clientData?.avatar_url,
								ticketFull?.avatar_full_url,
								ticketFull?.avatar_url,
								clientData?.avatar,
								ticketFull?.avatar,
								`/avatar/${currentUserId}`
						];

						let avatarSrc = '';
						for (const candidate of avatarCandidates) {
								const normalized = normalizeAvatarUrl(candidate);
								if (normalized) { avatarSrc = normalized; break; }
						}
						if (!avatarSrc) avatarSrc = fallbackAvatar;

						let fullSrc = '';
						const fullCandidates = [
								clientData?.avatar_full_url,
								ticketFull?.avatar_full_url,
								avatarSrc === fallbackAvatar ? '' : avatarSrc
						];
						for (const candidate of fullCandidates) {
								const normalized = ensureFullAvatarUrl(candidate);
								if (normalized) { fullSrc = normalized; break; }
						}
						if (!fullSrc) fullSrc = avatarSrc;

						avaEl.src = avatarSrc;
						avaEl.dataset.fullsrc = fullSrc;
						avaEl.alt = 'Аватар клиента';
						avaEl.onerror = () => {
								avaEl.onerror = null;
								avaEl.src = fallbackAvatar;
								avaEl.dataset.fullsrc = fallbackAvatar;
						};
				}

				const messages = historyData.messages || [];
				
				// ВАЖНОЕ ИСПРАВЛЕНИЕ: Полностью очищаем renderedMsgIds перед загрузкой новой истории
				renderedMsgIds.clear();
				
				// Стабильная сортировка с приоритетом временных меток
				const msgs = messages.slice();
				msgs.sort((a, b) => {
					const ta = sortTsMs(a);
					const tb = sortTsMs(b);
					
					// Сначала по времени (основной критерий)
					if (ta !== tb) return ta - tb;
					
					// При одинаковом времени - по ID телеграм сообщения
					const am = Number(telegramMid(a) || 0);
					const bm = Number(telegramMid(b) || 0);
					if (am !== bm) return am - bm;
					
					// При полной ничьей - клиент раньше оператора
					const as = isSupportMsg(a) ? 1 : 0;
					const bs = isSupportMsg(b) ? 1 : 0;
					return as - bs;
				});

				// Заполняем renderedMsgIds ОТСОРТИРОВАННЫМИ сообщениями
				msgs.forEach(m => {
					renderedMsgIds.add(msgKey(m));
				});
				
				// И устанавливаем время последнего просмотра
				lastSeenAt = new Date();

				// Отображаем проблему (ограничение 100ch + полный текст в title)
				const problem = clientData?.problem || 'Не указана';
				const problemEl = document.getElementById('problemText');
				problemEl.textContent = problem;
				problemEl.title = problem;

				// Читаемый статус для правого блока
				const statusText =
					ticketFull.status === 'resolved' ? 'Решено' :
					(ticketFull.status === 'pending' || ticketFull.status === 'in_progress') ? 'В обработке' :
					(ticketFull.status || '—');

				// === ВРЕМЕННЫЕ МЕТРИКИ (СООТВЕТСТВУЮТ ВАШЕЙ ЛОГИКЕ) ===
				// "Создана" — когда заявка попала в список заявок.
				// 1) Пытаемся взять ticket.created_at (от бэка); 2) иначе — первое сообщение клиента.
                                let createdAt = parseDateFromAny(ticketFull.created_at || ticketFull.createdAt);
                                if (!createdAt) {
                                        const firstUserMsg = messages.find(m => !isSupportMsg(m) && messageDate(m));
                                        createdAt = firstUserMsg ? messageDate(firstUserMsg) : null;
                                }

                                // "Первый ответ оператора" — первое сообщение support
                                const firstSupportMsg = messages.find(m => isSupportMsg(m) && messageDate(m));
                                const firstReply = firstSupportMsg ? messageDate(firstSupportMsg) : null;

                                // "Завершение" — resolved_at от бэка
                                const resolvedAt = parseDateFromAny(ticketFull.resolved_at || ticketFull.resolvedAt);

				// "Время до ответа" — от создания (createdAt) до первого ответа (firstReply)
				const timeToFirstReply = (createdAt && firstReply) ? diffHMin(createdAt, firstReply) : '—';

				// "Общее время" — время работы оператора: от первого ответа до завершения
				const totalWorkTime = (firstReply && resolvedAt) ? diffHMin(firstReply, resolvedAt) : '—';

				// Формируем HTML для блока "Время обращения"
				const info = document.getElementById('timeInfo');
				info.innerHTML = `
					<div id="timeCounter" style="font-size: 1.2em; font-weight: bold; margin-bottom: 8px;"></div>
					<div id="timeDetails" style="font-size: 0.95em; line-height: 1.6;">
						<div><strong>Статус:</strong> ${statusText}</div>
						<div><strong>Создана:</strong> ${formatRuDate(createdAt)}</div>
						<div><strong>Первый ответ оператора:</strong> ${formatRuDate(firstReply)}</div>
						<div><strong>Время до ответа:</strong> ${timeToFirstReply}</div>
						<div><strong>Завершение:</strong> ${formatRuDate(resolvedAt)}</div>
						<div><strong>Общее время:</strong> ${totalWorkTime}</div>
					</div>
				`;
				
				// первичный рендер всей ленты (и оператора, и клиента)
				const container = document.getElementById('historyContent');
				const html = renderMessagesHTML(ticket_id, msgs, clientData);
				window.currentChannelId = clientData?.channel_id ?? null;
				container.innerHTML = html || '<p class="text-muted">Нет сообщений</p>';
				container.scrollTop = container.scrollHeight;
				parseEmojis(container);

				ensureHistoryScrollButtons();

				// Устанавливаем lastRenderedAt на основе ОТСОРТИРОВАННОГО массива
				lastRenderedAt = msgs.length ? msgs[msgs.length - 1].timestamp : null;

				setupReadObserver();
				watchUserBubbles();
				recalcTicketUnreadFromDOM(currentTicketId);

				// Полный текст для ховера на блоке "Время обращения"
				const timeInfo = document.getElementById('timeInfo');
				const tooltipText = [
					`Статус: ${statusText}`,
					`Создана: ${formatRuDate(createdAt)}`,
					`Первый ответ оператора: ${formatRuDate(firstReply)}`,
					`Время до ответа: ${timeToFirstReply}`,
					`Завершение: ${formatRuDate(resolvedAt)}`,
					`Общее время: ${totalWorkTime}`
				].join('\n');
				timeInfo.title = tooltipText;

				// === ЖИВОЙ ТАЙМЕР (только если заявка НЕ закрыта): показываем, сколько прошло с момента "Создана" до сейчас
				if (ticketFull.status !== 'resolved' && createdAt) {
					const timerEl = info.querySelector('#timeCounter');
					const updateTimer = () => {
						const now = new Date();
						timerEl.textContent = diffHMin(createdAt, now);
					};
					updateTimer(); // первый вызов
					if (window.timeUpdateInterval) clearInterval(window.timeUpdateInterval);
					window.timeUpdateInterval = setInterval(updateTimer, 60000);
				} else {
					const timerEl = info.querySelector('#timeCounter');
					if (timerEl) timerEl.textContent = '';
					if (window.timeUpdateInterval) clearInterval(window.timeUpdateInterval);
				}

				// Обновляем состояние кнопки закрытия
				const closeButton = document.getElementById('closeTicketBtn');
				const isResolved = ticketFull.status === 'resolved';
				if (closeButton) {
					if (isResolved) {
						closeButton.disabled = true;
						closeButton.classList.add('disabled');
						closeButton.title = 'Заявка уже закрыта';
					} else {
						closeButton.disabled = false;
						closeButton.classList.remove('disabled');
						closeButton.title = '';
					}
				}

				// Загружаем текущую категорию заявки
				try {
					const respCat = await fetch(`/tickets/${ticket_id}/category`);
					const dataCat = await respCat.json();
					if (dataCat.category) setCategorySelection(dataCat.category);
				} catch (error) {
					console.error("Ошибка загрузки категории:", error);
				}

				// Обновляем заголовок: ID заявки
				document.getElementById('ticketIdDisplay').textContent = ticket_id;

				// Отображение имени клиента и статуса
				const displayName = clientData?.client_name || clientData?.username || 'Клиент';
				document.getElementById('clientDisplayName').textContent = displayName;
				document.getElementById('clientStatusDisplay').textContent = clientData?.client_status || '—';

				// Отображаем проблему (ещё раз — вдруг обновилась)
				document.getElementById('problemText').textContent = clientData?.problem || 'Не указана';

				// Клик по карандашу → редактирование имени
				document.getElementById('editClientBtn').onclick = function () {
					document.getElementById('clientNameInput').value = clientData?.client_name || '';
					document.getElementById('clientUsernameInput').value = clientData?.username || '';
					new bootstrap.Modal(document.getElementById('editClientNameModal')).show();
				};

				// Устанавливаем маркер последнего отрисованного сообщения
				lastRenderedAt = messages.length ? messages[messages.length - 1].timestamp : null;
				
				// обновляем бейдж непрочитанных от клиента после прихода свежих данных
				const lastRead = lastReadAtByTicket[currentTicketId] || 0;
				const unread = (historyData.messages || []).filter(
					m => m.sender === 'user' && new Date(m.timestamp).getTime() > lastRead
				).length;
				setUnread(unread);

				// Показать модальное окно
                                const modal = new bootstrap.Modal(document.getElementById('historyModal'));
                                historyModalIsOpen = true;
                                modal.show();

				// после первичного рендера истории:
					const chatEl = document.getElementById('historyContent');

				// если оператор доскроллил до низа — обнуляем непрочитанные
				chatEl.addEventListener('scroll', () => {
				  if (isAtBottom(chatEl)) {
					lastSeenAt = new Date();
					lastReadAtByTicket[currentTicketId] = Date.now();
					localStorage.setItem('lastReadAtByTicket', JSON.stringify(lastReadAtByTicket));
					setUnread(0);
					setTicketUnread(currentTicketId, 0);
				  }
				}, { passive: true });

                                document.getElementById('historyModal').addEventListener('hidden.bs.modal', () => {
                                  historyModalIsOpen = false;
                                  // НЕ сбрасываем счётчики — только останавливаем поллинг
                                  if (window.timeUpdateInterval) {
                                        clearInterval(window.timeUpdateInterval);
					window.timeUpdateInterval = null;
				  }
				  if (historyPolling) {
					clearInterval(historyPolling);
					historyPolling = null;
				  }
				});

				// === Автообновление истории (инкрементально) ===
				if (historyPolling) clearInterval(historyPolling);
					historyPolling = setInterval(async () => {
					  try {
						const resp = await fetch(`/history?user_id=${currentUserId}&ticket_id=${currentTicketId}&channel_id=${window.currentChannelId ?? ''}&_=${Date.now()}`, { cache: 'no-store' });
						const dataUp = await resp.json();
						const container = document.getElementById('historyContent');
						const msgs = dataUp.messages || [];

						const newOnes = msgs.filter(m => !renderedMsgIds.has(msgKey(m)));
						if (!newOnes.length) return;

						const wasAtBottom = isAtBottom(container);

						const html = renderMessagesHTML(currentTicketId, newOnes, window.currentClientData || null);
						container.insertAdjacentHTML('beforeend', html);
						parseEmojis(container);
						watchUserBubbles();
						recalcTicketUnreadFromDOM(currentTicketId);
						ensureHistoryScrollButtons();

						newOnes.forEach(m => renderedMsgIds.add(msgKey(m)));
						lastRenderedAt = newOnes[newOnes.length - 1].timestamp;

						if (wasAtBottom) {
						  scrollToBottom(container);
						  lastSeenAt = new Date();
						  lastReadAtByTicket[currentTicketId] = Date.now();
						  localStorage.setItem('lastReadAtByTicket', JSON.stringify(lastReadAtByTicket));
						  setUnread(0);
						} else {
						  const inc = newOnes.filter(m => String(m.sender).toLowerCase() === 'user').length;
						  if (inc) setUnread(unreadCount + inc);
						}
					  } catch (e) {
						console.error(e);
					  }
					}, 3000);

			} catch (error) {
				console.error("Ошибка при загрузке истории:", error);
				alert("Не удалось загрузить историю заявки");
			}
		}
	function _sizeHistoryHeights() {
		  const modal = document.getElementById('historyModal');
		  if (!modal) return;
		  const hdr = modal.querySelector('.modal-header');
		  const ftr = modal.querySelector('.modal-footer');
		  modal.style.setProperty('--hdr-h', (hdr?.offsetHeight || 0) + 'px');
		  modal.style.setProperty('--ftr-h', (ftr?.offsetHeight || 0) + 'px');
		}

                document.getElementById('historyModal').addEventListener('shown.bs.modal', () => {
                  historyModalIsOpen = true;
                  _sizeHistoryHeights();
                  // пересчитываем при ресайзе и изменении высоты футера (textarea растёт)
                  new ResizeObserver(_sizeHistoryHeights).observe(document.getElementById('historyModal'));
		  window.addEventListener('resize', _sizeHistoryHeights, { passive: true });
		});

		// Открытие превью изображения по клику на миниатюру .js-preview
		  document.addEventListener('click', function (e) {
			const img = e.target.closest('.js-preview');
			if (!img) return;

			const full = img.getAttribute('data-fullsrc') || img.src;
			const modalEl = document.getElementById('imagePreviewModal');
			document.getElementById('imagePreviewFull').src = full;
			document.getElementById('imageDownloadLink').href = full;

			const bsModal = bootstrap.Modal.getOrCreateInstance(modalEl);
			bsModal.show();
		  });
			// Обработчик события скрытия модального окна
                                document.getElementById('historyModal').addEventListener('hidden.bs.modal', function () {
                                        historyModalIsOpen = false;
                                        if (window.timeUpdateInterval) {
                                                clearInterval(window.timeUpdateInterval);
                                                window.timeUpdateInterval = null;
					}
					if (historyPolling) {
						clearInterval(historyPolling);
						historyPolling = null;
					}
				});

		// === Обновление счетчика времени ===
			function updateTimeCounter(ticketData) {
				if (!ticketData || !ticketData.created_date || !ticketData.created_time) {
					document.getElementById('timeCounter').textContent = 'Данные о времени отсутствуют';
					document.getElementById('timeDetails').textContent = '';
					return;
				}

				try {
					// Создаем дату создания заявки
					const [year, month, day] = ticketData.created_date.split('-');
					const [hours, minutes, seconds] = ticketData.created_time.split(':');
					const createdDate = new Date(year, month - 1, day, hours, minutes, seconds);
		
					const now = new Date();
					const diffMs = now - createdDate;
					const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
					const diffHours = Math.floor((diffMs % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
					const diffMinutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
		
					// Форматируем время
					let timeText = '';
					if (diffDays > 0) timeText += `${diffDays}д `;
					if (diffHours > 0) timeText += `${diffHours}ч `;
					timeText += `${diffMinutes}м`;
		
					document.getElementById('timeCounter').textContent = timeText;
		
					// Детальная информация
					const createdFormatted = createdDate.toLocaleString('ru-RU');
					const nowFormatted = now.toLocaleString('ru-RU');
					document.getElementById('timeDetails').innerHTML = `
					Создана: ${createdFormatted}<br>
					Текущее время: ${nowFormatted}
					`;
		
				} catch (error) {
					console.error("Ошибка расчета времени:", error);
					document.getElementById('timeCounter').textContent = 'Ошибка расчета';
					document.getElementById('timeDetails').textContent = '';
				}
			}
	// Функция для создания правильного URL медиафайла
		// Функция для создания правильного URL медиафайла
	function getMediaUrl(ticket_id, filename) {
		// Убираем путь из filename, если он есть
		const cleanFilename = filename.split('/').pop();
		return `/media/${ticket_id}/${cleanFilename}`;
	}

	// Функция для создания HTML медиафайла с улучшенным отображением (добавлены animation и sticker)
		function createMediaHtml(ticket_id, mediaInfo) {
			  const { message_type, attachment, text } = mediaInfo;
			  const filename = (attachment || '').split('/').pop();
			  const mediaUrl = getMediaUrl(ticket_id, filename);
			  const ext = (filename.split('.').pop() || '').toLowerCase();

			  // Иконка + лейбл типа медиа
			  const typeLabel = {
				photo:     '🖼 ФОТО',
				video:     '🎥 ВИДЕО',
				animation: '🎞 АНИМАЦИЯ',
				sticker:   '🧩 СТИКЕР',
				document:  '📄 ДОКУМЕНТ',
				voice:     '🎤 ГОЛОСОВОЕ'
			  }[message_type] || '📎 МЕДИА';

			  // Вспомогательная обёртка: иконка скачивания в правом верхнем углу
			  const wrap = (inner) => `
				<div class="mt-2 media-wrap">
				  <a class="media-download" href="${mediaUrl}" download title="Скачать оригинал">⤓</a>
				  ${inner}
				  <div class="media-type mt-1">${typeLabel}</div>
				  ${text ? `<div class="media-caption mt-1">${text}</div>` : ''}
				</div>
			  `;

			  if (message_type === 'photo') {
				return wrap(`
				  <img src="${mediaUrl}"
					   data-fullsrc="${mediaUrl}"
					   loading="lazy" decoding="async"
					   class="img-thumbnail js-preview"
					   style="max-width: 100%; max-height: 400px; border-radius: 8px; cursor: zoom-in;"
					   alt="Фото">
				`);
			  }

			  if (message_type === 'video') {
				return wrap(`
				  <video controls
						 class="img-thumbnail"
						 style="max-width: 100%; max-height: 300px; border-radius: 8px;">
					<source src="${mediaUrl}">
					Ваш браузер не поддерживает видео.
				  </video>
				`);
			  }

			  if (message_type === 'animation') {
				return wrap(`
				  <video autoplay loop muted playsinline controls
						 class="img-thumbnail"
						 style="max-width: 100%; max-height: 320px; border-radius: 8px;">
					<source src="${mediaUrl}">
					Ваш браузер не поддерживает видео.
				  </video>
				`);
			  }

			  if (message_type === 'sticker') {
				if (ext === 'webp') {
				  return wrap(`<img src="${mediaUrl}" alt="Стикер" style="max-width:160px; height:auto;">`);
				} else if (ext === 'webm') {
				  return wrap(`
					<video autoplay loop muted playsinline style="max-width:160px; border-radius:8px;">
					  <source src="${mediaUrl}">
					</video>
				  `);
				} else {
				  return wrap(`<a href="${mediaUrl}" target="_blank">Стикер</a>`);
				}
			  }

			  if (message_type === 'document') {
				return wrap(`
				  <div class="d-flex align-items-center gap-2">
					<span class="small text-muted">${filename}</span>
				  </div>
				`);
			  }

			  if (message_type === 'voice') {
				return wrap(`
				  <audio controls style="width: 100%;" class="mb-1">
					<source src="${mediaUrl}">
					Ваш браузер не поддерживает аудио.
				  </audio>
				`);
			  }

			  // по умолчанию — ссылка
			  if (attachment) {
				return wrap(`<a href="${mediaUrl}" target="_blank" class="text-muted">[медиа]</a>`);
			  }
			  return '';
		}


        // === ХЕЛПЕРЫ ДЛЯ ФОРМАТИРОВАНИЯ ДАТ И РАЗНИЦ ===
        function parseDateFromAny(value) {
                if (!value) return null;
                const iso = normalizeToISO(value);
                const d = new Date(iso);
                return isNaN(d) ? null : d;
        }

        function messageDate(msg) {
                if (!msg) return null;
                return parseDateFromAny(msg.timestamp ?? msg.date ?? msg.created_at ?? msg.createdAt ?? null);
        }

        function formatRuDate(d) {
                if (!(d instanceof Date) || isNaN(d)) return '—';
		const dd = String(d.getDate()).padStart(2,'0');
		const mm = String(d.getMonth()+1).padStart(2,'0');
		const yyyy = d.getFullYear();
		const hh = String(d.getHours()).padStart(2,'0');
		const mi = String(d.getMinutes()).padStart(2,'0');
		const ss = String(d.getSeconds()).padStart(2,'0');
		return `${dd}.${mm}.${yyyy}, ${hh}:${mi}:${ss}`;
	}

	function diffHMin(from, to) {
		if (!(from instanceof Date) || isNaN(from) || !(to instanceof Date) || isNaN(to)) return '—';
		const mins = Math.max(0, Math.round((to - from) / 60000));
		const h = Math.floor(mins / 60);
		const m = mins % 60;
		return `${h} ч ${m} мин`;
	}

	function safeParseISO(s) {
		if (!s) return null;
		const d = new Date(s);
		return isNaN(d) ? null : d;
	}
		
        const CATEGORY_COLOR_PALETTE = [
          '#0d6efd', '#6610f2', '#6f42c1', '#d63384', '#dc3545',
          '#fd7e14', '#20c997', '#198754', '#0dcaf0', '#343a40'
        ];

        function categoryColor(name = '') {
          if (!name) return CATEGORY_COLOR_PALETTE[0];
          let hash = 0;
          for (let i = 0; i < name.length; i++) {
            hash = (hash << 5) - hash + name.charCodeAt(i);
            hash |= 0;
          }
          const index = Math.abs(hash) % CATEGORY_COLOR_PALETTE.length;
          return CATEGORY_COLOR_PALETTE[index];
        }

        function renderCategoryBadges(container, categories, label = 'Выбрано:') {
          if (!container) return;
          if (!Array.isArray(categories) || categories.length === 0) {
            container.innerHTML = '';
            container.removeAttribute('title');
            container.classList.remove('has-categories');
            return;
          }

          const chips = categories.map(cat => {
            const rawCat = String(cat || '');
            const safeCat = escapeHtml(rawCat);
            const color = categoryColor(rawCat);
            return `<span class="category-chip" style="--chip-color:${color}">${safeCat}</span>`;
          }).join('');

          const labelHtml = label ? `<span class="selected-label text-muted me-2">${label}</span>` : '';
          container.innerHTML = `${labelHtml}${chips}`;
          container.title = categories.join(', ');
          container.classList.add('has-categories');
        }

// === Синхронизация категорий из истории в окно закрытия ===
		function syncCloseCategoriesFromHistory() {
			// Получаем выбранные категории из истории
				const historyCheckboxes = document.querySelectorAll('.category-checkbox:checked');
				const selectedValues = Array.from(historyCheckboxes).map(cb => cb.value);
	  
			// Устанавливаем те же категории в окне закрытия
				document.querySelectorAll('.close-category-checkbox').forEach(checkbox => {
					checkbox.checked = selectedValues.includes(checkbox.value);
				});
	  
			// Обновляем отображение выбранных категорий
				syncCloseCategorySelection();
		}

		// === Синхронизация выбора категорий в модальном окне закрытия ===
		function syncCloseCategorySelection() {
			const checkboxes = document.querySelectorAll('.close-category-checkbox:checked');
			const select = document.getElementById('closeCategorySelect');
			const selectedContainer = document.getElementById('closeSelectedCategories');
	  
			// Очищаем текущий выбор
				Array.from(select.options).forEach(option => {
					option.selected = false;
				});
	  
			// Обновляем выбранные элементы
				const selectedValues = [];
				checkboxes.forEach(checkbox => {
					const value = checkbox.value;
					const option = Array.from(select.options).find(opt => opt.value === value);
					if (option) {
						option.selected = true;
						selectedValues.push(value);
					}
				});
	  
			// Обновляем отображение выбранных категорий
                                renderCategoryBadges(selectedContainer, selectedValues);
                                const closeDropdown = document.getElementById('closeCategoryDropdown');
                                if (closeDropdown) {
                                        closeDropdown.textContent = selectedValues.length > 0
                                          ? `Выбрано: ${selectedValues.length} категорий`
                                          : 'Выберите категории...';
                                }
	  
			return selectedValues;
		}

		// === Синхронизация категорий из истории (для основного select) ===
		function syncCategorySelection() {
			const checkboxes = document.querySelectorAll('.category-checkbox:checked');
			const select = document.getElementById('ticketCategorySelect');
			const selectedContainer = document.getElementById('selectedCategories');
	  
			// Очищаем текущий выбор
				Array.from(select.options).forEach(option => {
					option.selected = false;
				});
	  
			// Обновляем выбранные элементы
				const selectedValues = [];
				checkboxes.forEach(checkbox => {
					const value = checkbox.value;
					const option = Array.from(select.options).find(opt => opt.value === value);
					if (option) {
						option.selected = true;
						selectedValues.push(value);
					}
				});
	  
			// Обновляем отображение выбранных категорий
                                renderCategoryBadges(selectedContainer, selectedValues);
                                const historyDropdown = document.getElementById('categoryDropdown');
                                if (historyDropdown) {
                                        historyDropdown.textContent = selectedValues.length > 0
                                          ? `Выбрано: ${selectedValues.length} категорий`
                                          : 'Выберите категории...';
                                }
	  
			return selectedValues;
		}

		// === Установка выбранных категорий ===
		function setCategorySelection(categories) {
			if (!categories) return;
	  
			const categoryArray = Array.isArray(categories) ? categories : categories.split(',').map(cat => cat.trim());
	  
			// Сбрасываем все чекбоксы
				document.querySelectorAll('.category-checkbox').forEach(checkbox => {
					checkbox.checked = false;
				});
	  
			// Устанавливаем выбранные категории
				categoryArray.forEach(cat => {
					const checkbox = document.querySelector(`.category-checkbox[value="${cat}"]`);
					if (checkbox) {
						checkbox.checked = true;
					}
				});
	  
			// Синхронизируем отображение
				syncCategorySelection();
		}

		// === Загрузка текучной категории заявки ===
		async function loadTicketCategory(ticket_id) {
			try {
				const response = await fetch('/tickets_list');
				const tickets = await response.json();
				const ticket = tickets.find(t => t.ticket_id == ticket_id);
		
				if (ticket && ticket.category) {
					const categories = ticket.category.split(',').map(cat => cat.trim());
					const select = document.getElementById('ticketCategorySelect');
		  
					// Снимаем все выделения
					Array.from(select.options).forEach(option => {
						option.selected = categories.includes(option.value);
					});
				}
			}
			catch (error) {
				console.error("Ошибка загрузки категории:", error);
			}
		}

		// === Сохранение категории заявки ===
		async function saveTicketCategory() {
			// Получаем выбранные чекбоксы
			const checkboxes = document.querySelectorAll('.category-checkbox:checked');
			const selectedCategories = Array.from(checkboxes).map(checkbox => checkbox.value);
	  
			if (selectedCategories.length === 0) {
				alert('Выберите хотя бы одну категорию');
				return;
			}

			try {
				const response = await fetch('/update_ticket_category', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({
						ticket_id: currentTicketId,
						category: selectedCategories.join(', ')
					})
				});

				const data = await response.json();
				if (data.success) {
					alert('✅ Категория обновлена');
				} 
				else {
					alert('❌ Ошибка: ' + data.error);
				}
			} 
			catch (error) {
				console.error('Ошибка сохранения категории:', error);
				alert('❌ Ошибка при сохранении категории');
			}
		}

		// === Обработка Enter/Ctrl+Enter ===
		document.getElementById('replyTextInHistory').addEventListener('keydown', function (e) {
		  const mode = localStorage.getItem('sendKeySetting') || 'enter';

			if (e.key === 'Enter') {
				if (mode === 'enter' && !e.shiftKey && !e.ctrlKey) {
					e.preventDefault();
					document.getElementById('sendReplyInHistory').click();
				} 
				else if (mode === 'ctrlEnter' && (e.ctrlKey || e.metaKey)) {
					e.preventDefault();
					document.getElementById('sendReplyInHistory').click();
				} 
				else if (mode === 'enterNewline' && (e.ctrlKey || e.metaKey)) {
					e.preventDefault();
					document.getElementById('sendReplyInHistory').click();
				}
			}
		});

	// === Отправить ответ из истории ===
	const sendReplyInHistoryBtn = document.getElementById('sendReplyInHistory');
	if (sendReplyInHistoryBtn) {
	  sendReplyInHistoryBtn.onclick = async function () {
		const ta = document.getElementById('replyTextInHistory');
		const text = ta.value.trim();
		if (!text) return;
		const admin = getOperatorName();
		const container = document.getElementById('historyContent');
		const wasAtBottom = isAtBottom(container);
		this.disabled = true;
		// === ДИАГНОСТИКА ПЕРЕД ОТПРАВКОЙ ===
		console.log('=== ДИАГНОСТИКА ПЕРЕД ОТПРАВКОЙ СООБЩЕНИЯ ===');
		console.log('Текущий ticket_id:', currentTicketId);
		console.log('Текущий user_id:', currentUserId);
		
		const currentTicket = window.allTickets?.find(t => String(t.ticket_id) === String(currentTicketId));
		if (currentTicket) {
		  console.log('Текущий статус заявки:', currentTicket.status);
		  console.log('Raw статус:', currentTicket.raw_status);
		  console.log('Дата создания:', currentTicket.created_date);
		  console.log('Время создания:', currentTicket.created_time);
		} else {
		  console.log('Заявка не найдена в allTickets');
		}
		console.log('==============================');
		try {
		  let resp, data;
		  if (window.currentEditTgId) {
			// Редактирование
			const fd = new FormData();
			fd.append('user_id', String(currentUserId));
			fd.append('ticket_id', String(currentTicketId));
			fd.append('tg_message_id', String(window.currentEditTgId));
			fd.append('text', text);
			resp = await fetch('/message_edit', { method: 'POST', body: fd });
			data = await resp.json();
			if (!data.success) throw new Error(data.error || 'Ошибка редактирования');
			window.currentEditTgId = null;
			if (window.clearChip) window.clearChip();
		  } else {
			// Обычная отправка
                        resp = await fetch('/reply', {
                          method: 'POST',
                          headers: { 'Content-Type': 'application/json' },
                          body: JSON.stringify({
                                user_id: currentUserId,
                                text,
                                admin,
                                ticket_id: currentTicketId,
                                reply_to_tg_id: (window.currentReplyToTgId || null)
                          })
                        });
                        data = await resp.json();
                                if (!data.success) throw new Error(data.error || 'Ошибка отправки');

                                updateTicketStatus(currentTicketId, 'Ожидает клиента');

                                try {
                                  await autoRefreshTickets();
                                } catch (e) {
                                  console.debug('Auto-refresh failed:', e);

                                }

                        window.currentReplyToTgId = null;
                        if (window.clearChip) window.clearChip();
		  }
		  
		  // Очищаем поле ввода
		  ta.value = '';
		  
		  // === ОБНОВЛЕНИЕ ИСТОРИИ ===
		  await updateHistory();
		  
		  const freshContainer = document.getElementById('historyContent');
		  if (freshContainer) {
			if (wasAtBottom) {
			  freshContainer.scrollTop = freshContainer.scrollHeight;
			}
			lastReadAtByTicket[currentTicketId] = Date.now();
			setUnread(0);
		  }
		  
		} catch (error) {
		  console.error('Ошибка отправки:', error);
		  alert('❌ ' + error.message);
		} finally {
		  this.disabled = false;
		}
	  };
	}
	// Функция для обновления статуса заявки локально
	function updateTicketStatus(ticketId, newStatus) {
	  console.log('🔄 Обновление статуса заявки:', ticketId, '->', newStatus);
	  
	  const found = findTicketEverywhere(ticketId);
	  if (!found) {
		console.log('❌ Не могу обновить статус: заявка не найдена');
		return false;
	  }
	  
	  const { source, ticket } = found;
	  
	  // Обновляем данные в зависимости от источника
	  if (source === 'allTickets' || source === 'filteredTickets') {
		// Обновляем в allTickets
		if (Array.isArray(window.allTickets)) {
		  const ticketIndex = window.allTickets.findIndex(t => String(t.ticket_id) === String(ticketId));
		  if (ticketIndex >= 0) {
                        const ticket = window.allTickets[ticketIndex];
                        ticket.status = newStatus;
                        if (newStatus === 'Ожидает клиента') ticket.raw_status = 'pending';
                        else if (newStatus === 'Открыта') ticket.raw_status = 'open';
                        else if (newStatus === 'Закрыта') ticket.raw_status = 'closed';
                        else if (newStatus === 'Ожидает оператора') ticket.raw_status = 'active';
                        else if (newStatus === 'Решено') ticket.raw_status = 'resolved';
                        else ticket.raw_status = 'pending';
                        const statusLower = String(newStatus || '').toLowerCase();
                        const isResolvedLike = statusLower.includes('решен') || statusLower.includes('закры');
                        ticket.resolved_by = isResolvedLike ? ticket.resolved_by : null;
                        console.log('✅ Статус обновлен в allTickets');
		  }
		}
		
		// Обновляем в filteredTickets
		if (Array.isArray(window.filteredTickets)) {
		  const filteredIndex = window.filteredTickets.findIndex(t => String(t.ticket_id) === String(ticketId));
		  if (filteredIndex >= 0) {
                        const filteredTicket = window.filteredTickets[filteredIndex];
                        filteredTicket.status = newStatus;
                        if (newStatus === 'Ожидает клиента') filteredTicket.raw_status = 'pending';
                        else if (newStatus === 'Открыта') filteredTicket.raw_status = 'open';
                        else if (newStatus === 'Закрыта') filteredTicket.raw_status = 'closed';
                        else if (newStatus === 'Ожидает оператора') filteredTicket.raw_status = 'active';
                        else if (newStatus === 'Решено') filteredTicket.raw_status = 'resolved';
                        else filteredTicket.raw_status = 'pending';
                        const statusLower = String(newStatus || '').toLowerCase();
                        const isResolvedLike = statusLower.includes('решен') || statusLower.includes('закры');
                        filteredTicket.resolved_by = isResolvedLike ? filteredTicket.resolved_by : null;
                        console.log('✅ Статус обновлен в filteredTickets');
		  }
		}
		// === СИНХРОНИЗАЦИЯ С ALLTICKETS ===
		try {
		  const fullTicket = allTickets?.find(t => String(t.ticket_id) === String(ticketId));
		  if (fullTicket) {
                        fullTicket.status = newStatus;
                        // подстраховка: корректируем raw_status под конкретное значение
                        if (newStatus === 'Ожидает клиента') fullTicket.raw_status = 'pending';
                        else if (newStatus === 'Открыта') fullTicket.raw_status = 'open';
                        else if (newStatus === 'Закрыта') fullTicket.raw_status = 'closed';
                        else if (newStatus === 'Ожидает оператора') fullTicket.raw_status = 'active';
                        else if (newStatus === 'Решено') fullTicket.raw_status = 'resolved';
                        else fullTicket.raw_status = 'pending';
                        const statusLower = String(newStatus || '').toLowerCase();
                        const isResolvedLike = statusLower.includes('решен') || statusLower.includes('закры');
                        fullTicket.resolved_by = isResolvedLike ? fullTicket.resolved_by : null;
                        console.log(`✅ Статус обновлен в allTickets: ${newStatus}`);
		  }
		} catch (e) {
		  console.warn('⚠️ Не удалось обновить статус в allTickets:', e);
		}
	  }
	  
	  // Всегда обновляем DOM
	  updateTicketStatusInTable(ticketId, newStatus);
	  
	  return true;
	}

	// Функция для принудительной проверки и обновления статуса
	function forceUpdateTicketStatus(ticketId, expectedNewStatus = 'Ожидает клиента') {
	  console.log('=== ПРИНУДИТЕЛЬНОЕ ОБНОВЛЕНИЕ СТАТУСА ===');
	  console.log('ticketId:', ticketId);
	  console.log('expectedNewStatus:', expectedNewStatus);
	  
	  // Обновляем в allTickets
	  if (Array.isArray(window.allTickets)) {
		const ticketIndex = window.allTickets.findIndex(t => String(t.ticket_id) === String(ticketId));
		if (ticketIndex >= 0) {
		  console.log('Старый статус:', window.allTickets[ticketIndex].status);
		  window.allTickets[ticketIndex].status = expectedNewStatus;
		  window.allTickets[ticketIndex].raw_status = (expectedNewStatus === 'Решено') ? 'resolved' : 'pending';
		  console.log('Новый статус в allTickets:', window.allTickets[ticketIndex].status);
		}
	  }
	  
	  // Немедленно обновляем отображение
	  updateTicketStatusInTable(ticketId, expectedNewStatus);
	  
	  // Принудительно перерисовываем таблицу
	  setTimeout(() => {
		if (window.filteredTickets && typeof displayTicketsForCurrentPageFiltered === 'function') {
		  displayTicketsForCurrentPageFiltered();
		} else if (typeof displayTicketsForCurrentPage === 'function') {
		  displayTicketsForCurrentPage();
		}
	  }, 100);
	}

// Функция для поиска заявки во всех источниках данных для отладочной информации
function findTicketEverywhere(ticketId) {
  console.log('🔍 Поиск заявки', ticketId, 'во всех источниках...');
  
  // Ищем в allTickets
  let ticket = window.allTickets?.find(t => String(t.ticket_id) === String(ticketId));
  if (ticket) {
    console.log('✅ Найдена в allTickets');
    return { source: 'allTickets', ticket };
  }
  
  // Ищем в filteredTickets
  ticket = window.filteredTickets?.find(t => String(t.ticket_id) === String(ticketId));
  if (ticket) {
    console.log('✅ Найдена в filteredTickets');
    return { source: 'filteredTickets', ticket };
  }
  
  // Ищем в DOM таблицы
  const rows = document.querySelectorAll('#ticketsBody tr');
  for (const row of rows) {
    const ticketIdCell = row.querySelector('code');
    if (ticketIdCell && ticketIdCell.textContent === String(ticketId)) {
      console.log('✅ Найдена в DOM таблицы');
      
      // Собираем данные из DOM
      const ticketData = {
        ticket_id: ticketId,
        status: row.querySelector('.badge')?.textContent?.trim() || 'Неизвестно',
        user_id: row.querySelector('.clickable-client')?.dataset?.userId || 'Неизвестно'
      };
      return { source: 'DOM', ticket: ticketData };
    }
  }
  
  console.log('❌ Заявка не найдена ни в одном источнике');
  return null;
}

	// Функция для обновления статуса в таблице
	function updateTicketStatusInTable(ticketId, newStatus) {
	  console.log('🔍 Поиск заявки в таблице DOM:', ticketId);
	  
	  const rows = document.querySelectorAll('#ticketsBody tr');
	  let found = false;
	  
	  rows.forEach(row => {
		const ticketIdCell = row.querySelector('code');
		if (ticketIdCell && ticketIdCell.textContent === String(ticketId)) {
		  found = true;
		  const statusCell = row.querySelector('td:nth-child(9)'); // 9-я колонка - статус
		  
		  if (statusCell) {
                        // Создаем новый бейдж статуса
                        let statusBadge = '';
                        if (newStatus === 'Ожидает клиента') {
                          statusBadge = '<span class="badge bg-info text-dark">⏳ Ожидает клиента</span>';
                        } else if (newStatus === 'Ожидает реакции') {
                          statusBadge = '<span class="badge bg-danger">⏳ Ожидает реакции</span>';
                        } else if (newStatus === 'Новая') {
                          statusBadge = '<span class="badge bg-secondary">🆕 Новая</span>';
                        } else if (newStatus === 'Решено') {
                          statusBadge = '<span class="badge bg-success">✅ Решено</span>';
                        } else {
                          statusBadge = `<span class="badge bg-warning">${newStatus}</span>`;
                        }

                        let unreadBadge = statusCell.querySelector('.unread-badge');
                        if (!unreadBadge) {
                          unreadBadge = document.createElement('span');
                          unreadBadge.className = 'badge bg-danger me-1 unread-badge';
                          unreadBadge.dataset.ticket = String(ticketId);
                          unreadBadge.style.display = 'none';
                          unreadBadge.textContent = '0';
                        }

                        const unreadValue = parseInt(unreadBadge.textContent, 10) || 0;
                        const ticketData = getTicketById(ticketId);
                        const canShowUnread = shouldDisplayUnreadBadge(ticketData, newStatus);

                        statusCell.innerHTML = '';
                        statusCell.insertAdjacentElement('afterbegin', unreadBadge);
                        statusCell.insertAdjacentHTML('beforeend', statusBadge);

                        unreadBadge.style.display = (unreadValue > 0 && canShowUnread) ? 'inline-flex' : 'none';
                        console.log('✅ Статус обновлен в DOM:', newStatus);
                  }
                }
          });

	  if (!found) {
		console.log('❌ Заявка не найдена в DOM таблицы');
		
		// Пытаемся обновить через перерисовку таблицы
		setTimeout(() => {
		  console.log('🔄 Попытка перерисовки таблицы...');
		  if (window.filteredTickets && typeof displayTicketsForCurrentPageFiltered === 'function') {
			displayTicketsForCurrentPageFiltered();
		  } else if (typeof displayTicketsForCurrentPage === 'function') {
			displayTicketsForCurrentPage();
		  }
		}, 500);
	  }
	}
	// === Отправка файлов из истории ===
	document.getElementById('replyFiles')?.addEventListener('change', async (e) => {
	  const files = Array.from(e.target.files || []);
	  if (!files.length) return;

	  // === ДИАГНОСТИКА ПЕРЕД ОТПРАВКОЙ ФАЙЛА ===
	  console.log('=== ДИАГНОСТИКА ПЕРЕД ОТПРАВКОЙ ФАЙЛА ===');
	  console.log('Текущий ticket_id:', currentTicketId);
	  
	  const currentTicket = window.allTickets?.find(t => String(t.ticket_id) === String(currentTicketId));
	  if (currentTicket) {
		console.log('Текущий статус заявки:', currentTicket.status);
		console.log('Raw статус:', currentTicket.raw_status);
	  }
	  console.log('==============================');
	  for (const file of files) {
		const fd = new FormData();
		fd.append('user_id', currentUserId);
		fd.append('ticket_id', currentTicketId);
		fd.append('admin', getOperatorName());
		fd.append('file', file);

		try {
		  if (window.currentReplyToTgId) {
			fd.append('reply_to_tg_id', String(window.currentReplyToTgId));
		  }
		  
		  const resp = await fetch('/reply_file', { method: 'POST', body: fd });
		  const j = await resp.json();
		  
		  if (!j.success) {
			alert('❌ Ошибка загрузки файла: ' + (j.error || ''));
			continue;
		  }

		  // Обновляем статус заявки после отправки файла оператором
		  if (j.success) {
			updateTicketStatus(currentTicketId, 'Ожидает клиента');
			try { 
			  await autoRefreshTickets(); 
			} catch(e) { 
			  console.debug('Auto-refresh failed:', e);
			}
		  }

		  // Обновляем историю
		  lastRenderedAt = null;
		  await updateHistory();
		  
		  // автоскролл
		  const container = document.getElementById('historyContent');
		  scrollToBottom(container);

		  lastReadAtByTicket[currentTicketId] = Date.now();
		  setUnread(0);
		  
		} catch (err) {
		  console.error('upload error', err);
		  alert('❌ Ошибка загрузки файла');
		}
	  }

	  // сбросить выбор
	  e.target.value = '';
	});

	// === Сохранить имя клиента ===
		async function saveClientName() {
			const newName = document.getElementById('clientNameInput').value.trim();
			const newUsername = document.getElementById('clientUsernameInput').value.trim();
			
			// Загружаем данные клиента заново
			try {
				const response = await fetch('/tickets_list');
				const allTickets = await response.json();
				const clientData = allTickets.find(t => t.user_id == currentUserId && t.ticket_id == currentTicketId);

				if (!newName && !newUsername) {
					alert('Введите хотя бы одно значение');
					return;
				}

				try {
					const response = await fetch('/update_client', {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify({
							user_id: currentUserId,
							client_name: newName,
							username: newUsername
						})
					});

					const data = await response.json();
					if (data.success) {
						alert('✅ Данные клиента обновлены');
						
						// Обновляем отображение имени в модальном окне истории
						const displayName = newName || newUsername || 'Клиент';
						document.getElementById('clientDisplayName').textContent = displayName;
						
						// Закрываем модальное окно редактирования
						bootstrap.Modal.getInstance(document.getElementById('editClientNameModal')).hide();
						
						// Обновляем данные в таблице (если она видима)
						if (window.refreshTicketsTable) {
							window.refreshTicketsTable();
						}
					} else {
						alert('❌ Ошибка при обновлении: ' + (data.error || 'Неизвестная ошибка'));
					}
				} catch (error) {
					console.error('Ошибка при сохранении имени:', error);
					alert('❌ Ошибка сети при сохранении имени');
				}
			} catch (error) {
				console.error('Ошибка при загрузке данных клиента:', error);
				alert('❌ Ошибка при загрузке данных клиента');
			}
		}

	// === Закрыть заявку (через отдельное окно) ===
	function getHistorySelectedCategories() {
                return Array.from(document.querySelectorAll('.category-checkbox:checked')).map(cb => cb.value);
        }

	async function performTicketClose(selectedCategories, triggerButton) {
                if (!Array.isArray(selectedCategories) || selectedCategories.length === 0) {
                        alert('❌ Выберите хотя бы одну категорию');
                        return;
                }

		const admin = getOperatorName();
                try {
                        triggerButton?.setAttribute('disabled', 'disabled');

                        const response = await fetch('/close_ticket', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                        user_id: currentUserId,
                                        admin,
                                        category: selectedCategories.join(', '),
                                        ticket_id: currentTicketId
                                })
                        });

                        const data = await response.json();
                        if (!data.success) {
                                alert('❌ Ошибка: ' + (data.error || 'Не удалось закрыть заявку'));
                                return;
                        }

                        const closeModalEl = document.getElementById('closeTicketModal');
                        if (closeModalEl) {
                                const instance = bootstrap.Modal.getInstance(closeModalEl);
                                instance?.hide();
                        }

                        const successModalEl = document.getElementById('ticketClosedModal');
                        if (successModalEl) {
                                bootstrap.Modal.getOrCreateInstance(successModalEl).show();
                        } else {
                                alert('✅ Заявка закрыта');
                                location.reload();
                        }
                } catch (error) {
                        console.error('Ошибка закрытия заявки:', error);
                        alert('❌ Ошибка: ' + (error?.message || error));
                } finally {
                        triggerButton?.removeAttribute('disabled');
                }
        }

		document.getElementById('closeTicketBtn').onclick = function () {
                const historySelected = getHistorySelectedCategories();
                if (historySelected.length > 0) {
                        performTicketClose(historySelected, this);
                        return;
                }

                syncCloseCategoriesFromHistory();
                const modal = new bootstrap.Modal(document.getElementById('closeTicketModal'));
                modal.show();
        };

        // === Подтвердить закрытие ===
        document.getElementById('confirmCloseTicketBtn').onclick = async function() {
                const selectedCategories = syncCloseCategorySelection();
                await performTicketClose(selectedCategories, this);
        };

	// === Синхронизация выбора категорий ===
	function syncCategorySelection() {
		const checkboxes = document.querySelectorAll('.category-checkbox:checked');
		const selectedContainer = document.getElementById('selectedCategories');
  
		// Обновляем отображение выбранных категорий
			const selectedValues = Array.from(checkboxes).map(cb => cb.value);
  
			if (selectedValues.length > 0) {
				selectedContainer.textContent = 'Выбрано: ' + selectedValues.join(', ');
				document.getElementById('categoryDropdown').textContent = `Выбрано: ${selectedValues.length} категорий`;
			} 
			else {
				selectedContainer.textContent = '';
				document.getElementById('categoryDropdown').textContent = 'Выберите категории...';
			}
  
		return selectedValues;
	}


	// Обработчики событий для чекбоксов
		document.addEventListener('DOMContentLoaded', function() {
			document.querySelectorAll('.close-category-checkbox').forEach(checkbox => {
				checkbox.addEventListener('change', syncCloseCategorySelection);
			});
		});
	// Обработчики для чекбоксов категорий
		document.querySelectorAll('.category-checkbox').forEach(checkbox => {
			checkbox.addEventListener('change', syncCategorySelection);
		});
  
		document.querySelectorAll('.close-category-checkbox').forEach(checkbox => {
			checkbox.addEventListener('change', syncCloseCategorySelection);
		});
	
		// === Подтвердить закрытие (из основного окна) ===
		function confirmClose(user_id, ticket_id) {
			if (confirm("Завершить заявку?")) {
				loadHistory(user_id, ticket_id);
			}
		}
		// Обработчик ошибок загрузки изображений
		document.addEventListener('DOMContentLoaded', function() {
			document.body.addEventListener('error', function(e) {
				if (e.target.tagName === 'IMG' && e.target.classList.contains('img-thumbnail')) {
					const img = e.target;
					const fallback = img.nextElementSibling;
					if (fallback && fallback.classList.contains('text-muted')) {
						img.style.display = 'none';
						fallback.style.display = 'block';
					}
				}
			}, true);
		});
		
	// список базовых таймзон (можно расширить)
  const DEFAULT_TZ = localStorage.getItem('its_operator_tz') || Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC';

	function fmtTsISO(iso, tz = getOperatorTZ()) {
	  const d = new Date(iso);
	  if (isNaN(d.getTime())) return iso;
	  return new Intl.DateTimeFormat('ru-RU', {
		timeZone: tz,
		year: 'numeric', month: '2-digit', day: '2-digit',
		hour: '2-digit', minute: '2-digit', second: '2-digit'
	  }).format(d);
	}

	function getOperatorTZ() {
	  const saved = localStorage.getItem('its_operator_tz') || 'UTC';
	  return saved === 'browser' ? 'UTC' : saved;
	}

	function setOperatorTZ(value) {
	  localStorage.setItem('its_operator_tz', value);
	  const tz = value === 'browser' ? 'UTC' : value;
	  // Перерисовать все временные метки
	  document.querySelectorAll('.msg-time[data-iso]').forEach(el => {
		el.textContent = fmtTsISO(el.dataset.iso, tz);
	  });
	  // Обновить таблицу
	  if (window.filteredTickets && typeof displayTicketsForCurrentPageFiltered === 'function') {
		displayTicketsForCurrentPageFiltered();
		if (typeof updatePaginationFiltered === 'function') updatePaginationFiltered();
	  } else if (typeof displayTicketsForCurrentPage === 'function') {
		displayTicketsForCurrentPage();
		if (typeof updatePagination === 'function') updatePagination();
	  }
	}

  (function(){
    const sel = document.getElementById('tzSelect');
    if (!sel) return;
    // инициализация значением из localStorage (или 'browser')
    const stored = localStorage.getItem('its_operator_tz') || 'browser';
    // если такого option нет — не страшно
    if ([...sel.options].some(o => o.value === stored)) sel.value = stored;
    // обработчик изменения
    sel.addEventListener('change', (e) => setOperatorTZ(e.target.value));
  })();
  async function createTaskFromDialog(problem, location) {
    try {
      const r = await fetch('/api/tasks/from_dialog', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'same-origin',
        body: JSON.stringify({ problem, location })
      });
      if (!r.ok) {
        const txt = await r.text();
        alert('Не удалось создать задачу: ' + txt);
        return;
      }
      // после успешного создания — переходим на страницу задач
      window.location.href = '/tasks';
    } catch (e) {
      alert('Ошибка сети при создании задачи');
    }
  }
	</script>
<div class="modal fade" id="imageModal" tabindex="-1">
  <div class="modal-dialog modal-dialog-centered modal-xl">
    <div class="modal-content bg-dark">
      <div class="modal-body p-0">
        <img id="imageModalImg" class="w-100" alt="Просмотр изображения">
      </div>
    </div>
  </div>
</div>
<div class="modal fade" id="imageViewerModal" tabindex="-1">
  <div class="modal-dialog modal-dialog-centered modal-xl">
    <div class="modal-content bg-dark">
      <div class="modal-body p-0 text-center">
        <img id="imageViewerImg" src="" alt="media" style="max-width:100%; max-height:85vh;">
      </div>
    </div>
  </div>
</div>
<!-- Модалка превью изображения -->
<div class="modal fade" id="imagePreviewModal" tabindex="-1">
  <div class="modal-dialog modal-dialog-centered modal-lg">
    <div class="modal-content">
      <div class="modal-body p-0">
        <img id="imagePreviewFull" src="" alt="preview" style="width:100%; height:auto; display:block;">
      </div>
      <div class="modal-footer py-2">
        <button type="button" class="btn btn-secondary btn-sm" data-bs-dismiss="modal">Закрыть</button>
        <a id="imageDownloadLink" class="btn btn-primary btn-sm" href="#" download>Скачать</a>
      </div>
    </div>
  </div>
</div>
<!-- Twemoji -->
<script src="{{ url_for('static', filename='vendor/twemoji/twemoji.min.js') }}"></script>
<script>
  function parseEmojis(root) {
    if (!window.twemoji) return;
    twemoji.parse(root || document.body, {
      folder: 'svg',
      ext: '.svg',
      base: "{{ url_for('static', filename='vendor/twemoji/') }}",
      className: 'emoji',
      // ← критично: инлайновые размеры/выравнивание, чтобы Firefox не «сжимал»
      attributes: function () {
        return {
          draggable: 'false',
          style: [
            'display:inline-block',
            'width:1em',
            'height:1em',
            'max-width:none',
            'max-height:none',
            'vertical-align:-0.12em',
            'border:0',
            'padding:0',
            'background:transparent'
          ].join(';')
        };
      }
    });
  }
</script>

<script>
  // Парсим эмодзи в указанном контейнере (или во всём документе)
  function parseEmojis(root) {
    try {
      twemoji.parse(root || document.body, { folder: 'svg', ext: '.svg', className: 'emoji' });
    } catch (e) { /* no-op */ }
  }
  // Первичный проход после загрузки DOM
  document.addEventListener('DOMContentLoaded', function () { parseEmojis(document.body); });
</script>
<script>
(function () {
  function showAvatar(src) {
    const fallbackSrc = '/static/default-avatar.png';
    let prepared = ensureFullAvatarUrl(src);
    if (!prepared) {
      const normalized = normalizeAvatarUrl(src);
      prepared = normalized || fallbackSrc;
    }

    // ИСПРАВЛЕНИЕ: используем правильную модалку для аватара
    const modalEl = document.getElementById('avatarModal');
    const modalImg = document.getElementById('avatarModalImg');
    const downloadLink = document.getElementById('avatarDownloadLink');

    if (!modalEl || !modalImg) {
      console.error('Modal elements not found');
      return;
    }

    const updateDownloadLink = (nextSrc) => {
      if (!downloadLink) return;
      downloadLink.href = nextSrc;
      downloadLink.download = 'avatar.jpg';
    };

    const currentSrc = modalImg.getAttribute('src') || '';
    const isSameSrc = currentSrc === prepared;

    if (!isSameSrc) {
      modalImg.style.opacity = '0';
    }

    modalImg.alt = 'Фото клиента';

    modalImg.onload = () => {
      modalImg.style.opacity = '1';
      modalImg.onload = null;
      modalImg.onerror = null;
    };

    modalImg.onerror = () => {
      if (!modalImg.src.includes(fallbackSrc)) {
        modalImg.src = fallbackSrc;
        updateDownloadLink(fallbackSrc);
        return;
      }

      modalImg.style.opacity = '1';
      modalImg.onerror = null;
    };

    if (isSameSrc) {
      if (modalImg.complete && modalImg.naturalWidth > 0) {
        modalImg.style.opacity = '1';
        modalImg.onload = null;
        modalImg.onerror = null;
      } else {
        modalImg.src = '';
        modalImg.src = prepared;
      }
    } else {
      modalImg.src = prepared;
    }

    updateDownloadLink(prepared);

    if (modalImg.complete && modalImg.naturalWidth > 0) {
      modalImg.style.opacity = '1';
      modalImg.onload = null;
      modalImg.onerror = null;
    }

    modalImg.dataset.currentSrc = prepared;

    const modalInstance = bootstrap.Modal.getOrCreateInstance(modalEl);
    modalInstance.show();
  }

  const avaInHistory = document.getElementById('clientAvatarInHistory');
  if (avaInHistory) {
    avaInHistory.style.cursor = 'zoom-in';
    avaInHistory.addEventListener('click', function () {
      const fullSrc = this.dataset.fullsrc || this.src;
      showAvatar(fullSrc);
    });
  }
})();

document.addEventListener('click', async (e)=>{
  const btn = e.target.closest('.create-task-btn');
  if (!btn) return;
  const payload = {
    problem: btn.dataset.problem || '',
    location: btn.dataset.location || ''
  };
  try {
    const r = await fetch('/api/tasks/from_dialog', {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      credentials:'same-origin',
      body: JSON.stringify(payload)
    });
    if (r.status === 401) { alert('Сессия истекла. Войдите заново.'); window.location.href='/login'; return; }
    const data = await r.json();
    if (data && data.ok) { window.location.href = '/tasks'; }
    else { alert(data && data.error ? data.error : 'Не удалось создать задачу'); }
  } catch (error) {
      console.error('Не удалось создать задачу из диалога:', error);
      alert('Сеть недоступна. Попробуйте ещё раз.');
  }
});

document.addEventListener('click', async (e)=>{
  // открыть задачу по кнопке №DL_id
  const btnOpen = e.target.closest('.open-task-btn');
  if (btnOpen) {
    const taskId = btnOpen.dataset.taskId;
    window.location.href = `/tasks#task=${taskId}`;
    return;
  }

  // создать задачу из диалога
  const btn = e.target.closest('.create-task-btn');
  if (!btn) return;
  const payload = {
    problem: btn.dataset.problem || '',
    location: btn.dataset.location || '',
    ticket_id: btn.dataset.ticket || ''
  };
  try {
    const r = await fetch('/api/tasks/from_dialog', {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      credentials:'same-origin',
      body: JSON.stringify(payload)
    });
    if (r.status === 401) { alert('Сессия истекла. Войдите заново.'); window.location.href='/login'; return; }
    const data = await r.json();
    if (data && data.ok) {
      // меняем кнопку на номер задачи
      btn.outerHTML = `<button class="btn btn-sm btn-outline-primary open-task-btn" data-task-id="${data.id}">№DL_${data.id}</button>`;
      // помечаем тикет активным за текущим юзером
      try { await fetch(`/api/tickets/${payload.ticket_id}/active`, {method:'POST', credentials:'same-origin'}); } catch(_){}
    } else {
      alert(data && data.error ? data.error : 'Не удалось создать задачу');
    }
  } catch (error) {
      console.error('Не удалось открыть задачу по номеру:', error);
      alert('Сеть недоступна. Попробуйте ещё раз.');
  }
});

  (function(){
    function openFromHash(){
      const h = location.hash || '';
      // формат: #open=ticket:<id>
      const m = h.match(/#open=ticket:([^&]+)/);
      if (m) {
        const ticketId = decodeURIComponent(m[1]);
        // user_id не знаем — у тебя loadHistory(user_id, ticket_id) принимает user_id,
        // подставим 0: сервер всё равно грузит по ticket_id.
        loadHistory(0, ticketId);
      }
    }
    window.addEventListener('hashchange', openFromHash);
    openFromHash();
  })();

  document.addEventListener('DOMContentLoaded', function () {
    const sel = document.getElementById('tzSelect');
    if (!sel) return; // ← защита: если селекта нет, ничего не делаем

    // восстановление сохранённого значения
    const stored = localStorage.getItem('its_operator_tz') || 'browser';
    if ([...sel.options].some(o => o.value === stored)) {
      sel.value = stored;
    }

    // реагируем на смену TZ
    sel.addEventListener('change', (e) => {
      const tz = e.target.value;
      // если в проекте есть твоя функция — используем её,
      // иначе просто сохраняем в localStorage и перезагружаем.
      if (typeof setOperatorTZ === 'function') {
        setOperatorTZ(tz);
      } else {
        localStorage.setItem('its_operator_tz', tz);
        location.reload();
      }
    });
  });

	// Функции для работы с модальными фильтрами
	function applyFiltersModal() {
		  // Получаем значения напрямую из модального окна
		  const status = document.getElementById('filterStatusModal')?.value || '';
		  const user = document.getElementById('filterUserModal')?.value.toLowerCase() || '';
		  const ticketId = document.getElementById('filterTicketIdModal')?.value.toLowerCase() || '';
		  const business = document.getElementById('filterBusinessModal')?.value.toLowerCase() || '';
		  const location = document.getElementById('filterLocationModal')?.value.toLowerCase() || '';
		  const clientStatus = document.getElementById('filterClientStatusModal')?.value.toLowerCase() || '';
		  const responsible = document.getElementById('filterResponsibleModal')?.value.toLowerCase() || '';
		  const dateFrom = document.getElementById('filterDateFromModal')?.value || '';
		  const dateTo = document.getElementById('filterDateToModal')?.value || '';

		  // Фильтруем ВСЕ заявки
		  const filteredTickets = allTickets.filter(t => {
			const searchIndex = [
			  String(t.user_id || ''),
			  String(t.ticket_id || ''),
			  String(t.client_status || ''),
			  String(t.channel_name || ''),
			  String(t.business || ''),
			  String(t.city || ''),
			  String(t.location_name || ''),
			  String(t.problem || ''),
			  String(t.responsible || ''),
			  String(t.raw_status || ''),
			  String(t.status || ''),
			  String(t.created_date || ''),
			  String(t.created_time || ''),
			  String(t.username || ''),
			  String(t.client_name || '')
			].join(' ').toLowerCase();

			const createdDate = t.created_date || '';
			
			const matches = (!status || searchIndex.includes(status)) &&
						  (!user || searchIndex.includes(user)) &&
						  (!ticketId || searchIndex.includes(ticketId)) &&
						  (!business || searchIndex.includes(business)) &&
						  (!location || searchIndex.includes(location)) &&
						  (!responsible || searchIndex.includes(responsible)) &&
						  (!clientStatus || searchIndex.includes(clientStatus)) &&
						  (!dateFrom || createdDate >= dateFrom) &&
						  (!dateTo || createdDate <= dateTo);

			return matches;
		  });

		  // Обновляем отображаемые данные
		  displayFilteredTickets(filteredTickets);
		  
		  // Показываем активные фильтры
		  showActiveFiltersModal();
		  
		  // Закрываем модальное окно
		  const modalInstance = bootstrap.Modal.getInstance(document.getElementById('filtersModal'));
		  if (modalInstance) {
			modalInstance.hide();
		  }
	}

	function resetFiltersModal() {
	  // Сбрасываем значения в модальном окне
	  const modalFilterIds = [
		'filterStatusModal', 'filterUserModal', 'filterTicketIdModal', 
		'filterBusinessModal', 'filterLocationModal', 'filterClientStatusModal', 
		'filterResponsibleModal', 'filterDateFromModal', 'filterDateToModal'
	  ];
	  
	  modalFilterIds.forEach(id => {
		const element = document.getElementById(id);
		if (element) {
		  element.value = '';
		}
	  });
	  
	  // Сбрасываем основные фильтры
	  resetFilters();
	  // Сбрасываем активные фильтры в модальном окне
	  showActiveFiltersModal();
	  // Скрываем активные фильтры
	  const activeContainer = document.getElementById('activeFiltersModal');
	  if (activeContainer) {
		activeContainer.style.display = 'none';
	  }
	}

	function showActiveFiltersModal() {
	  const badgesContainer = document.getElementById('filterBadgesModal');
	  const activeContainer = document.getElementById('activeFiltersModal');
	  
	  if (!badgesContainer || !activeContainer) return;
	  
	  badgesContainer.innerHTML = '';
	  let hasActiveFilters = false;
	  
	  // Проверяем каждый фильтр и добавляем бейдж, если есть значение
	  const filters = [
		{ id: 'filterStatusModal', label: 'Статус' },
		{ id: 'filterUserModal', label: 'ID клиента' },
		{ id: 'filterTicketIdModal', label: 'ID заявки' },
		{ id: 'filterBusinessModal', label: 'Бизнес' },
		{ id: 'filterLocationModal', label: 'Локация' },
		{ id: 'filterClientStatusModal', label: 'Статус клиента' },
		{ id: 'filterResponsibleModal', label: 'Ответственный' },
		{ id: 'filterDateFromModal', label: 'Дата от' },
		{ id: 'filterDateToModal', label: 'Дата до' }
	  ];
	  
	  filters.forEach(filter => {
		const element = document.getElementById(filter.id);
		if (element && element.value) {
		  hasActiveFilters = true;
		  const badge = document.createElement('span');
		  badge.className = 'badge bg-primary filter-badge';
		  badge.innerHTML = `${filter.label}: ${element.value} 
			<span style="cursor:pointer; margin-left:5px;" onclick="removeFilterModal('${filter.id}')">×</span>`;
		  badgesContainer.appendChild(badge);
		}
	  });
	  
	  activeContainer.style.display = hasActiveFilters ? 'block' : 'none';
	}

	function removeFilterModal(filterId) {
  // Сбрасываем конкретный фильтр в модальном окне
	  const modalElement = document.getElementById(filterId);
	  if (modalElement) {
		modalElement.value = '';
	  }
	  
	  // Если модальное окно открыто, обновляем отображение
	  if (document.getElementById('filtersModal').classList.contains('show')) {
		showActiveFiltersModal();
	  } else {
		// Если модальное окно закрыто, применяем изменения
		applyFiltersModal();
	  }
	}

	// Инициализация при загрузке страницы
		document.addEventListener('DOMContentLoaded', function() {
		  // Показываем активные фильтры при открытии модального окна
		  document.getElementById('filtersModal').addEventListener('show.bs.modal', function() {
			// Синхронизируем значения из основных фильтров в модальные
			const mainFilters = [
			  'filterStatus', 'filterUser', 'filterTicketId', 'filterBusiness', 
			  'filterLocation', 'filterClientStatus', 'filterResponsible', 
			  'filterDateFrom', 'filterDateTo'
			];
			
			mainFilters.forEach(filterId => {
			  const mainEl = document.getElementById(filterId);
			  const modalEl = document.getElementById(filterId + 'Modal');
			  
			  if (mainEl && modalEl) {
				modalEl.value = mainEl.value;
			  }
			});
			
			showActiveFiltersModal();
		  });
		});


// === Ресайзер левой панели в истории ===
function initHistoryPaneResizer() {
  const resizer = document.getElementById('historyPaneResizer');
  const sidebarPane = document.querySelector('.sidebar-pane');
  const historyPane = document.querySelector('.history-pane');
  
  if (!resizer || !sidebarPane || !historyPane) return;

  let isResizing = false;
  let startX, startWidth;

  resizer.addEventListener('mousedown', function(e) {
    isResizing = true;
    startX = e.clientX;
    startWidth = sidebarPane.getBoundingClientRect().width;
    
    document.documentElement.classList.add('resizing');
    resizer.classList.add('resizing');
    
    // Добавляем overlay для предотвращения выделения текста
    const overlay = document.createElement('div');
    overlay.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: transparent;
      z-index: 9999;
      cursor: col-resize;
    `;
    overlay.id = 'resizeOverlay';
    document.body.appendChild(overlay);
    
    e.preventDefault();
  });

  function onMouseMove(e) {
    if (!isResizing) return;
    
    const width = startWidth + (e.clientX - startX);
    const minWidth = 300;
    const maxWidth = window.innerWidth * 0.7;
    
    if (width >= minWidth && width <= maxWidth) {
      sidebarPane.style.width = width + 'px';
      sidebarPane.style.flex = '0 0 auto';
      
      // Принудительный reflow для обновления layout
      sidebarPane.offsetHeight;
    }
  }

  function onMouseUp() {
    if (!isResizing) return;
    
    isResizing = false;
    document.documentElement.classList.remove('resizing');
    resizer.classList.remove('resizing');
    
    // Удаляем overlay
    const overlay = document.getElementById('resizeOverlay');
    if (overlay) overlay.remove();
    
    document.removeEventListener('mousemove', onMouseMove);
    document.removeEventListener('mouseup', onMouseUp);
    
    // Сохраняем ширину в localStorage
    const width = sidebarPane.getBoundingClientRect().width;
    localStorage.setItem('historySidebarWidth', width);
  }

  document.addEventListener('mousemove', onMouseMove);
  document.addEventListener('mouseup', onMouseUp);
}

// Восстановление сохраненной ширины
function restoreSidebarWidth() {
  const savedWidth = localStorage.getItem('historySidebarWidth');
  const sidebarPane = document.querySelector('.sidebar-pane');
  
  if (savedWidth && sidebarPane) {
    sidebarPane.style.width = savedWidth + 'px';
    sidebarPane.style.flex = '0 0 auto';
  }
}

// Инициализация при загрузке модального окна
	document.getElementById('historyModal').addEventListener('shown.bs.modal', function() {
		historyModalIsOpen = true;
		  restoreSidebarWidth();
		  initHistoryPaneResizer();
	});

const ticketClosedModalEl = document.getElementById('ticketClosedModal');
if (ticketClosedModalEl) {
  ticketClosedModalEl.addEventListener('hidden.bs.modal', () => {
    location.reload();
  });
}

// Обработчик изменения размера окна
window.addEventListener('resize', function() {
  const sidebarPane = document.querySelector('.sidebar-pane');
  if (sidebarPane) {
    const currentWidth = sidebarPane.getBoundingClientRect().width;
    const maxWidth = window.innerWidth * 0.7;
    
    if (currentWidth > maxWidth) {
      sidebarPane.style.width = maxWidth + 'px';
    }
  }
});

// Инициализация при загрузке страницы
document.addEventListener('DOMContentLoaded', function() {
  // Восстановление счётчиков непрочитанных
  const savedUnread = localStorage.getItem('unreadCountByTicket');
  if (savedUnread) {
    unreadCountByTicket = JSON.parse(savedUnread);
  }

  // Принудительное обновление счётчиков в таблице
  setTimeout(() => {
    refreshUnreadIndicators();
  }, 1000);
});
window.currentUser = CURRENT_OPERATOR;
</script>

<!-- Модальное окно для просмотра аватара -->
<div class="modal fade" id="avatarModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered modal-lg">
    <div class="modal-content bg-dark">
      <div class="modal-header border-0">
        <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Закрыть"></button>
      </div>
      <div class="modal-body p-0 text-center">
        <img id="avatarModalImg" src="" alt="Аватар клиента" style="max-width: 100%; max-height: 80vh; object-fit: contain;">
      </div>
      <div class="modal-footer border-0 justify-content-center">
        <a id="avatarDownloadLink" class="btn btn-primary" href="#" download="avatar.jpg">
          <i class="bi bi-download"></i> Скачать
        </a>
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Закрыть</button>
      </div>
    </div>
  </div>
</div>
  </main>
  <script src="{{ url_for('static', filename='sidebar.js') }}"></script>
</body>
</html>
